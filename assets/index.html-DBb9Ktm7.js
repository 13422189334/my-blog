import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as i,c as a,d as g,a as t,f as p,w as l,e as o,b as n}from"./app-D0oP6OJV.js";const c={},h=n('<h2 id="简述" tabindex="-1"><a class="header-anchor" href="#简述"><span>简述</span></a></h2><figure><img src="https://shaohui-jin.github.io/picx-images-hosting/blog/浏览器进程模型.6pn9qxux5f.webp" alt="浏览器进程模型" width="800" tabindex="0" loading="lazy"><figcaption>浏览器进程模型</figcaption></figure><p>JS是一门单线程的语言，这是因为它运行在浏览器的 <strong>渲染主线程</strong> 中，而 <strong>渲染主线程</strong> 只有一个。</p><p>而渲染主线程承担着诸多的工作，<strong>渲染页面</strong>、<strong>执行JS</strong> 都在其中运行。</p><p>如果使用同步的方式，就极有可能导致主线程产生 <strong>阻塞</strong>，从而导致消息队列中的很多其他任务无法得到执行。</p><p>这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。</p><p>具体做法是当某些任务发生时，比如 <strong>计时器</strong>、<strong>网络</strong>、<strong>事件监听</strong>，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。</p><p>当其他线程完成时，将事先传递的<strong>回调函数包装成任务</strong>，加入到 <strong>消息队列</strong> 的 <strong>末尾排队</strong>，等待主线程调度执行。</p><p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p><p>在目前 chrome 的实现中，至少包含了下面的队列: 延时队列:用于存放计时器到达后的回调任务，优先级「中」 交互队列:用于存放用户操作后产生的事件处理任务，优先级「高」 微队列:用户存放需要最快执行的任务，优先级「最高」</p>',10),d=n('<p>事件循环又叫做消息循环，是浏览器 <strong>渲染主线程</strong> 的工作方式。 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出 <strong>第一个任务</strong>执行，而其他线程只需要在合适的时候将任务加入到 <strong>队列末尾</strong> 即可。 过去把消息队列简单分为 <strong>宏队列</strong> 和 <strong>微队列</strong>，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，<strong>同类型的任务必须在同一个队列</strong>，<strong>不同的任务可以属于不同的队列</strong>。 不同任务队列有 <strong>不同的优先级</strong>，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。</p><p>但浏览器 <strong>必须</strong> 有一个<strong>微队列</strong>，微队列的任务一定具有 <strong>最高的优先级</strong>，必须优先调度执行。</p><p>面试题:JS 中的计时器能做到精确计时吗?为什么?</p><p>参考答案: 不行，因为:</p><ol><li>计算机硬件没有原子钟，无法做到精确计时</li><li>操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差</li><li>按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差</li><li>受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差</li></ol><p>单线程是异步产生的原因 事件循环是异步的实现方式</p><h2 id="异步流程的一般步骤" tabindex="-1"><a class="header-anchor" href="#异步流程的一般步骤"><span>异步流程的一般步骤</span></a></h2><ol><li><strong>发起异步操作</strong>：首先，发起一个异步操作，比如<strong>发起一个网络请求</strong>、<strong>读取一个文件</strong>、<strong>等待用户输入</strong>等。这些操作可能需要一段时间来完成。</li><li><strong>注册回调函数</strong>：一旦异步操作被触发，通常会<strong>注册一个回调函数</strong>，这个函数将在操作完成后被调用。回调函数是异步流程中的关键，因为它定义了在异步操作完成时要执行的逻辑。</li><li><strong>继续执行</strong>：在注册回调函数后，程序通常会<strong>继续执行其他任务</strong>，而<strong>不会等待</strong>异步操作完成。这样可以提高程序的响应性，不会让程序在等待I/O操作时被阻塞。</li><li><strong>异步操作完成</strong>：当异步操作完成，注册的回调函数将被调用，执行与异步操作相关的逻辑。</li></ol><h2 id="常见的异步编程模式和技术" tabindex="-1"><a class="header-anchor" href="#常见的异步编程模式和技术"><span>常见的异步编程模式和技术</span></a></h2><ol><li><strong>回调函数</strong>：最基本的异步编程模式是使用回调函数。将一个函数作为参数传递给异步操作，当操作完成时，回调函数将被执行。</li><li><strong>Promise</strong>：Promise是一种更高级的<strong>异步编程模式</strong>，它提供了一种更结构化的方式来处理异步操作。通过Promise，可以更容易地处理异步操作的成功和失败情况。</li><li><strong>async/await</strong>：async/await是JavaScript中的<strong>异步编程语法糖</strong>，它<strong>基于Promise</strong>构建，使异步代码看起来更像同步代码，提高了可读性。</li><li><strong>事件驱动编程</strong>：在事件驱动编程中，将事件处理程序注册到特定事件上，当事件发生时，处理程序将被调用，如 onclick。</li><li><strong>生成器函数</strong>：生成器函数允许在迭代中暂停和恢复执行，这对于处理异步操作的结果很有用。</li></ol><p>异步流程允许程序在执行过程中<strong>非阻塞</strong>地处理多个任务，提高了程序的效率和用户体验。然而，它也需要更复杂的控制流程，因此需要小心<strong>处理回调地狱<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><strong>和</strong>异步错误处理</strong>等问题。</p><hr class="footnotes-sep">',12),m={class:"footnotes"},f={class:"footnotes-list"},u={id:"footnote1",class:"footnote-item"},_=t("a",{href:"#footnote-ref1",class:"footnote-backref"},"↩︎",-1);function x(b,S){const r=e("RouteLink");return i(),a("div",null,[h,g(" more "),d,t("section",m,[t("ol",f,[t("li",u,[t("p",null,[p(r,{to:"/Interview/JavaScript/CallbackHell/"},{default:l(()=>[o("回调地狱")]),_:1}),o(),_])])])])])}const v=s(c,[["render",x],["__file","index.html.vue"]]),w=JSON.parse('{"path":"/Interview/JavaScript/Async/","title":"JS的同步和异步","lang":"zh-CN","frontmatter":{"title":"JS的同步和异步","lang":"zh-CN","date":"2024-03-12T11:45:33.000Z","permalink":"/Interview/JavaScript/Async/","category":["JavaScript"],"tag":["JavaScript"],"description":"简述 浏览器进程模型浏览器进程模型 JS是一门单线程的语言，这是因为它运行在浏览器的 渲染主线程 中，而 渲染主线程 只有一个。 而渲染主线程承担着诸多的工作，渲染页面、执行JS 都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生 阻塞，从而导致消息队列中的很多其他任务无法得到执行。 这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/Interview/JavaScript/Async/"}],["meta",{"property":"og:title","content":"JS的同步和异步"}],["meta",{"property":"og:description","content":"简述 浏览器进程模型浏览器进程模型 JS是一门单线程的语言，这是因为它运行在浏览器的 渲染主线程 中，而 渲染主线程 只有一个。 而渲染主线程承担着诸多的工作，渲染页面、执行JS 都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生 阻塞，从而导致消息队列中的很多其他任务无法得到执行。 这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://shaohui-jin.github.io/picx-images-hosting/blog/浏览器进程模型.6pn9qxux5f.webp \\"浏览器进程模型\\" =800x"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-22T06:41:07.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:tag","content":"JavaScript"}],["meta",{"property":"article:published_time","content":"2024-03-12T11:45:33.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-22T06:41:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS的同步和异步\\",\\"image\\":[\\"https://shaohui-jin.github.io/picx-images-hosting/blog/浏览器进程模型.6pn9qxux5f.webp \\\\\\"浏览器进程模型\\\\\\" =800x\\"],\\"datePublished\\":\\"2024-03-12T11:45:33.000Z\\",\\"dateModified\\":\\"2024-03-22T06:41:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":2,"title":"简述","slug":"简述","link":"#简述","children":[]},{"level":2,"title":"异步流程的一般步骤","slug":"异步流程的一般步骤","link":"#异步流程的一般步骤","children":[]},{"level":2,"title":"常见的异步编程模式和技术","slug":"常见的异步编程模式和技术","link":"#常见的异步编程模式和技术","children":[]}],"git":{"createdTime":1710235448000,"updatedTime":1711089667000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":3}]},"readingTime":{"minutes":5.02,"words":1507},"filePathRelative":"zh/Interview/JavaScript/2-异步/Async.md","localizedDate":"2024年3月12日","excerpt":"<h2>简述</h2>\\n<figure><img src=\\"https://shaohui-jin.github.io/picx-images-hosting/blog/浏览器进程模型.6pn9qxux5f.webp\\" alt=\\"浏览器进程模型\\" width=\\"800\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>浏览器进程模型</figcaption></figure>\\n<p>JS是一门单线程的语言，这是因为它运行在浏览器的 <strong>渲染主线程</strong> 中，而 <strong>渲染主线程</strong> 只有一个。</p>\\n<p>而渲染主线程承担着诸多的工作，<strong>渲染页面</strong>、<strong>执行JS</strong> 都在其中运行。</p>\\n<p>如果使用同步的方式，就极有可能导致主线程产生 <strong>阻塞</strong>，从而导致消息队列中的很多其他任务无法得到执行。</p>\\n<p>这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。</p>\\n<p>具体做法是当某些任务发生时，比如 <strong>计时器</strong>、<strong>网络</strong>、<strong>事件监听</strong>，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。</p>\\n<p>当其他线程完成时，将事先传递的<strong>回调函数包装成任务</strong>，加入到 <strong>消息队列</strong> 的 <strong>末尾排队</strong>，等待主线程调度执行。</p>\\n<p>在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。</p>\\n<p>在目前 chrome 的实现中，至少包含了下面的队列:\\n延时队列:用于存放计时器到达后的回调任务，优先级「中」\\n交互队列:用于存放用户操作后产生的事件处理任务，优先级「高」\\n微队列:用户存放需要最快执行的任务，优先级「最高」</p>\\n","autoDesc":true}');export{v as comp,w as data};
