const e=JSON.parse('{"key":"v-d621118a","path":"/Java/Stream/","title":"Stream","lang":"zh-CN","frontmatter":{"title":"Stream","lang":"zh-CN","date":"2022-05-16T11:26:43.000Z","permalink":"/Java/Stream/","category":["Java"],"tag":["Java"],"description":"Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 特性 不是数据结构：它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 不支持索引访问：但是很容易生成数组或者 List 。 惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。 并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。 注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。","head":[["meta",{"property":"og:url","content":"https://jin-shaohui.gitee.io/Java/Stream/"}],["meta",{"property":"og:site_name","content":"繁华中自律，落魄中自愈"}],["meta",{"property":"og:title","content":"Stream"}],["meta",{"property":"og:description","content":"Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 特性 不是数据结构：它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 不支持索引访问：但是很容易生成数组或者 List 。 惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。 并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。 注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-14T09:02:01.000Z"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:published_time","content":"2022-05-16T11:26:43.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-14T09:02:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Stream\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-16T11:26:43.000Z\\",\\"dateModified\\":\\"2023-08-14T09:02:01.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"特性","slug":"特性","link":"#特性","children":[]},{"level":2,"title":"流操作类型","slug":"流操作类型","link":"#流操作类型","children":[]},{"level":2,"title":"基本使用","slug":"基本使用","link":"#基本使用","children":[]},{"level":2,"title":"构造Stream流的方式","slug":"构造stream流的方式","link":"#构造stream流的方式","children":[]},{"level":2,"title":"Stream流的之间的转换","slug":"stream流的之间的转换","link":"#stream流的之间的转换","children":[]},{"level":2,"title":"Stream流的map使用","slug":"stream流的map使用","link":"#stream流的map使用","children":[]},{"level":2,"title":"Stream流的filter使用","slug":"stream流的filter使用","link":"#stream流的filter使用","children":[]},{"level":2,"title":"Stream流的flatMap使用","slug":"stream流的flatmap使用","link":"#stream流的flatmap使用","children":[]},{"level":2,"title":"Stream流的limit使用","slug":"stream流的limit使用","link":"#stream流的limit使用","children":[]},{"level":2,"title":"Stream流的sort使用","slug":"stream流的sort使用","link":"#stream流的sort使用","children":[]},{"level":2,"title":"Stream流的peek使用","slug":"stream流的peek使用","link":"#stream流的peek使用","children":[]},{"level":2,"title":"Stream流的parallel使用","slug":"stream流的parallel使用","link":"#stream流的parallel使用","children":[]},{"level":2,"title":"Stream流的max/min/distinct使用","slug":"stream流的max-min-distinct使用","link":"#stream流的max-min-distinct使用","children":[]},{"level":2,"title":"Stream流的Match使用","slug":"stream流的match使用","link":"#stream流的match使用","children":[]},{"level":2,"title":"Stream流的reduce使用","slug":"stream流的reduce使用","link":"#stream流的reduce使用","children":[]},{"level":2,"title":"Stream流的iterate使用","slug":"stream流的iterate使用","link":"#stream流的iterate使用","children":[]},{"level":2,"title":"Stream流的Supplier使用","slug":"stream流的supplier使用","link":"#stream流的supplier使用","children":[]},{"level":2,"title":"Stream流的groupingBy/partitioningBy使用","slug":"stream流的groupingby-partitioningby使用","link":"#stream流的groupingby-partitioningby使用","children":[]},{"level":2,"title":"Stream流的summaryStatistics使用","slug":"stream流的summarystatistics使用","link":"#stream流的summarystatistics使用","children":[]}],"git":{"createdTime":1682567520000,"updatedTime":1692003721000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":2}]},"readingTime":{"minutes":10.49,"words":3148},"filePathRelative":"Knowledge/BackEnd/Java-Stream.md","localizedDate":"2022年5月16日","excerpt":"<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\\nStream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\\n这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>\\n<h2> 特性</h2>\\n<ul>\\n<li>不是数据结构：它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>\\n<li>不支持索引访问：但是很容易生成数组或者 List 。</li>\\n<li>惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。</li>\\n<li>并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>\\n<li>可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>\\n<li>注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。</li>\\n</ul>","copyright":{"author":"JSH","license":"MIT"},"autoDesc":true}');export{e as data};
