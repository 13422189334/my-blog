import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,b as l}from"./app-BnVGlo90.js";const o={},i=l('<h3 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h3><p><code>描述</code>： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包</p><p><code>特点</code>： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收</p><p><code>缺点</code>： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露</p><p><code>使用</code>： 防抖，节流，函数嵌套函数避免全局污染</p><blockquote><p><strong>高级描述：</strong></p><ol><li><code>函数</code> + <code>其定义时所处的词法环境</code></li><li><code>函数本身</code> + <code>内部属性[Environment]</code></li></ol><p><strong>内存泄漏条件：</strong></p><ol><li><strong>持有了不再需要的函数引用，会导致函数关联的 <code>词法环境</code> 无法销毁，从而导致内存泄露</strong></li><li><strong>当多个函数 <code>共享词法环境</code> 时，会导致词法环境膨胀，从而导致出现 <code>无法触达</code> 也 <code>无法回收</code> 的内存空间，导致内存泄漏</strong></li></ol></blockquote><h3 id="ajax" tabindex="-1"><a class="header-anchor" href="#ajax"><span>ajax</span></a></h3><ul><li>「<strong>AJAX 全称 Asynchronous Javascript And XML</strong>」：异步JavaScript和xml，是一种技术的统称 <ul><li>「<strong>XHR 全称 XmlHttpRequest</strong>」：HTML源生实现Ajax的一种技术</li><li>「<strong>Fetch</strong>」：基于 Promise 的一种api，在es6时提出，用于代替 XHR 实现 AJAX 的一种技术</li></ul></li><li>「<strong>axios</strong>」 是一种 使用 Promise + xhr 封装的第三方库</li><li>「<strong>umi-request</strong>」： 基于 fetch 封装的第三方库</li></ul><blockquote><p><strong>上传下载进度：</strong></p><ol><li>xhr <code>支持上传、下载进度展示</code></li><li>fetch 不支持上传进度，<code>支持下载进度展示</code></li></ol><p><strong>Abort 取消机制：</strong></p><ol><li>xhr <code>支持终止请求</code></li><li>fetch <code>本身不支持</code>，可使用 <code>信号控制器 AbortController</code> 实现</li></ol><p><strong>Timeout 超时机制:</strong></p><ol><li>xhr <code>支持超时机制</code></li><li>fetch <strong>本身不支持</strong>，可使用 <code>信号控制器 AbortController</code> 以及 <code>Promise</code> 实现</li></ol></blockquote><h2 id="网络" tabindex="-1"><a class="header-anchor" href="#网络"><span>网络</span></a></h2><h3 id="同源与跨域" tabindex="-1"><a class="header-anchor" href="#同源与跨域"><span>同源与跨域</span></a></h3><h4 id="同源策略限制了什么" tabindex="-1"><a class="header-anchor" href="#同源策略限制了什么"><span>同源策略限制了什么</span></a></h4><ol><li>DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作</li><li>数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据</li><li>网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</li></ol><h4 id="跨域三要素" tabindex="-1"><a class="header-anchor" href="#跨域三要素"><span>跨域三要素</span></a></h4><p>浏览器限制：即浏览器对跨域行为进行检测和阻止 触发跨域的三要素之一：协议、域名、端口 发起的是xhr请求：即XMLHttpRequest</p><h4 id="如何解决跨域" tabindex="-1"><a class="header-anchor" href="#如何解决跨域"><span>如何解决跨域</span></a></h4><p>被调用方解决跨域设置 访问控制允许来源 response.addHeader(‘Access-Control-Allow-Origin’,’*’ ) 调用方使用Nginx 代理调用方请求，目的是为了和被调用方的域名端口保持一致 jsonp</p><h4 id="a-com-b-com-跨域发生在一步" tabindex="-1"><a class="header-anchor" href="#a-com-b-com-跨域发生在一步"><span>a.com -&gt; b.com 跨域发生在一步</span></a></h4><h3 id="get请求跨域吗" tabindex="-1"><a class="header-anchor" href="#get请求跨域吗"><span>get请求跨域吗</span></a></h3><h3 id="什么时候会发送预检请求" tabindex="-1"><a class="header-anchor" href="#什么时候会发送预检请求"><span>什么时候会发送预检请求</span></a></h3><h3 id="网络策略" tabindex="-1"><a class="header-anchor" href="#网络策略"><span>网络策略</span></a></h3><h4 id="cors-跨源资源共享" tabindex="-1"><a class="header-anchor" href="#cors-跨源资源共享"><span>CORS 跨源资源共享</span></a></h4><h4 id="csp-内容安全策略" tabindex="-1"><a class="header-anchor" href="#csp-内容安全策略"><span>CSP 内容安全策略</span></a></h4><p>同源策略是期望让我们的页面引用的资源都来自一个源，对于不是同源的文件，我们默认就是不安全的 CSP的核心思想就是让服务器决定浏览器可以加载那些资源，让服务器决定浏览器是否能够执行加载的JS代码。 Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</p><h2 id="vue3" tabindex="-1"><a class="header-anchor" href="#vue3"><span>Vue3</span></a></h2><h3 id="ref-和-reactive的用法" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive的用法"><span>ref 和 reactive的用法</span></a></h3><h3 id="reactive的响应式" tabindex="-1"><a class="header-anchor" href="#reactive的响应式"><span>reactive的响应式</span></a></h3><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h2><h3 id="类组件-和-函数组件-的区别" tabindex="-1"><a class="header-anchor" href="#类组件-和-函数组件-的区别"><span>类组件 和 函数组件 的区别</span></a></h3><h3 id="usestate-和-useref" tabindex="-1"><a class="header-anchor" href="#usestate-和-useref"><span>useState 和 useRef</span></a></h3><h3 id="uselayouteffect" tabindex="-1"><a class="header-anchor" href="#uselayouteffect"><span>useLayoutEffect</span></a></h3><h2 id="代码测试" tabindex="-1"><a class="header-anchor" href="#代码测试"><span>代码测试</span></a></h2><h2 id="灵活" tabindex="-1"><a class="header-anchor" href="#灵活"><span>灵活</span></a></h2><h3 id="长列表问题" tabindex="-1"><a class="header-anchor" href="#长列表问题"><span>长列表问题</span></a></h3><ol><li>帧动画加载</li><li>冻结数组</li><li>触底加载</li><li>文档碎片Fragment</li></ol>',35),n=[i];function c(r,s){return t(),a("div",null,n)}const p=e(o,[["render",c],["__file","index.html.vue"]]),u=JSON.parse('{"path":"/InterviewQuestion/","title":"面试题汇总","lang":"zh-CN","frontmatter":{"title":"面试题汇总","lang":"zh-CN","date":"2024-05-05T16:59:31.000Z","permalink":"/InterviewQuestion/","headerDepth":5,"gitInclude":["../../../src/zh/JavaScript/闭包以及内存泄漏原因.md","../../../src/zh/JavaScript/Ajax.md"],"description":"闭包 描述： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包 特点： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收 缺点： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露 使用： 防抖，节流，函数嵌套函数避免全局污染 高级描述： 函数 + 其定义时所处的词法环境 ...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/InterviewQuestion/"}],["meta",{"property":"og:title","content":"面试题汇总"}],["meta",{"property":"og:description","content":"闭包 描述： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包 特点： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收 缺点： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露 使用： 防抖，节流，函数嵌套函数避免全局污染 高级描述： 函数 + 其定义时所处的词法环境 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-05T11:41:53.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:published_time","content":"2024-05-05T16:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-05T11:41:53.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试题汇总\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-05T16:59:31.000Z\\",\\"dateModified\\":\\"2024-06-05T11:41:53.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":3,"title":"闭包","slug":"闭包","link":"#闭包","children":[]},{"level":3,"title":"ajax","slug":"ajax","link":"#ajax","children":[]},{"level":2,"title":"网络","slug":"网络","link":"#网络","children":[{"level":3,"title":"同源与跨域","slug":"同源与跨域","link":"#同源与跨域","children":[{"level":4,"title":"同源策略限制了什么","slug":"同源策略限制了什么","link":"#同源策略限制了什么","children":[]},{"level":4,"title":"跨域三要素","slug":"跨域三要素","link":"#跨域三要素","children":[]},{"level":4,"title":"如何解决跨域","slug":"如何解决跨域","link":"#如何解决跨域","children":[]},{"level":4,"title":"a.com -> b.com 跨域发生在一步","slug":"a-com-b-com-跨域发生在一步","link":"#a-com-b-com-跨域发生在一步","children":[]}]},{"level":3,"title":"get请求跨域吗","slug":"get请求跨域吗","link":"#get请求跨域吗","children":[]},{"level":3,"title":"什么时候会发送预检请求","slug":"什么时候会发送预检请求","link":"#什么时候会发送预检请求","children":[]},{"level":3,"title":"网络策略","slug":"网络策略","link":"#网络策略","children":[{"level":4,"title":"CORS 跨源资源共享","slug":"cors-跨源资源共享","link":"#cors-跨源资源共享","children":[]},{"level":4,"title":"CSP 内容安全策略","slug":"csp-内容安全策略","link":"#csp-内容安全策略","children":[]}]}]},{"level":2,"title":"Vue3","slug":"vue3","link":"#vue3","children":[{"level":3,"title":"ref 和 reactive的用法","slug":"ref-和-reactive的用法","link":"#ref-和-reactive的用法","children":[]},{"level":3,"title":"reactive的响应式","slug":"reactive的响应式","link":"#reactive的响应式","children":[]}]},{"level":2,"title":"React","slug":"react","link":"#react","children":[{"level":3,"title":"类组件 和 函数组件 的区别","slug":"类组件-和-函数组件-的区别","link":"#类组件-和-函数组件-的区别","children":[]},{"level":3,"title":"useState 和 useRef","slug":"usestate-和-useref","link":"#usestate-和-useref","children":[]},{"level":3,"title":"useLayoutEffect","slug":"uselayouteffect","link":"#uselayouteffect","children":[]}]},{"level":2,"title":"代码测试","slug":"代码测试","link":"#代码测试","children":[]},{"level":2,"title":"灵活","slug":"灵活","link":"#灵活","children":[{"level":3,"title":"长列表问题","slug":"长列表问题","link":"#长列表问题","children":[]}]}],"git":{"createdTime":1712308326000,"updatedTime":1717587713000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":6}]},"readingTime":{"minutes":1.57,"words":472},"filePathRelative":"zh/面试题 - 随时看看/面试题汇总.md","localizedDate":"2024年5月5日","excerpt":"<h3>闭包</h3>\\n<p><code>描述</code>： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包</p>\\n<p><code>特点</code>： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收</p>\\n<p><code>缺点</code>： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露</p>\\n<p><code>使用</code>： 防抖，节流，函数嵌套函数避免全局污染</p>\\n<blockquote>\\n<p><strong>高级描述：</strong></p>\\n<ol>\\n<li><code>函数</code> + <code>其定义时所处的词法环境</code></li>\\n<li><code>函数本身</code> + <code>内部属性[Environment]</code></li>\\n</ol>\\n<p><strong>内存泄漏条件：</strong></p>\\n<ol>\\n<li><strong>持有了不再需要的函数引用，会导致函数关联的 <code>词法环境</code> 无法销毁，从而导致内存泄露</strong></li>\\n<li><strong>当多个函数 <code>共享词法环境</code> 时，会导致词法环境膨胀，从而导致出现 <code>无法触达</code> 也 <code>无法回收</code> 的内存空间，导致内存泄漏</strong></li>\\n</ol>\\n</blockquote>","autoDesc":true}');export{p as comp,u as data};
