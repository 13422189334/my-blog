import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as n,b as a}from"./app-BTQyp2eF.js";const s={},p=a(`<p>原理方面，react diff，fiber，性能优化分别从编译阶段和编译后来讲有哪些措施;</p><h3 id="css" tabindex="-1"><a class="header-anchor" href="#css"><span>Css</span></a></h3><h4 id="隐藏元素" tabindex="-1"><a class="header-anchor" href="#隐藏元素"><span>隐藏元素</span></a></h4><ol><li>display: none; 元素在页面上消失，不占据空间。</li><li>opacity: 0; 元素在页面上消失，占据空间。</li><li>visibility: hidden; 元素在页面上消失，占据空间。</li><li>position: absolute; right: 0; 极限偏移， 元素在页面上消失，不占据空间</li><li>transform: scale(0) 元素在页面上消失，占据空间。</li><li>clip-path: circle(10%);剪裁元素在页面上消失，占据空间。</li></ol><p>元素居中</p><ol><li>position: absolute; margin: auto;</li><li>position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);</li><li>display: flex;align-items: center;justify-content: center;</li><li>display: grid;align-items: center; justify-items: center;</li><li>display: table-cell; text-align: center; vertical-align: middle;</li></ol><p>Transform、 translate、transition Transform变形， rotate旋转、skew扭曲、scale缩放、translate移动、matrix 2D转换方法 Translate平移 Transition过渡， property运动 duration持续时间 timing-function delay延迟</p><p>em和 rem Em是相对于 元素自身 的字体大小的存在，如果元素没有设置字体大小，则相对于父元素的字体大小。 Rem是相对于 根元素（即html元素） 的字体大小的存在，它不受 元素字体大小 和 父元素字体大小 的影响，只受根元素字体大小的影响</p><p>bfc兼容性 BFC的形成条件 浮动元素 float 的值不为 left / right / inherit 中的任何⼀个 溢出元素 overflow 的值为 hidden / scroll / auto / inherit 中的任何⼀个 定位元素 position 的值为 absolute / fixed 中的任何⼀个 显示元素 display 的值为 **inline-block / table-caption / table-cell 中的任何⼀个 BFC的布局规则 1.内部的 box 会在 垂直方向 上，一个接一个的放置 2.box 垂直方向 的距离由 margin 决定，属于 同一个BFC的两个相邻 box 的 margin 会发生重叠 3.BFC 的区域 不会与浮动元素区域重叠 4.BFC 就是页面上一个 独立容器，容器内的子元素不会影响到外面的元素 5.计算 BFC 的高度时，浮动元素也参与计算</p><p>1.Bfc在垂直方向上margin 重叠 2.防止文字环绕 让其中一个元素处于新的BFC区域，这样里面的标签不会影响外面，外面的也不会影响里面 3.自适应两栏或者三栏布局 可以让自适应块处于一个新的BFC区域，这样BFC区域就不会和float区域发生重叠了</p><p>JS 数据类型 基本数据类型： number， boolean， null，undefined，string，symbol， 基本数据类型保存在栈内存中，保存的就是一个具体的值 引用数据类型：date，RegExp，function，array，object 保存在堆内存当中，声明一个引用类型的变量，他保存的就是应用数据类型的地址 假如声明两个引用类型同时指向一个地址的时候，修改其中一个那么另一个也发生改变</p><p>For in 会不会遍历原型，怎么判断是否自身 For in 无论是原型还是自身都遍历出来 hasOwnProperty判断是否自身而不是原型的方法 闭包 1.描述： 函数嵌套函数，内部函数被外部函数返回并保存下来，就会产生闭包 2.特点： 可以重复利用变量，并且这个变量不会污染全局；这个变量一直保存在内存中，不会被垃圾回收机制回收 3.缺点： 闭包较多的时候，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露 4.使用： 防抖，节流，函数嵌套函数避免全局污染</p><p>原型链 1.原型其实是个普通的对象，为构造函数的实例提供属性和方法，所有的实例的原型都是同一个 2.使用prototype可以把方法挂在原型上，内存只保存一份 3.__proto__可以理解为指针，是实例对象中的属性，指向的是构造函数的原型</p><p>作用域 作用域链 作用域 作用域是指在运行时，代码中的某些特定部分中变量、函数和对象的可访问性</p><p>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。 ES6 之前 JavaScript 没有块级作用域，只有全局作用域和函数作用域。 ES6 提出了 块级作用域 所声明的变量在指定块的作用域外无法被访问。 作用域链 当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找。如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p><p>Typeof、intanceof、constructor、Object.prototype.toString.call Typeof typeof xxx 只能检测基本数据类型</p><p>Instanceof [] instanceof Array 只能检测引用数据类型</p><p>Constructor (‘abc’).constructor === String 基本能够检测基本类型和引用类型，但是如果声明构造函数，并把它的原型换指向Array，就不对了</p><p>Object.prototype.toString.call Object.prototype.toString.call(2) 能够完全检测基本类型和引用类型</p><p>事件委托 事件委托又叫事件代理，原理是利用事件冒泡的机制来实现，也就是说把子元素的事件绑定到了父元素的身上，如果子元素阻止了事件冒泡(Event.stopPropagation)，那么委托也就不成立 addEventListener(‘click’, 函数名， true/ false ) True 事件捕获， false 事件冒泡 继承 1.原型链的继承 让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性 优点：写法方便简洁，容易理解 缺点： 对象实例共享所有继承的属性和方法，无法向父类构造函数传值 2.借用构造函数继承 在子类型构造函数的内部调用父类型的构造函数，使用 apply或call将父对象的构造函数绑定在子对象上 优点： 解决了原型链实现继承的不能传参的问题以及父类的原型共享问题 缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法，对子类型而言是不可见的 3.组合继承 使用原型链实现对原型属性和方法的继承 通过借用构造函数进来实现对实例属性的继承 既通过在原型上定义方法，实现了函数复用，又能保证每个实例都有自己的属性</p><p>4.Es6的class Class通过extends关键字来实现继承，其本质是 1.先创造出父类的this对象 2.然后用子类的构造函数修改this 3.子类的构造函数中必须调用super方法，且只有在调用了super之后才能使用this，因为子类的提升对象是继承父类的this对象，然后对其进行加工，而super方法表示的是父类的构造函数，用来新建父类的this对象</p><p>es6新特性 1.块级作用域（let const） 不存在变量提升、存在暂时性死区、块级作用域、不能在同一个作用域重复生命 2.新增语法糖 class 3.基本数据类型 symbol 4.新增解构赋值 5.新增箭头函数 不能作为构造函数使用，不能使用new、箭头函数没有原型、箭头函数没有arguments、箭头函数不能使用call、bind、apply改变this的指向、this指向 外层第一个函数的this 6.新增了函数参数的默认值 7.数组新增了api 8.对象数组新增了拓展运算符 console.log(1, ...[2, 3, 4], 5) 9.Promise 10.模块化 import export 11.新增set(不重复) map(key类型不受限制)数据结构 12.新增generator</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">xxfn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token string">&#39;d end...&#39;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> _xxfn <span class="token operator">=</span> <span class="token function">xxfn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
    <span class="token comment">//第一个yield语句</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>_xxfn<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//{value: &#39;a&#39;, done: false}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>this 的指向 1.全局对象中的this 指向window 2.全局作用域或普通函数的this 指向 window 3.This永远指向最后调用它的那个对象（非箭头函数） 4.New 关键字改变了this指向 5.Apply，call，bind改变this的指向（非箭头函数） 6.箭头函数中的this，它在定义的时候就已经确定好了，如果外层有函数，则是外层函数的this，没有的话就是window 7.匿名函数中的this永远指向window，匿名函数的执行环境具有全局性，因此指向window</p><p>Js设计原理是什么 Js引擎 运行上下文 调用栈 事件循环 回调</p><p>New操作符做了什么</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">newFun</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 1.先创建一个空对象</span>
 <span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token comment">// 2.把空对象和构造函数通过原型链进行链接</span>
 newObj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> fn<span class="token punctuation">.</span>prototype
 <span class="token comment">// 3.把构造函数的this绑定到新的空对象上</span>
 <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>newObj<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
 <span class="token comment">// 4.根据构造函数返回的类型进行判断，如果是引用数据类型，则返回这个引用类型，如果是值类型，则返回对象</span>
 <span class="token keyword">return</span> result <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token operator">?</span> result <span class="token operator">:</span> newObj
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>settimeout最小执行时间 HTML规定最小时间为4ms setInterval最小执行时间 HTML规定最小时间为10ms Script中的async和defer区别 没有标识： 浏览器会理科加载并执行 有async：加载和渲染后面元素的过程将和script的加载和执行并行进行(异步) 有defer：加载和渲染后面元素的过程江河script的加载并行进行，但是他的执行事件是要等所有元素解析完成之后执行</p><p>Promise 1.解决了回调地狱的问题 2.自身有all、reject、resolve、race方法 3.原型上有then、catch方法 4.把异步队列化 5.三种状态：pendding初始状态、rejected操作失败、fulfilled操作成功</p><p>Async 和 await 1.同步带吗做异步操作，必须搭配使用 2.Async表示函数内部有异步操作，调用函数会返回promise 3.Await是组成async的表达式，结果是取决于他等待的内容，如果是promise那就是promise的结果，如果是普通函数就进行链式调用 4.Await后的promise如果是reject状态，那么整个async函数就会中断后面的代码不执行</p><p>Call，apply，bind 都会改变this的指向，call apply功能类似，只是传参方式不同 Call方法是传的一个参数列表 Apply方法传递的是一个数组 Bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数是可以传参的 Call方法性能要比apply好一点，所以用call的会更多一点</p><p>深克隆 1.解构 ｛...xxx｝ 只能实现第一层，当有多层的时候还是浅拷贝 2.JSON.parse(JSON.stringify(xxx)) 该方法不会拷贝内部函数 3.利用递归实现函数 事件循环 什么异步 JS是一门单线程的语言，这是因为它运行在浏览器的 渲染主线程 中，而 渲染主线程 只有一个。 而渲染主线程承担着诸多的工作，渲染页面、执行JS 都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生 阻塞，从而导致消息队列中的很多其他任务无法得到执行。 这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。 具体做法是当某些任务发生时，比如 计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。 当其他线程完成时，将事先传递的回调函数包装成任务，加入到 消息队列 的 末尾排队，等待主线程调度执行。 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。 什么事件循环 1.事件循环又叫做 消息循环，是浏览器 渲染主线程 的工作方式。 2.在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出 第一个任务执行，而其他线程只需要在合适的时候将任务加入到 队列末尾 即可。 3.过去把消息队列简单分为 宏队列 和 微队列，这种说法目前已无法满足复杂的浏览器环境，W3C 不再使用宏队列的说法，取而代之的是一种更加灵活多变的处理方式。 4.. 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。任务没有优先级，在消息队列中 先进先出，但消息队列是有优先级的。 5. 不同任务队列有 不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。 但浏览器 必须 有一个微队列，微队列的任务一定具有 最高的优先级，必须优先调度执行</p><p>在目前 chrome 的实现中，至少包含了下面的队列: 延时队列：用于存放计时器到达后的回调任务，优先级「中」 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」 微队列：用户存放需要最快执行的任务，优先级「最高」</p><p>http 状态码</p><ul><li>GET: 200 OK</li><li>POST: 201 Created</li><li>PUT: 200 OK</li><li>PATCH: 200 OK</li><li>DELETE: 204 No Content</li></ul><p>301状态码（永久重定向） 302状态码（暂时重定向，307也是这个含义） 303用于POST、PUT和DELETE请求。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办 304 协商缓存</p><p>400 Bad Request：服务器不理解客户端的请求，未做任何处理。 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。 404 Not Found：所请求的资源不存在，或不可用。 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。 410 Gone：所请求的资源已从这个地址转移，不再可用。 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。 429 Too Many Requests：客户端的请求次数超过限额。</p><p>500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</p><p>跨域</p><p>1.跨域三要素 浏览器限制：即浏览器对跨域行为进行检测和阻止 触发跨域的三要素之一：协议、域名、端口 发起的是xhr请求：即XMLHttpRequest 2.如何解决跨域 被调用方解决跨域设置 访问控制允许来源 response.addHeader(‘Access-Control-Allow-Origin’,’*’ ) 调用方使用Nginx 代理调用方请求，目的是为了和被调用方的域名端口保持一致 3.Jsonp web页面上调用 js 是不受跨域的影响，同时拥有 src属性 的标签也具有相同的能力，比如 <code>&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;</code> web客户端通过与调用脚本一样的方式，来调用跨域服务器上动态生成的js格式文件</p><p>同源策略限制内容有哪些 1.DOM层面：同源策略限制了不同源的js对当前DOM对象的读写操作 2.数据层面：同源策略限制了不同源站点读取当前站点的Cookies、IndexDB、LocalStorage等数据 3.网络层面：同源策略限制了数据发送给非同源站点（比如XML HttpRequest、Fetch等无法请求不同源站点</p><p>XSS跨站脚本攻击 当浏览器收到html文件时，是无法区分被插入的文件是恶意的还是正常的。那这个恶意的脚本就会寄生在页面中，当用户打开页面操作时，就可以做一些坏事情。比如改变用户的搜索结果，改变链接的指向，将页面的一些敏感数据比如Cookie，IndexDB，LocalStorage等数据通过插入的jiechi.js脚本发送给服务器。比如在jiechi.js中的逻辑会弹出一个会话框，当你点击这个会话框时，就会触发jiechi.js中的点击回调，而这个回调可能干的是这个逻辑，会读取Cookie作为页面参数，来诱导你打开一个新的页面，这样这个你的cookie就会被发送到一个恶意的服务器中，这就是一个典型的XSS攻击。 CSP 内容安全策略 同源策略是期望让我们的页面引用的资源都来自一个源，对于不是同源的文件，我们默认就是不安全的 CSP的核心思想就是让服务器决定浏览器可以加载那些资源，让服务器决定浏览器是否能够执行加载的JS代码。 Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</p><p>CSRF CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！</p><p>1.攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 2.攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据 3.整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 4.跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</p><p>CORS 跨源资源共享 浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨源请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证 COOKIE</p><p>http1.0 2.0区别 1、连接方式： http 1.0 是无状态的，每次请求都需要建立新的连接，这意味着每次请求都需要进行TCP握手，这会导致大量延迟。 http 2.0 支持多路复用，可以在一个tcp连接上并发多个请求或响应。 2、数据格式： http 1.0 的数据是文本格式，方便阅读但不利于传输和解析。 http 2.0 的数据是二进制格式，更利于传输和解析。 3、头部压缩： http 1.0 的请求头部信息是明文，会导致大量的冗余数据。 http 2.0 的请求头部是经过了压缩的，减少了数据传输量，并且使用了HPACK去除了冗余的头部字段。 4、服务器推送： http 1.0 中，客户端需要明确请求服务器才能获取资源。 http 2.0 中，服务器可以主动向客户端推送资源。服务端预测到客户端需要的资源后，在客户端请求之前就将这些资源发送到客户端存储到缓存中， 等到客户端真正需要的时候，直接从缓存中获取，提高了性能。</p><p>缓存 缓存可以解决什么问题？ 减少不必要的网络传输，节约宽带（就是省钱） 更快的加载页面（就是加速） 减少服务器负载，避免服务器过载的情况出现。（就是减载） 缺点是什么？ 占内存（有些缓存会被存到内存中 浏览器缓存 localStorage(5M)、sessionStorage(5M)、cookie(4k) HTTP缓存 服务器需要处理http的请求，而缓存，就是为了让服务器不去处理这个请求，客户端也可以拿到数据。 注意，缓存主要是针对html、css、img等静态资源，常规情况下，不会去缓存一些动态资源。 缓存的类型 首先从缓存的类型上来说，可以分为两种: 强缓存 与 协商缓存</p><p>强缓存是不需要发送HTTP请求的，而协商缓存需要</p><p>也就是在发送HTTP请求之前，浏览器会先检查一下强缓存，如果命中直接使用，否则就进入下一步。</p><p>强缓存 浏览器检查强缓存的方式主要是判断这两个字段: HTTP/1.0使用的是Expires;<br> Expires字面意思是有效期，它表示的就是一个具体的时间 如果手动修改本地时间，可能造成缓存失效，所以在1.1时被摒弃</p><p>HTTP/1.1使用的是Cache-Control<br> 1.public: 客户端和代理服务器都可以缓存。 2.private: 这个是Cache-Control默认的取值，只有客户端可以缓存，中间节点不允许缓存。 3.no-cache: 表示不进行强缓存验证，而是用协商缓存来验证。 4.no-store: 所有内容都不会被缓存，不进行强缓存，也不进行协商缓存（都不要）。 5.max-age: 表示在多久之后过期，比如max-age=300表示在300s后缓存内容失效。 6.s-max-age: 它的作用和max-age很像， 不过max-age 用于普通缓存，而s-max-age用于代理缓存，且s-max-age的优先级更高。 7.max-stale: 能容忍的最大过期时间。 8.min-fresh：能够容忍的最小新鲜度。</p><p>Expires和Cache-control的对比 1.Expires产于HTTP/1.0，Cache-control产于HTTP/1.1; 2.Expires设置的是一个具体的时间，Cache-control 可以设置具体时常还有其它的属性; 3.两者同时存在，Cache-control的优先级更高; 4.在不支持HTTP/1.1的环境下，Expires就会发挥作用，所以先阶段的存在是为了做一些兼容的处理。</p><p>协商缓存 Last-Modified（最后修改时间） 和 If-Modified-Since（自此是否修改） 1.浏览器第一次向服务器请求这个资源 2.服务器在返回这个资源的时候，在response header中添加Last-Modified的header，值为该资源在服务器上最后的修改时间 3.浏览器接收到后缓存文件和这个header 4.当下次浏览器再次请求这个资源的时候， 检测到有Last-Modified这个header，就会在请求头中添加If-Modified-Since这个header，该值就是Last-Modified 5.服务器再次接收到该资源的请求，则根据If-Modified-Since与服务器中的这个资源的最后修改时间做对比 6.对比结果相同则返回304和一个空的响应体，告诉浏览器从自己(浏览器)的缓存中拿 7.对比结果不同(If-Modified-Since &lt; 服务器资源最后修改时间)，则表示资源被修改了，则返回200和最新的资源文件(当然还包括最新的Last-Modefied)</p><p>ETag（标识）与 If-None-Match（是否没有一个相同）</p><ol><li>ETag其实与Last-Modefied的原理差不多，不过它不是根据资源的最后修改时间来判断的，而是通过一个唯一的标识。</li><li>在浏览器请求服务器资源的时候，服务器会根据当前文件的内容，给文件生成一个唯一的标识，若是文件发生了改变，则这个标识就会改变。</li><li>服务器会将这个标识ETag放到响应体的header中与请求的资源一起返回给浏览器，而浏览器同样也会缓存文件与这个header。</li><li>在下一次再次加载该资源时，浏览器会将刚刚缓存的ETag放到请求体头部(request header)的If-None-Match里发送给服务器。</li><li>同样的服务器接收到了之后与该资源自身的ETag做对比，如果一致，则表示该资源未发生改变，则直接返回304知会客户端直接使用本地缓存即可。</li><li>若是不一致，则返回200和最新的资源文件(当然还包括最新的ETag)</li></ol><p>对比 首先对于Last-Modified: 1.若是本地打开了缓存文件，并没有进行修改，也还是会改变最后修改时间，导致缓存失败; 2.由于Last-Modified是以秒来计时的，若是某个文件在一秒内被修改了很多次，那么这时候的 Last-Modified 并没有体现出修改了。</p><p>然后对于ETag: 性能上的不足，只要文件发生改变，ETag就会发生改变。 ETag需要服务器通过算法来计算出一个hash值。</p><p>总结，所以对于两种协商缓存:</p><p>准确度上ETag更强; 性能上Last-Modified更好; 两者都支持的话，ETag优先级更高</p><p>VUE 生命周期</p><p>New Vue -&gt; 初始化事件、生命周期 -&gt; beforeCreate -&gt; 初始化响应式数据、注入方法 -&gt; created -&gt; 判断是否有el(挂载节点) -&gt; 判断是否有template模版 -&gt; 模版编译(template、outerHTML) -&gt; beforeMount -&gt; 虚拟dom 替换真实节点 -&gt; mounted -&gt; beforeUpdate -&gt; 虚拟dom根据最新数据触发re-render 重新渲染，以及patch更新组件dom结构 -&gt; beforeDestory -&gt; 卸载子组件、数据监听器、事件监听器 -&gt; destoryed</p><p>通讯方式</p><p>1.父子组件通信: props/$emit $parent/$children provide/inject ref $attrs/$listeners 2. 兄弟组件通信: eventBus Vuex 3. 跨级通信: eventBus Vuex provide/inject $attrs/$listeners</p><p>计算属性和监听属性的区别 监听属性: 监测数据的变化并触发相应的回调函数 计算属性: 对已有的数据进行计算和衍生，生成新的数据</p><p>数据双向绑定原理 1.需要Observer(数据劫持)对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 2. Compiler(订阅者)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 3. Watcher(观察者)是Observer和Compiler之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 4. MVVM作为数据绑定的入口，整合Observer、Compiler和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p><p>灵活 输入网址发生了什么 1.域名解析； 2.发起TCP的3次握手； 3.建立TCP连接后发起http请求； 4.服务器响应http请求，浏览器得到html代码； 5.浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）； 6.浏览器对页面进行渲染呈现给用户。</p><p>当浏览器的 「网络线程」 收到 「HTML 文档」后，会产生一个 渲染任务，并将其传递 「渲染主线程」 的消息队列。</p><p>解析 HTML 浏览器在开始解析前，会启动一个 预解析 的线程，率先下载 HTML 中的 外部CSS 文件和 外部的 JS 文件</p><p>如果主线程解析到 link 位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的HTML。这是因为 下载 和 解析 CSS 的工作是在 预解析线程 中进行的。这就是CSS不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因</p><p>样式计算</p><p>主线程会遍历得到的 DOM 树， 依次为树中的每个节点计算出它最终的样式</p><p>在这一过程中，很多 预设值会变成 绝对值，比如 red 会变成 rgb(255,0,0)；相对单位 会变成 绝对单位，比如 em 会变成 px</p><p>布局 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的「几何信息」。 例如节点的 宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树 「并非一一对应」。</p><p>比如 display:none 的节点 没有几何信息，因此不会生成到布局树；又比如使用了 伪元素选择器，虽然 DOM树 中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。 还有 匿名行盒、匿名块盒 等等都会导致 DOM 树和布局树无法一一对应。</p><p>分层</p><p>主线程会使用一套复杂的策略对整个 布局树 中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change 属性更大程度的影响分层结果。</p><p>观察方式： 谷歌浏览器 F12 打开控制台，右上角的 三个点 中的更多工具中有 Layers</p><p>绘制 主线程 会为 每个层 单独产生 「绘制指令集」，用于描述这一层的内容该如何画出来。 渲染主线程的工作到此为止，剩余步骤交给其他线程完成。</p><p>分块 主线程将 每个图层的绘制信息 提交给 合成线程，剩余工作将由合成线程完成。 合成线程 首先对 每个图层 进行 分块，将其划分为更多的小区域。 它会从线程池中拿取多个线程来完成分块工作。</p><p>光栅化 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程 会开启 多个线程 来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图。</p><p>画 合成线程 拿到 每个层、每个块的位图 后，生成一个个 指引(quad) 信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到 旋转、缩放 等变形。</p><p>变形发生 在 合成线程，与 渲染主线程 无关，这就是 transform 效率高的本质原因。</p><p>合成线程会把 「quad」 提交给 「GPU 进程」，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。</p><p>什么是 reflow(重排) reflow 的本质就是 重新计算 layout 树。</p><p>当进行了会影响 布局树 的操作后，需要重新计算布局树，会引发 layout。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码 全部完成后 再进行统一计算。 所以，改动属性造成的 reflow 是 异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。</p><p>浏览器在反复权衡下，最终决定 获取属性立即 reflow</p><p>什么是 repaint(重绘) repaint 的本质就是重新根据 分层信息 计算了 绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发repaint。</p><p>由于元素的 布局信息 也属于可见样式，所以 reflow 一定会引起 repaint</p><p>为什么 transform 的效率高 因为 transform 既不会影响 布局 也不会影响 绘制指令，</p><p>它影响的只是 渲染流程 的 最后一个「draw」阶段由于 draw 阶段在 合成线程 中，所以 transform 的变化几乎不会影响 渲染主线程。</p><p>反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p><p>算法 冒泡排序 1.比较相邻的元素。如果第一个比第二个大，就交换它们两个； 2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数； 3.针对所有的元素重复以上的步骤，除了最后一个； 4.重复步骤1~3，直到排序完成。</p><p>let arr = [4,23,100,9,7,49,36,57]; console.log(&quot;原始数据：&quot; + arr); for (let i= 0; i &lt; arr.length - 1; i++) { for (let j = 0; j &lt; arr.length - i - 1; j++) { if (arr[j] &gt; arr[j+ 1]) { let temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp } } } console.log(&quot;输出数据：&quot; + arr);</p><p>广度优先遍历（BFS） 广度优先遍历（Breath First Search，简称 BFS）一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。 实际就是 队列 + 前序遍历 深度优先遍历（DFS） 深度优先遍历（Depth First Search，简称 DFS）就是找准一条路不停深入的搜索方法， 当发现这条路走不通的时候就会回退到上一个探索的节点，如果上一个节点存在没有探索的分支，便继续探索若没有则继续回退。 深度优先遍历就有点像二叉树中的后序遍历。 实际就是 栈 + 二叉树的 后序遍历</p><p>性能优化 Vue</p><p>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher v-if 和v-for区分使用场景，v-if和v-for不要连用； v-for遍历必须为item添加key，key保证唯一性，且避免同时使用vif computed和method区分使用场景 路由懒加载、图片懒加载、长列表动态加载 第三方模块按需导入 对于短时间的大量操作（缩放、滚动）使用防抖、节流函数 事件的销毁 SPA 页面采用keep-alive缓存组件 组件的延迟加载，可以把页面资源划分为多份，用到的时候才会按需加载，这样减少第一次加载的消耗。</p><p>代码精简，去除 console ，可复用的方法、组件提取出来 不要写行内样式，避免dom重绘</p><p>Webpack： 1.压缩文件，开启GZIP。 2.文件压缩，文件的大小会直接影响浏览器的加载速度，可使用构建工具 ；webpack, gulp / grunt, rollup等构建工具 3.删除代码中无用的css，可以借助Uncss工具移除样式表中无用的css 4.压缩源码和图片（ JavaScript采用混淆压缩，CSS进行普通压缩，JPG图片根据具体质量压缩为50%~70%，把PNG图片从24色压缩成8色以去掉一些PNG格式信息等）。</p><p>HTTP 1.网址后面加斜杠(&quot; / &quot;)，服务器会直接找到 要处理的目录，如果后面不加斜杠，服务器会从文件开始找起，使加载时间延长。 2.使用 CDN、外部的JavaScript和CSS文件缓存，添加 Expires 头，在服务器端配置 Etag，减少DNS查找。 3.减少 cookie头信息的大小，头信息越大，资源传输速度越慢。 4.初始首屏之外的图片资源按需加载，静态资源延迟加载。 5.合并静态资源（减少HTTP请求） 6.减少页面中的元素，网页中的图片,form,flash等元素都会发出http请求，尽量减少页面中非必要元素，可以减少http请求次数。 7.可以把一些图标制作成精灵图样式，使用background-image,background-position属性显示其中一小部分。 8.JS文件和CSS文件只有一个，合并脚本和css文件，减少http请求 9.使用 localstorage缓存和 mainfest 应用缓存</p><p>移动端 1.可以使用 touch事件 代替 click事件。 2.合理使用 requestAnimation Frame动画代替 setTimeout。 3.避免使用CSS3 渐变阴影 效果。</p><p>JavaScript代码 1.作用域 避免全局查找(少用全局变量)：将在一个函数中会多次用到的全局对象存储为局部变量总是没错的。 避免 with 语句：with会创建自己的作用域，因此会增加其中执行代码的 作用域链的长度。 2.DOM 用 innerHTML 代替DOM操作，减少DOM操作次数。 用 setTimeout 避免页面失去响应。 3.用变量保存 Ajax请求 结果，操作本地变量时不用请求，减少请求次数。 4.尽量使用 事件委托模式，避免批量绑定事件。</p>`,110),i=[p];function o(r,l){return t(),n("div",null,i)}const u=e(s,[["render",o],["__file","index.html.vue"]]),m=JSON.parse('{"path":"/InterviewQuestion/","title":"面试题汇总","lang":"zh-CN","frontmatter":{"title":"面试题汇总","lang":"zh-CN","date":"2024-05-05T16:59:31.000Z","permalink":"/InterviewQuestion/","description":"原理方面，react diff，fiber，性能优化分别从编译阶段和编译后来讲有哪些措施; Css 隐藏元素 display: none; 元素在页面上消失，不占据空间。 opacity: 0; 元素在页面上消失，占据空间。 visibility: hidden; 元素在页面上消失，占据空间。 position: absolute; right: 0;...","head":[["meta",{"property":"og:url","content":"https://shaohui-jin.github.io/InterviewQuestion/"}],["meta",{"property":"og:title","content":"面试题汇总"}],["meta",{"property":"og:description","content":"原理方面，react diff，fiber，性能优化分别从编译阶段和编译后来讲有哪些措施; Css 隐藏元素 display: none; 元素在页面上消失，不占据空间。 opacity: 0; 元素在页面上消失，占据空间。 visibility: hidden; 元素在页面上消失，占据空间。 position: absolute; right: 0;..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-05T09:11:19.000Z"}],["meta",{"property":"article:author","content":"石怜安"}],["meta",{"property":"article:published_time","content":"2024-05-05T16:59:31.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-05T09:11:19.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试题汇总\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-05-05T16:59:31.000Z\\",\\"dateModified\\":\\"2024-05-05T09:11:19.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"石怜安\\",\\"url\\":\\"https://shaohui-jin.github.io\\"}]}"]]},"headers":[{"level":3,"title":"Css","slug":"css","link":"#css","children":[{"level":4,"title":"隐藏元素","slug":"隐藏元素","link":"#隐藏元素","children":[]}]}],"git":{"createdTime":1714900279000,"updatedTime":1714900279000,"contributors":[{"name":"shaohui_jin","email":"1051131737@qq.com","commits":1}]},"readingTime":{"minutes":32.08,"words":9623},"filePathRelative":"zh/面试题 - 随时看看/面试题汇总.md","localizedDate":"2024年5月5日","excerpt":"<p>原理方面，react diff，fiber，性能优化分别从编译阶段和编译后来讲有哪些措施;</p>\\n<h3>Css</h3>\\n<h4>隐藏元素</h4>\\n<ol>\\n<li>display: none;  元素在页面上消失，不占据空间。</li>\\n<li>opacity: 0;  元素在页面上消失，占据空间。</li>\\n<li>visibility: hidden; 元素在页面上消失，占据空间。</li>\\n<li>position: absolute;  right: 0; 极限偏移， 元素在页面上消失，不占据空间</li>\\n<li>transform: scale(0) 元素在页面上消失，占据空间。</li>\\n<li>clip-path: circle(10%);剪裁元素在页面上消失，占据空间。</li>\\n</ol>","autoDesc":true}');export{u as comp,m as data};
