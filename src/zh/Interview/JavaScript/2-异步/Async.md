---
title: JS的同步和异步
lang: zh-CN
date: 2024-03-12 11:45:33
permalink: /Interview/JavaScript/Async/
category: 
  - JavaScript
tag: 
  - JavaScript
---

## 简述

![](https://shaohui-jin.github.io/picx-images-hosting/blog/浏览器进程模型.6pn9qxux5f.webp "浏览器进程模型" =800x)

JS是一门单线程的语言，这是因为它运行在浏览器的 **渲染主线程** 中，而 **渲染主线程** 只有一个。

而渲染主线程承担着诸多的工作，**渲染页面**、**执行JS** 都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生 **阻塞**，从而导致消息队列中的很多其他任务无法得到执行。

这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。

具体做法是当某些任务发生时，比如 **计时器**、**网络**、**事件监听**，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。

当其他线程完成时，将事先传递的**回调函数包装成任务**，加入到 **消息队列** 的 **末尾排队**，等待主线程调度执行。

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

在目前 chrome 的实现中，至少包含了下面的队列:
延时队列:用于存放计时器到达后的回调任务，优先级「中」
交互队列:用于存放用户操作后产生的事件处理任务，优先级「高」
微队列:用户存放需要最快执行的任务，优先级「最高」

<!-- more -->

[//]: # (![img.png]&#40;img.png&#41;)

事件循环又叫做消息循环，是浏览器 **渲染主线程** 的工作方式。
在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出 **第一个任务**执行，而其他线程只需要在合适的时候将任务加入到 **队列末尾** 即可。
过去把消息队列简单分为 **宏队列** 和 **微队列**，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。
根据 W3C 官方的解释，每个任务有不同的类型，**同类型的任务必须在同一个队列**，**不同的任务可以属于不同的队列**。
不同任务队列有 **不同的优先级**，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。

但浏览器 **必须** 有一个**微队列**，微队列的任务一定具有 **最高的优先级**，必须优先调度执行。


面试题:JS 中的计时器能做到精确计时吗?为什么?

参考答案:
不行，因为:
1. 计算机硬件没有原子钟，无法做到精确计时
2. 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差
3. 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差
4. 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差

[//]: # (![img_1.png]&#40;img_1.png&#41;)

单线程是异步产生的原因
事件循环是异步的实现方式


## 异步流程的一般步骤

1. **发起异步操作**：首先，发起一个异步操作，比如**发起一个网络请求**、**读取一个文件**、**等待用户输入**等。这些操作可能需要一段时间来完成。
2. **注册回调函数**：一旦异步操作被触发，通常会**注册一个回调函数**，这个函数将在操作完成后被调用。回调函数是异步流程中的关键，因为它定义了在异步操作完成时要执行的逻辑。
3. **继续执行**：在注册回调函数后，程序通常会**继续执行其他任务**，而**不会等待**异步操作完成。这样可以提高程序的响应性，不会让程序在等待I/O操作时被阻塞。
4. **异步操作完成**：当异步操作完成，注册的回调函数将被调用，执行与异步操作相关的逻辑。

## 常见的异步编程模式和技术

1. **回调函数**：最基本的异步编程模式是使用回调函数。将一个函数作为参数传递给异步操作，当操作完成时，回调函数将被执行。
2. **Promise**：Promise是一种更高级的**异步编程模式**，它提供了一种更结构化的方式来处理异步操作。通过Promise，可以更容易地处理异步操作的成功和失败情况。
3. **async/await**：async/await是JavaScript中的**异步编程语法糖**，它**基于Promise**构建，使异步代码看起来更像同步代码，提高了可读性。
4. **事件驱动编程**：在事件驱动编程中，将事件处理程序注册到特定事件上，当事件发生时，处理程序将被调用，如 onclick。
5. **生成器函数**：生成器函数允许在迭代中暂停和恢复执行，这对于处理异步操作的结果很有用。

异步流程允许程序在执行过程中**非阻塞**地处理多个任务，提高了程序的效率和用户体验。然而，它也需要更复杂的控制流程，因此需要小心**处理回调地狱[^回调地狱]**和**异步错误处理**等问题。


[^回调地狱]: [回调地狱](/Interview/JavaScript/CallbackHell/)
