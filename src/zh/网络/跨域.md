---
title: 跨域
lang: zh-CN
date: 2024-05-14 16:24:16
permalink: /Network/CrossDomain/
category: 
  - Network
tag: 
  - Network
---

## 同源策略的概念和具体限制

同源策略：限制 **从一个源加载的文档或脚本** 如何与 **来自另一个源的资源** 进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）

具体解释：

- `源`包括三个部分：协议、域名、端口。如果有任何一个部分不同，则`源`不同，那就是跨域了。
- `限制`：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：
  - `Cookie`、`LocalStorage`和`IndexDB`无法获取。
  - 无法获取和操作`DOM`。
  - 不能发送`Ajax`请求。我们要注意，`Ajax`只适合`同源`的通信。

<!-- more -->

## 前后端如何通信

主要有以下几种方式：

- `Ajax`：不支持跨域。
- `WebSocket`：不受同源策略的限制，支持跨域
- `CORS`：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：`同时支持同源和跨域的Ajax`。

###  如何创建Ajax

1. 创建 `XMLHttpRequest` 对象。
2. 使用`open`方法设置请求的参数。`open(method, url, 是否异步)`
3. 发送请求。 
4. 注册事件。 注册 `onreadystatechange` 事件，状态改变时就会调用。 
5. 获取返回的数据，更新UI。

### 发送 get 请求

```javascript
// 1. 创建异步对象
let ajaxObj = new XMLHttpRequest();
// 2. 设置请求的参数。包括：请求的方法、请求的url。
ajaxObj.open('get', 'xxx');
// 3. 发送请求
ajaxObj.send();
// 4. 注册事件。 onreadystatechange事件，状态改变时就会调用。
// 如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。
ajaxObj.onreadystatechange = function () {
  // 为了保证 数据 完整返回，我们一般会判断 两个值
  if (ajaxObj.readyState == 4 && ajaxObj.status == 200) {
    // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
    // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示
    console.log('数据返回成功');
    // 数据是保存在 异步对象的 属性中
    console.log(ajaxObj.responseText);
    // 修改页面的显示
    document.querySelector('h1').innerHTML = ajaxObj.responseText;
  }
}
```

### 发送 post 请求

```javascript
// 异步对象
let xhr = new XMLHttpRequest();
// 设置属性
xhr.open('post', 'xxx');
// 如果想要使用post提交数据,必须添加此行
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
// 将数据通过send方法传递
xhr.send('name=fox&age=18');
// 发送并接受返回值
xhr.onreadystatechange = function () {
  // 这步为判断服务器是否正确响应
  if (xhr.readyState == 4 && xhr.status == 200) {
    alert(xhr.responseText);
  }
};
```

### onreadystatechange

注册 `onreadystatechange` 事件后，每当 `readyState` 属性改变时，就会调用 `onreadystatechange` 函数。

`readyState`：（存有 `XMLHttpRequest` 的状态。从 0 到 4 发生变化）

- `0`: 请求未初始化
- `1`: 服务器连接已建立
- `2`: 请求已接收
- `3`: 请求处理中
- `4`: 请求已完成，且响应已就绪

### 事件的触发条件及顺序

| 顺序 | 事件                     | 触发条件                                                                                                                                                                                                                                                                                                 |
|----|------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | xhr.onreadystatechange | 每当`xhr.readystate`改变时触发；但`xhr.readystate`由非`θ`值变为`0`时不触发(如`xhr.abort()`取消接口的时候)                                                                                                                                                                                                                      |
| 2  | xhr.onloadstart        | 调用`xhr.send()`方法后立即触发，若`xhr.send()`未被调用则不会触发此事件。                                                                                                                                                                                                                                                     |
| 3  | xhr.upload.onloadstart | 上传阶段开始                                                                                                                                                                                                                                                                                               |
| 4  | xhr.upload.onprogress  | `xhr.upload.onprogress`在上传阶段(即`xhr.send()`之后，`xhr.readystate=2`之前)触发，每50ms触发一次                                                                                                                                                                                                                                                                                        |
| 5  | xhr.upload.onload      |                                                                                                                                                                                                                                                                                                      |
| 6  | xhr.upload.onloadend   | 上传阶段结束，下载阶段开始                                                                                                                                                                                                                                                                                        |
| 7  | xhr.onprogress         | `xhr.onprogress`在下载阶段(即`xhr.readystate=3`时)触发，每50ms触发一次                                                                                                                                                         |
| 8  | xhr.onload             | 当请求成功完成时触发，此时 `xhr.readystate=4`                                                                                                                                                                                                                                                                     |
| 9  | xhr.onloadend          | 当请求结束(包括请求成功和请求失败)时触发                                                                                                                                                                                                                                                                                |
|    | xhr.onabort            | 当调用 `xhr.abort()` 后触发                                                                                                                                                                                                                                                                                |
|    | xhr.ontimeout          | `xhr.timeout` 不等于0，由请求开始即 `onloadstart` 开始算起，当到达 `xhr.timeout` 所设置时间请求还未结束即 `onloadend`，则触发此事件。                                                                                                                                                                                                      |
|    | xhr.onerror            | 在请求过程中，若发生 `Network error` 则会触发此事件(若发生 `Network error` 时，上传还没有结束，则会先触发 `xhr.upload.onerror`，再触发 `xhr.onerror`；若发生 Network error 时，上传已经结束，则只会触发 `xhr.onerror` )。注意，只有发生了 **网络层级别** 的异常才会触发此事件，对于应用层级别的异常，如响应返回的 `xhr.statuscode` 是 `4xx` 时，并不属于 `Network error`，所以不会触发 `onerror` 事件，而是会触发 `onload` 事件。 |

### 实际开发中用的 原生Ajax请求

```javascript
//获取 ajax 请求之后的json
function ajaxRequest(options) {
  let opt = {
    url: '',
    type: 'get',
    data: {},
    success: function () {},
    error: function () {},
  };
  //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在 XMLHttpRequest 这个 api，没有的话，就用IE的api
  let xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject('Microsoft.XMLHTTP');
  let data = opt.data,
    url = opt.url,
    type = opt.type.toUpperCase(),
    dataArr = [];

  for (let key in data) {
    dataArr.push(key + '=' + data[key]);
  }

  if (type === 'GET') {
    url = url + '?' + dataArr.join('&');
    xhr.open(type, url.replace(/\?$/g, ''), true);
    xhr.send();
  }

  if (type === 'POST') {
    xhr.open(type, url, true);
    // 如果想要使用post提交数据,必须添加此行
    xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
    xhr.send(dataArr.join('&'));
  }

  xhr.onload = function () {
    if (xhr.status === 200 || xhr.status === 304) { //304表示：用缓存即可。206表示获取媒体资源的前面一部分
      let res;
      if (opt.success && opt.success instanceof Function) {
        res = xhr.responseText;
        if (typeof res === 'string') {
          res = JSON.parse(res);  //将字符串转成json
          opt.success.call(xhr, res);
        }
      }
    } else {
      if (opt.error && opt.error instanceof Function) {
        opt.error.call(xhr, null);
      }
    }
  };
}
```

## 跨域的解决方式

1. CORS
2. nginx

### CORS 跨源资源共享

浏览器必须首先使用 OPTIONS 方法发起一个预检请求，从而获知服务端是否允许该跨源请求。

服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证 COOKIE

1. 当浏览器发出跨域请求时，浏览器会添加一个带有当前 **源(方案、主机和端口)** 的 **Origin** 标头。
2. 在服务器端，当服务器看到此标头并希望允许访问时，它需要在响应中添加一个 **Access-Control-Allow-Origin** 标头，指定请求来源(或 * 以允许任何来源)
3. 当浏览器看到带有适当 **Access-Control-Allow-Origin** 标头的响应时，浏览器允许与客户端站点共享响应数据。

``` java {7-17}
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
  throws IOException, ServletException {
  
  HttpServletResponse res = (HttpServletResponse) response;

  // 允许跨域的域名，设置 * 表示允许除带 Cookies 信息的所有域名
  res.addHeader("Access-Control-Allow-Origin", "http://localhost:9527"); 
  // 携带Cookie的请求需开启配置，同时 Access-Control-Allow-Origin 一定为精准匹配
  res.addHeader("Access-Control-Allow-Credentials", true); 
  // 允许跨域的方法，可设置*表示所有。GET/POST/OPTIONS等
  res.addHeader("Access-Control-Allow-Methods", "GET"); 
  // 假如给post请求头设置了contentType字段，则需要添加以下信息
  res.addHeader("Access-Control-Allow-Headers", "Content-Type");
  // 设置预检命令的缓存时效。单位是"秒"
  // 如果没有失效，则不会再次发起OPTION预检请求
  res.addHeader("Access-Control-Max-Age", "3600");
  // 还可以有其他配置...
  chain.doFilter(request, response); //让过滤器放行该请求
}
```

### nginx

> **正向代理：** 利用代理客户端去请求服务器，从而隐藏了真实的客户端，服务器并不知道客户端是谁。如：vpn、devServerProxy
>
> **反向代理:** 反向代理隐藏了真正的服务端。软件层面上常用 Ngnix 来做反向代理服务器，性能很好，用来做负载均衡

为了实现反向代理，需要在 Ngnix 中配置一个代理域名，或者称为一个网址 demo.com，就像百度成千上万的服务器使用用一个代理网址 www.baidu.com 一样

```nginx
server {
  listen 80;
  server_name: demo.com; # 请求域名是demo.com，端口是80的，都会被nginx做代理
  # http://demo.com/api/test 就会跳转到http://localhost:8080/test/
  location /api {
    proxy_pass http://localhost:8080/test/;
  }
  # http://demo.com/test 就会跳转到http://localhost:8080/
  location / {
    proxy_pass http://localhost:8080; 
  }
}
```

##  跨域通信的几种方式

1. JSONP
2. WebSocket
3. Hash
4. postMessage

### JSONP

在 `CORS` 和 `postMessage` 以前，一直都是通过 `JSONP` 来做跨域通信的。

> 通过`<script>标签`的异步加载来实现的。比如说，实际开发中，head标签里，可以通过`<script url="xxx">`加载很多在线的插件。这就是用到了JSONP。

比如，客户端这样写：

```html
 <script src="https://shaohui-jin.github.io/?data=name&callback=jsonp_xxxx"></script>
```

于是，本地要求创建一个 jsonp_xxxx 的全局函数，才能将返回的数据执行出来。

```js
function jsonp(url, params, callback) {
  // 接收接口所需的所有参数及callback的函数名
  let paramList = []
  for (let key in params) {
    paramList.push(`${key}=${params[key]}`)
  }
  // 随机callback函数名称
  let random = Math.random().toString().replace('.', '')
  const callbackName = 'jsonp_' + random
  paramList.push(`callback=${callbackName}`)
  const urlStr = url + '?' + paramList.join('&')
  window[callbackName] = function (param) {      //根据回调名称注册一个全局的函数
    if (callback && typeof callback === 'function') {
      callback(param)
    }
  };
  // 生成element
  const script = document.createElement('script')
  script.src = urlStr
  // 放入body, 立即调用全局函数 callbackName
  document.body.appendChild(script)
  // js拿到后，移除文件
  document.body.removeChild(script)
  // 删除函数或变量
  window[callbackName] = null;  //最后不要忘了删除
}
```

### WebSocket

```js
let ws = new WebSocket('wss://shaohui-jin.github.io'); //创建WebSocket的对象。参数可以是 ws 或 wss，后者表示加密。

//把请求发出去
ws.onopen = function (evt) {
  console.log('Connection open ...');
  ws.send('Hello WebSockets!');
};

//对方发消息过来时，我接收
ws.onmessage = function (evt) {
  console.log('Received Message: ', evt.data);
  ws.close();
};

//关闭连接
ws.onclose = function (evt) {
  console.log('Connection closed.');
};
```

### Hash

url的 `#` 后面的内容就叫 **Hash**。 **Hash** 的改变，页面不会刷新。这就是用 **Hash** 做跨域通信的基本原理。

url的 `?` 后面的内容叫 **Search**。**Search** 的改变，会导致页面刷新，因此不能做跨域通信。

```js {3,6-8}
//伪代码
let B = document.getElementsByTagName('iframe');
B.src = B.src + '#' + 'jsonString';  // 可以把JS 对象，通过 JSON.stringify()方法转成 json字符串，发给 B

// B中的伪代码
window.onhashchange = function () {  //通过onhashchange方法监听，url中的 hash 是否发生变化
  let data = window.location.hash;
}
```

### postMessage

```js
// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息
Awindow.postMessage('data', 'http://B.com'); //这里强调的是B窗口里的window对象

// 在窗口B中监听 message 事件
Bwindow.addEventListener('message', function (event) {   //这里强调的是A窗口里的window对象
  console.log(event.origin);  //获取 ：url。这里指：http://A.com
  console.log(event.source);  //获取：A window对象
  console.log(event.data);    //获取传过来的数据
}, false);
```

