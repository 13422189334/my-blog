---
title: 跨域
lang: zh-CN
date: 2022-06-01 15:28:16
permalink: /Network/CrossDomain/
category: 
  - Network
tag: 
  - Network
---

## 同源策略的概念和具体限制

同源策略：限制 **从一个源加载的文档或脚本** 如何与 **来自另一个源的资源** 进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）

具体解释：

- `源`包括三个部分：协议、域名、端口。如果有任何一个部分不同，则`源`不同，那就是跨域了。
- `限制`：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：
  - `Cookie`、`LocalStorage`和`IndexDB`无法获取。
  - 无法获取和操作`DOM`。
  - 不能发送`Ajax`请求。我们要注意，`Ajax`只适合`同源`的通信。

<!-- more -->

## 前后端如何通信

主要有以下几种方式：

- `Ajax`：不支持跨域。
- `WebSocket`：不受同源策略的限制，支持跨域
- `CORS`：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：`同时支持同源和跨域的Ajax`。

###  如何创建Ajax

1. 创建 `XMLHttpRequest` 对象。
2. 使用`open`方法设置请求的参数。`open(method, url, 是否异步)`
3. 发送请求。 
4. 注册事件。 注册 `onreadystatechange` 事件，状态改变时就会调用。 
5. 获取返回的数据，更新UI。

### 发送 get 请求

```javascript
// （1）创建异步对象
let ajaxObj = new XMLHttpRequest();
// （2）设置请求的参数。包括：请求的方法、请求的url。
ajaxObj.open('get', 'xxx');
// （3）发送请求
ajaxObj.send();
//（4）注册事件。 onreadystatechange事件，状态改变时就会调用。
//如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。
ajaxObj.onreadystatechange = function () {
  // 为了保证 数据 完整返回，我们一般会判断 两个值
  if (ajaxObj.readyState == 4 && ajaxObj.status == 200) {
    // 如果能够进到这个判断 说明 数据 完美的回来了,并且请求的页面是存在的
    // 5.在注册的事件中 获取 返回的 内容 并修改页面的显示
    console.log('数据返回成功');
    // 数据是保存在 异步对象的 属性中
    console.log(ajaxObj.responseText);
    // 修改页面的显示
    document.querySelector('h1').innerHTML = ajaxObj.responseText;
  }
}
```

### 发送 post 请求

```javascript
// 异步对象
let xhr = new XMLHttpRequest();
// 设置属性
xhr.open('post', 'xxx');
// 如果想要使用post提交数据,必须添加此行
xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
// 将数据通过send方法传递
xhr.send('name=fox&age=18');
// 发送并接受返回值
xhr.onreadystatechange = function () {
  // 这步为判断服务器是否正确响应
  if (xhr.readyState == 4 && xhr.status == 200) {
    alert(xhr.responseText);
  }
};
```

### onreadystatechange

注册 `onreadystatechange` 事件后，每当 `readyState` 属性改变时，就会调用 `onreadystatechange` 函数。

`readyState`：（存有 `XMLHttpRequest` 的状态。从 0 到 4 发生变化）

- `0`: 请求未初始化
- `1`: 服务器连接已建立
- `2`: 请求已接收
- `3`: 请求处理中
- `4`: 请求已完成，且响应已就绪

### 事件的触发条件

| 事件 | 触发条件                                                                                                                                                                                                                                                                                                  |
|----|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|  onreadystatechange  | 每当 `xhr.readystate` 改变时触发；但 `xhr.readystate` 由 非 `θ` 值变为 `0` 时不触发                                                                                                                                                                                                                                     |
|  onloadstart  | 调用 `xhr.send()` 方法后立即触发，若 `xhr.send()` 未被调用则不会触发此事件。                                                                                                                                                                                                                                                  |
|  onprogress  | `xhr.upload.onprogress` 在上传阶段(即 `xhr.send()`之后，`xhr.readystate=2` 之前)触发，每50ms触发一次；`xhr.onprogress` 在下载阶段(即 `xhr.readystate=3` 时)触发，每50ms触发一次。                                                                                                                                                         |
|  onload  | 当请求成功完成时触发，此时 `xhr.readystate=4`                                                                                                                                                                                                                                                                      |
|  onloadend  | 当请求结束(包括请求成功和请求失败)时触发                                                                                                                                                                                                                                                                                 |
|  onabort  | 当调用 `xhr.abort()` 后触发                                                                                                                                                                                                                                                                                 |
|  ontimeout  | `xhr.timeout` 不等于0，由请求开始即 `onloadstart` 开始算起，当到达 `xhr.timeout` 所设置时间请求还未结束即 `onloadend`，则触发此事件。                                                                                                                                                                                                       |
|  onerror  | 在请求过程中，若发生 `Network error` 则会触发此事件(若发生 `Network error` 时，上传还没有结束，则会先触发 `xhr.upload.onerror`，再触发 `xhr.onerror`；若发生 Network error 时，上传已经结束，则只会触发 `xhr.onerror` )。注意，只有发生了 **网络层级别** 的异常才会触发此事件，对于应用层级别的异常，如响应返回的 `xhr.statuscode` 是 `4xx` 时，并不属于 `Network error`，所以不会触发 `onerror` 事件，而是会触发 `onload` 事件。 |


## 如何解决跨域

### **被调用方（即服务端）解决**

**调用方** 将请求发送至 **被调用方**，被调用方处理完成后，在请求响应中添加基于 **http协议** 关于跨域请求的一些规定，就是在 http响应头 中添加 **Access-Control-Allow-Origin** 等一些配置允许跨域访问。

```java
// 允许跨域的域名，设置*表示允许除带Cookies信息的所有域名
response.addHeader("Access-Control-Allow-Origin", "*"); 
```

### **调用方（即客户端）解决**

**调用方** 的 请求url 经过调用方的 **Nginx** 做反向代理转换，修改 **调用方** 的HTTP服务器，目的就是为了和 **被调用方** 的域名端口一致，在浏览器中也就只能看到调用方的url。

### 补充后端解决跨域问题

如果是在被调用方解决跨域问题，被调用方解决支持跨域办法如下：

1. 在应用服务器端实现
2. 在Ngnix上配置
3. 在Apache上配置
4. Spring框架解决

虽然有4种方案，但是这4种方案的本质都是一样的，最终的目的是在响应头增加字段。浏览器在执行跨域请求时，如果遇到是简单请求，则先执行后判断；如果是非简单请求，则先使用OPTION向服务器发起一个预检请求 **preflight request** ，从而获知服务器是否允许该跨域访问，如果允许，就在此发起带真实数据的请求，否则不发起。这就实现了对被调用方的数据安全保护，也是跨域问题设计所在的目的之一。

>在介绍简单/非简单请求前，我们要了解什么是 Content-Type，**Content-Type是指http/https发送信息至服务器时的内容编码类型**


- **举个例子**

我们在本地搭起来了一个后端项目，端口号为8080；同时搭建了一个前端项目，端口号为9527。那这个时候我们直接调用后端接口的时候，前后端分离的原因导致我们需要跨域请求 。因此，在应用服务器端的响应头需要添加允许跨域的设置，即如下：

``` java
@Override
public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
  throws IOException, ServletException {

  HttpServletResponse res = (HttpServletResponse) response;

  // 允许跨域的域名，设置*表示允许除带Cookies信息的所有域名
  res.addHeader("Access-Control-Allow-Origin", "http://localhost:9527"); 
  // 允许跨域的方法，可设置*表示所有。GET/POST/OPTIONS等
  res.addHeader("Access-Control-Allow-Methods", "GET"); 
  // 假如给post请求头设置了contentType字段，则需要添加以下信息
  res.addHeader("Access-Control-Allow-Headers", "Content-Type");
  // 设置预检命令的缓存时效。单位是"秒"
  // 如果没有失效，则不会再次发起OPTION预检请求
  res.addHeader("Access-Control-Max-Age", "3600");
  // 还可以有其他配置...
  chain.doFilter(request, response); //让过滤器放行该请求
}
```
这时候，我们就可以在响应头Response Headers里观察到 **Access-Control-Allow-Origin** 和 **Access-Control-Allow-Methods** 信息，这代表跨域就被成功允许了。

- **还有一种特殊情况**

带有Cookie的请求还需要注意一下两点才能实现跨域：

1. Access-Control-Allow-Origin的值不能为 **'*'** 而是必须是精准匹配，因此需要添上具体的域名
2. 打开允许Cookie的设置，即Access-Control-Allow-Credentials: true

但是这又带出了另一个问题，就是只能支持一个域名的跨域，怎么办？其实该变量可以通过调用方的请求头信息获取，解决办法如下：

``` java
HttpServletRequest req = (HttpServletRequset) request;
String origin =  req.getHeader('Origin');
if (!org.springframework.util.StringUtils.isEmpty(origin)) {
  // 带cookie的时候origin必须是全匹配，不能使用 *
  res.addHeader("Access-Control-Allow-Orign", origin);
}
```
对于需要增加请求头信息解决方案与此类似

**调用方解决跨域：反向代理**

当被调用方无法帮助解决处理跨域问题时，调用方也可以自己解决处理。其实现的办法就是利用反向代理

> **正向代理：** 利用代理客户端去请求服务器，从而隐藏了真实的客户端，服务器并不知道客户端是谁，这种代理方式称作正向代理，其代理的对象是客户端
> 
> **反向代理:** 反向代理隐藏了真正的服务端。举个例子，我们只知道敲下www.baidu.com时就能访问百度搜索页面，然而背后成千上万的服务器到底是哪一台正在为我们服务我们并不知道，这种隐藏了服务器端的代理方式称作反向代理，其代理的是服务器端。软件层面上常用Ngnix来做反向代理服务器，他的性能很好，用来做负载均衡。


为了实现反向代理，我们需要在 Ngnix中配置一个代理域名，或者称为一个网址demo.com，就像百度成千上万的服务器使用用一个代理网址www.baidu.com一样。ngnix的配置信息如下

```nginx
server {
  listen 80;
  server_name: demo.com; # 请求域名是demo.com，端口是80的，都会被nginx做代理
  # http://demo.com/api/test 就会跳转到http://localhost:8080/test/
  location /api {
    proxy_pass http://localhost:8080/test/;
  }
  # http://demo.com/test 就会跳转到http://localhost:8080/
  location / {
    proxy_pass http://localhost:8080; 
  }
}
```

## 总结

跨域是由浏览器安全限制造成的，解决跨域的办法有三种，一是 **Jsonp** 绕过浏览器安全检测策略，二是从被调用方配置支持跨域的请求头信息，三是从调用方利用反向代理，在 Ngnix 或 Apache 中配置代理域名隐藏跨域。 
