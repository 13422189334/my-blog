<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://jin-shaohui.gitee.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://jin-shaohui.gitee.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>繁华中自律，落魄中自愈</title>
    <link>https://jin-shaohui.gitee.io/</link>
    <description>Just playing around</description>
    <language>zh-CN</language>
    <pubDate>Mon, 11 Mar 2024 09:06:31 GMT</pubDate>
    <lastBuildDate>Mon, 11 Mar 2024 09:06:31 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>MIT Licensed | Copyright © 2019-present JSH</copyright>
    <image>
      <title>繁华中自律，落魄中自愈</title>
      <url>https://jin-shaohui.gitee.io/logo/logo.gif</url>
      <link>https://jin-shaohui.gitee.io/</link>
    </image>
    <category>JavaScript</category>
    <category>nginx</category>
    <category>性能优化</category>
    <category>算法</category>
    <category>设计模式</category>
    <category>Git</category>
    <category>推荐</category>
    <category>服务器</category>
    <category>Java</category>
    <category>PackageJson</category>
    <category>Webpack</category>
    <category>Canvas</category>
    <category>Svg</category>
    <category>CSS</category>
    <category>Question</category>
    <category>微前端</category>
    <category>Network</category>
    <category>React</category>
    <category>ECMAScript</category>
    <category>前端规范</category>
    <category>VUE</category>
    <category>VUE3</category>
    <item>
      <title>闭包</title>
      <link>https://jin-shaohui.gitee.io/Interview/JavaScript/Closure/</link>
      <guid>https://jin-shaohui.gitee.io/Interview/JavaScript/Closure/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">闭包</source>
      <description>闭包（Closure） 是指一个函数包含了 对其外部作用域中变量的引用 ， 即使在该函数外部作用域执行完毕后，仍然可以访问这些变量。 闭包允许你在一个函数内部访问另一个函数的变量，这在许多编程语言中是一种强大的特性。 闭包定义应用场景 保护私有变量：闭包允许你创建一个包含私有数据的函数，这些数据对外部是不可见的。这在模块化编程中非常有用，可以防止外部代码直接访问和修改内部状态。例如： function counter() { let count = 0; return function () { count++; console.log(count); }; } const increment = counter(); increment(); // 输出 1 increment(); // 输出 2</description>
      <category>JavaScript</category>
      <pubDate>Mon, 11 Mar 2024 14:58:43 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>闭包（Closure）</strong> 是指一个函数包含了 <strong>对其外部作用域中变量的引用</strong> ，
即使在该函数外部作用域执行完毕后，仍然可以访问这些变量。
闭包允许你在一个函数内部访问另一个函数的变量，这在许多编程语言中是一种强大的特性。</p>
<h2> 闭包定义应用场景</h2>
<ol>
<li>保护私有变量：闭包允许你创建一个包含私有数据的函数，这些数据对外部是不可见的。这在模块化编程中非常有用，可以防止外部代码直接访问和修改内部状态。例如：</li>
</ol>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>nginx常用变量</title>
      <link>https://jin-shaohui.gitee.io/Nginx/CommonVariables/</link>
      <guid>https://jin-shaohui.gitee.io/Nginx/CommonVariables/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">nginx常用变量</source>
      <description>$args ## URL中的查询字符串，如 http://example1.com/?foo=123&amp;amp;bar=blahblah中的foo=123&amp;amp;bar=blahblah $binary_remote_addr ## 二进制形式的IP，节省空间. $body_bytes_sent ## 发送的body字节数. $content_length ## HTTP请求信息里的 Content-Length; $content_type ## HTTP请求信息里的 Content-type $document_root ## 当前请求的目录 $document_uri ## 同 $uri. $uri ## 请求的 URI，可能和最初的值有不同，比如经过重定向之类的 $host ## 请求的主机 $http_HEADER ## 请求头 $request_uri ## 请求的原始URI $server_addr ## 服务器地址 $server_name ## 服务器名称 $server_port ## 服务器的端口 $server_protocol ## 通常是 HTTP/1.0 或者 HTTP/1.1. $upstream_cache_status ## 缓存是否命中</description>
      <category>nginx</category>
      <pubDate>Wed, 21 Jun 2023 11:25:42 GMT</pubDate>
      <content:encoded><![CDATA[<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>nginx内核模块</title>
      <link>https://jin-shaohui.gitee.io/Nginx/Core/</link>
      <guid>https://jin-shaohui.gitee.io/Nginx/Core/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">nginx内核模块</source>
      <description>内核模块用于控制 nginx服务器 的基本功能，内核参数的修改需要重新启动nginx才能生效？？？ 用于调试进程，定位问题的配置项 daemon 是否以 守护进程 方式启动nginx 语法： daemon on|off; 默认： daemon on; 守护进程（daemon） 是 脱离终端 并且在 后台运行 的进程。 它脱离终端是为了避免进程执行过程中的信息在任何终端上显示，这样一来，进程也不会被任何终端所产生的信息所打断。 nginx毫无疑问是一个需要以守护进程方式运行的服务，因此，默认 都是以这种方式运行的。 不过 nginx 还是提供了 关闭 守护进程的模式，之所以提供这种模式，是为了 方便跟踪调试nginx，毕竟用 gdbLinux常用的程序调试器 调试进程时最烦琐的就是如何继续跟进fork出的子进程了。</description>
      <category>nginx</category>
      <pubDate>Tue, 20 Jun 2023 10:04:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>内核模块用于控制 <strong>nginx服务器</strong> 的基本功能，内核参数的修改需要重新启动nginx才能生效？？？</p>
<h3> 用于调试进程，定位问题的配置项</h3>
<h4> daemon</h4>
<div class="hint-container info">
<p class="hint-container-title">是否以 守护进程 方式启动nginx</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>守护进程（daemon）</strong> 是 <strong>脱离终端</strong> 并且在 <strong>后台运行</strong> 的进程。
它脱离终端是为了避免进程执行过程中的信息在任何终端上显示，这样一来，进程也不会被任何终端所产生的信息所打断。
<code>nginx毫无疑问是一个需要以守护进程方式运行的服务</code>，因此，<strong>默认</strong> 都是以这种方式运行的。
不过 nginx 还是提供了 <strong>关闭</strong> 守护进程的模式，之所以提供这种模式，是为了 <strong>方便跟踪调试nginx</strong>，毕竟用 <strong>gdb</strong><sup>Linux常用的程序调试器</sup> 调试进程时最烦琐的就是<code>如何继续跟进fork出的子进程</code>了。</p>
</div>
<h4> master_process</h4>
<div class="hint-container info">
<p class="hint-container-title">是否以 master/worker 方式工作</p>
<ul>
<li>on时（默认），以 <strong>master/worker</strong> 进程运行</li>
<li>off时，以 <strong>master</strong> 进程运行</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认 nginx 是以 <strong>一个master进程</strong> 管理 <strong>多个 worker进程</strong> 的方式运行的，几乎所有的产品环境下，nginx都以这种方式工作。</p>
<p>与daemon配置相同，提供 <strong>master_process</strong> 配置也是为了 <strong>方便跟踪调试nginx</strong>。如果用 <strong>关闭</strong> 了 <strong>master_process</strong> 方式，就不会 fork 出 worker子进程 来处理请求，而是用 <strong>master进程</strong> 自身来处理请求。</p>
</div>
<h4> error_log</h4>
<div class="hint-container info">
<p class="hint-container-title">日志文件配置</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>path/to/file</strong> 参数可以是一个具体的文件</p>
<ul>
<li>默认情况下是 <strong>logs/error.log</strong> 文件，最好将它放到一个磁盘空间足够大的位置</li>
<li>可以是 <strong>/dev/null</strong>，这样就不会输出任何日志了，这也是关闭 <strong>error日志</strong> 的 <strong>唯一手段</strong></li>
<li>可以是 <strong>stderr</strong>，这样日志会输出到 <strong>标准错误文件</strong></li>
</ul>
<p><strong>level</strong> 是日志的输出级别</p>
<ul>
<li>取值范围是 <code>debug</code>、<code>info</code>、<code>notice</code>、<code>warn</code>、<code>error</code>、<code>crit</code>、<code>alert</code>、<code>emerg</code>，从左至右级别依次增大</li>
<li>如果日志级别设定到 <strong>debug</strong>，必须在 configure 时加入 <strong>-–with-debug</strong> 配置项</li>
</ul>
</div>
<h4> debug_points</h4>
<div class="hint-container info">
<p class="hint-container-title">是否处理几个特殊的调试点</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该指令用于 nginx 调试，可用来帮助用户调试nginx。<strong>debug_points</strong> 接收2个参数，分别为：<strong>stop</strong> 和 <strong>abort</strong>。</p>
<p>nginx 在一些关键的错误逻辑中（nginx 1.0.14版本中有8处）设置了调试点。如果设置为 <strong>stop</strong>，那么 nginx 的代码执行到这些调试点时，会发出 <strong>SIGSTOP</strong> 信号。如果设置为 <strong>abort</strong>，则会产生一个 <strong>coredump</strong> 文件，可以使用gdb来查看nginx当时的各种信息。</p>
</div>
<h4> debug_connection</h4>
<div class="hint-container info">
<p class="hint-container-title">仅对指定的客户端输出debug级别的日志</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个配置项实际上属于 <strong>事件类</strong> 配置，因此，它必须放在 <strong>events{...}</strong> 中才有效。它的值可以是 <strong>IP地址</strong> 或 <strong>CIDR地址</strong> ，例如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，仅仅来自以上 <strong>IP地址</strong> 的请求才会输出 <strong>debug级别</strong> 的日志，其他请求仍然沿用 <strong>error_log</strong> 中配置的日志级别。<code>上面这个配置对修复Bug很有用，特别是定位高并发请求下才会发生的问题。</code></p>
<p>使用 <strong>debug_connection</strong> 前，需确保在执行 <strong>configure</strong> 时已经加入了 <strong>--with-debug</strong> 参数，否则不会生效。</p>
</div>
<h4> worker_rlimit_core</h4>
<div class="hint-container info">
<p class="hint-container-title">限制 coredump 核心转储文件的大小</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在Linux系统中，当进程 <strong>发生错误</strong> 或 <strong>收到信号</strong> 而终止时，系统会将进程执行时的内存内容（<strong>核心映像</strong>）写入一个文件（<strong>core文件</strong>），以作为调试之用，这就是所谓的 <strong>核心转储（core dumps）</strong>。</p>
<p>当Nginx进程出现一些 <strong>非法操作（如内存越界）</strong> 导致进程直接被操作系统强制结束时，会 <strong>生成核心转储core文件</strong>，可以从 core 文件获取当时的堆栈、寄存器等信息，从而帮助我们定位问题。</p>
<p>但这种core文件中的许多信息 <strong>不一定是用户需要的</strong>，如果不加以限制，那么可能一个core文件会达到几GB，这样随便 <strong>coredumps</strong> 几次就会把磁盘占满，引发严重问题。</p>
<p>通过 <strong>worker_rlimit_core</strong> 配置可以限制 <strong>core文件</strong> 的大小，从而有效帮助用户定位问题。</p>
</div>
<h4> working_directory</h4>
<div class="hint-container info">
<p class="hint-container-title">指定 coredump 文件生成目录</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>worker进程的工作目录。这个配置项的唯一用途就是设置 <strong>coredump</strong> 文件所放置的目录。因此，需确保 worker进程 <strong>有权限</strong> 向 <strong>working_directory</strong> 指定的目录中写入文件。</p>
</div>
<h3> 正常运行的必备配置</h3>
<h4> env</h4>
<div class="hint-container info">
<p class="hint-container-title">定义环境变量</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个配置项可以让用户直接设置 <strong>操作系统</strong> 上的 <strong>环境变量</strong></p>
</div>
<h4> include</h4>
<div class="hint-container info">
<p class="hint-container-title">嵌入其他配置文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>include 配置项 可以将 <strong>其他配置文件</strong> 嵌入到当前的 <strong>nginx.conf</strong> 文件中，
它的参数 既可以是 <strong>绝对路径</strong>，也可以是 <strong>相对路径</strong>（相对于Nginx的配置目录，即nginx.conf所在的目录）。
参数的值可以是一个 <strong>明确的文件名</strong>，也可以是含有 <strong>通配符*的文件名</strong>，同时可以一次嵌入多个配置文件。</p>
</div>
<h4> pid</h4>
<div class="hint-container info">
<p class="hint-container-title">指定nginx的pid文件</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>保存 <strong>master进程ID</strong> 的 pid文件存放路径。</p>
<p>默认与 <strong>configure</strong> 执行时的参数 <strong>–pid-path</strong> 所指定的路径是相同的，也可以随时修改，但应确保 nginx <strong>有权限</strong>在相应的目标中<strong>创建pid文件</strong>，该文件直接影响 nginx 是否可以运行。</p>
</div>
<h4> user</h4>
<div class="hint-container info">
<p class="hint-container-title">指定运行 worker进程 的用户和组</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>user用于设置 <strong>master进程</strong> 启动后，fork出的 <strong>worker进程</strong> 运行在哪个用户和用户组下。当按照 <strong><code>user username;</code></strong> 设置时，<strong>用户组名</strong> 与 <strong>用户名</strong> 相同。</p>
<p>若用户在 configure 命令执行时使用了参数 <strong><code>–user=username</code></strong> 和 <strong><code>–group=groupname</code></strong> ，此时 nginx.conf 将使用参数中指定的 <strong>用户</strong> 和 <strong>用户组</strong>。</p>
</div>
<h4> worker_rlimit_nofile</h4>
<div class="hint-container info">
<p class="hint-container-title">指定 nginx worker进程 可以打开的最大句柄描述符个数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<h4> worker_rlimit_sigpending</h4>
<div class="hint-container info">
<p class="hint-container-title">指定每个用户能够发往worker的信号的数量</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置每个用户发往 nginx 的 <strong>信号队列的大小</strong>。也就是说，当某个用户的信号队列满了，这个用户再发送的信号量会被 <strong>丢掉</strong></p>
</div>
<h3> 优化性能相关的配置</h3>
<h4> worker_processes</h4>
<div class="hint-container info">
<p class="hint-container-title">worker线程的个数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在 master/worker 运行方式下，即 <strong><code>master_process on;</code></strong> ，定义 <strong>worker进程</strong> 的个数。</p>
<p>通常应该为物理CPU核心个数减1；</p>
<p>worker进程的数量会直接影响性能。</p>
<p>每个 worker进程 都是 <strong>单线程的进程</strong>，它们会调用各个模块以实现多种多样的功能。
如果这些模块确认不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程；反之，如果有可能出现阻塞式调用，那么需要配置稍多一些的worker进程。</p>
<p>例如，如果业务方面会致使用户请求大量读取本地磁盘上的静态资源文件，而且服务器上的内存较小，以至于大部分的请求访问静态资源文件时都必须读取磁盘（磁头的寻址是缓慢的），而不是内存中的磁盘缓存，那么磁盘I/O调用可能会阻塞住worker进程少量时间，进而导致服务整体性能下降。</p>
<p>多worker进程可以充分利用多核系统架构，但若worker进程的数量多于CPU内核数，那么会增大进程间切换带来的消耗（Linux是抢占式内核）。一般情况下，用户要配置与CPU内核数相等的worker进程，并且使用下面的worker_cpu_affinity配置来绑定CPU内核。</p>
</div>
<h4> worker_cpu_affinity</h4>
<div class="hint-container info">
<p class="hint-container-title">绑定Nginx worker进程到指定的CPU内核</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>为什么要绑定worker进程到指定的CPU内核呢？假定每一个worker进程都是非常繁忙的，如果多个worker进程都在抢同一个CPU，那么这就会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。</p>
<p>例如，如果有4颗CPU内核，就可以进行如下配置：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>将第1个进程绑定到CPU0/CPU2上,将第2个进程绑定到CPU1/CPU3上,这个对于超线程CPU合适</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：worker_cpu_affinity配置仅对Linux操作系统有效。Linux操作系统使用sched_setaffinity()系统调用实现这个功能。</p>
</div>
<h4> ssl_engine</h4>
<div class="hint-container info">
<p class="hint-container-title">SSL硬件加速</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果服务器上有SSL硬件加速设备，那么就可以进行配置以加快SSL协议的处理速度。用户可以使用OpenSSL提供的命令来查看是否有SSL硬件加速设备：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<h4> timer_resolution</h4>
<div class="hint-container info">
<p class="hint-container-title">系统调用 gettimeofday 的执行频率</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>默认情况下，每次内核的事件调用（如epoll、select、poll、kqueue等）返回时，都会执行一次gettimeofday，实现用内核的时钟来更新Nginx中的缓存时钟。
在早期的Linux内核中，gettimeofday的执行代价不小，因为中间有一次内核态到用户态的内存复制。
当需要降低gettimeofday的调用频率时，可以使用timer_resolution配置。例如，“timer_resolution 100ms；”表示至少每100ms才调用一次gettimeofday。</p>
<p>但在目前的大多数内核中，如x86-64体系架构，gettimeofday只是一次vsyscall，仅仅对共享内存页中的数据做访问，并不是通常的系统调用，代价并不大，一般不必使用这个配置。
而且，如果希望日志文件中每行打印的时间更准确，也可以使用它。</p>
</div>
<h4> worker_priority</h4>
<div class="hint-container info">
<p class="hint-container-title">Nginx worker进程优先级设置</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>该配置项用于设置Nginx worker进程的nice优先级。</p>
<p>在Linux或其他类UNIX操作系统中，当许多进程都处于可执行状态时，将按照所有进程的优先级来决定本次内核选择哪一个进程执行。
进程所分配的CPU时间片大小也与进程优先级相关，优先级越高，进程分配到的时间片也就越大（例如，在默认配置下，最小的时间片只有5ms，最大的时间片则有800ms）。
这样，优先级高的进程会占有更多的系统资源。</p>
<p>优先级由静态优先级和内核根据进程执行情况所做的动态调整（目前只有±5的调整）共同决定。
nice值是进程的静态优先级，它的取值范围是–20~+19，–20是最高优先级，+19是最低优先级。
因此，如果用户希望Nginx占有更多的系统资源，那么可以把nice值配置得更小一些，但不建议比内核进程的nice值（通常为–5）还要小。</p>
</div>
<h3> 事件类配置项</h3>
<h4> worker_connections</h4>
<div class="hint-container info">
<p class="hint-container-title">每个worker的最大连接数</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>定义每个worker进程可以同时处理的最大连接数。</p>
</div>
<h4> accept_mutex</h4>
<div class="hint-container info">
<p class="hint-container-title">是否打开accept锁</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>accept_mutex是Nginx的负载均衡锁，本书会在第9章事件处理框架中详述Nginx是如何实现负载均衡的。
这里，读者仅需要知道accept_mutex这把锁可以让多个worker进程轮流地、序列化地与新的客户端建立TCP连接。
当某一个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，
以此实现所有worker进程之上处理的客户端请求数尽量接近。</p>
<p>accept锁默认是打开的，如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡，因此不建议关闭它。</p>
</div>
<h4> lock_file</h4>
<div class="hint-container info">
<p class="hint-container-title">lock文件的路径</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>accept锁可能需要这个lock文件，如果accept锁关闭，lock_file配置完全不生效。
如果打开了accept锁，并且由于编译程序、操作系统架构等因素导致Nginx不支持原子锁，
这时才会用文件锁实现accept锁（14.8.1节将会介绍文件锁的用法），这样lock_file指定的lock文件才会生效。</p>
<p>注意 　在基于i386、AMD64、Sparc64、PPC64体系架构的操作系统上，若使用GCC、Intel C++、SunPro C++编译器来编译Nginx，
则可以肯定这时的Nginx是支持原子锁的，因为Nginx会利用CPU的特性并用汇编语言来实现它（可以参考14.3节x86架构下原子操作的实现）。
这时的lock_file配置是没有意义的。</p>
</div>
<h4> accept_mutex_delay</h4>
<div class="hint-container info">
<p class="hint-container-title">使用accept锁后到真正建立连接之间的延迟时间</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。
这个accept锁不是阻塞锁，如果取不到会立刻返回。
如果有一个worker进程试图取accept锁而没有取到，它至少要等accept_mutex_delay定义的时间间隔后才能再次试图取锁。</p>
</div>
<h4> multi_accept</h4>
<div class="hint-container info">
<p class="hint-container-title">批量建立新连接</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当事件模型通知有新连接时，尽可能地对本次调度中客户端发起的所有TCP请求都建立连接。</p>
</div>
<h4> use</h4>
<div class="hint-container info">
<p class="hint-container-title">选择事件模型</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于Linux操作系统来说，可供选择的事件驱动模型有poll、select、epoll三种。epoll当然是性能最高的一种，在9.6节会解释epoll为什么可以处理大并发连接。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>nginx的功能</title>
      <link>https://jin-shaohui.gitee.io/Nginx/Function/</link>
      <guid>https://jin-shaohui.gitee.io/Nginx/Function/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">nginx的功能</source>
      <description>nginx的特性 模块化设计、较好扩展性 但不支持动态模块加载，编译时启用的模块在nginx启动时会全部加载；1.9.11部分模块支持DSO 高可靠性 master进程负责管理 worker进程的崩溃不会相互影响 低内存消耗 10000个keep-alive连接在nginx仅消耗2.5MB 支持热部署 不停机而更新配置文件、更换日志文件、更新服务器程序版本 基本HTTP功能</description>
      <category>nginx</category>
      <pubDate>Tue, 20 Jun 2023 10:04:14 GMT</pubDate>
      <content:encoded><![CDATA[<h3> nginx的特性</h3>
<ul>
<li>模块化设计、较好扩展性</li>
</ul>
<p>但不支持动态模块加载，编译时启用的模块在nginx启动时会全部加载；1.9.11部分模块支持DSO</p>
<ul>
<li>高可靠性</li>
</ul>
<p>master进程负责管理 worker进程的崩溃不会相互影响</p>
<ul>
<li>低内存消耗</li>
</ul>
<p>10000个keep-alive连接在nginx仅消耗2.5MB</p>
<ul>
<li>支持热部署</li>
</ul>
<p>不停机而更新配置文件、更换日志文件、更新服务器程序版本</p>
<h3> 基本HTTP功能</h3>
<ul>
<li>提供静态文件和index文件，生成自动索引，缓存打开文件的描述符；</li>
<li>使用缓存加快反向代理和FastCGI访问；</li>
<li>模块化结构，过滤器包括gzip，字节range，chunk响应，XSLT，SSI(Server Side Include)，图像大小调；整，被传到后台服务器的多个SSI指令在单个页面并行处理；</li>
<li>支持SSL和TLS SNI；</li>
</ul>
<h3> 其他HTTP功能</h3>
<ul>
<li>基于名称和IP的虚拟服务器；</li>
<li>基于客户端IP和HTTP基本认证的访问控制；</li>
<li>支持keepalive和管道连接；</li>
<li>平滑的重新配置和在线升级；</li>
<li>定制访问日志格式，缓存日志写入和快速日志轮询；</li>
<li>3xx-5xx错误重定向，定制错误页面；</li>
<li>支持url rewrite；</li>
<li>FLV流文件；</li>
<li>速度限制；</li>
<li>限制同时连接数或者来自同一个IP地址的请求；</li>
</ul>
<h3> 邮件代理服务器</h3>
<h3> 架构和可扩展性</h3>
<ul>
<li>
<p>一个主进程和多个工作进程，工作进程以非特权用户运行；
主进程必须以管理员身份启动（启动&lt;1023端口必须使用管理员身份），主进程用来监控和管理工作进程；主进程加载配置文件后，若有错误，不会影响工作进程；重新再加载正确后，新的连接建立时使用新配置。</p>
</li>
<li>
<p>支持的事件机制的IO框架
kqueue（FreeBSD 4.1+）、epoll（Linux 2.6+）、rt signals（Linux 2.2.19+）、/dev/poll（Solaris 7 11/99+）、event ports（Solaris 10）、select以及poll（次之）；
众多支持的kqueue特性包括EV_CLEAR、EV_DISABLE（临时禁止事件）、NOTE_LOWAT、EV_EOF，可用数据的数量，错误代码；</p>
</li>
<li>
<p>支持sendfile（FreeBSD 3.1+, Linux 2.2+, Mac OS X 10.5+）、sendfile64（Linux 2.4.21+）和sendfilev（Solaris 8 7/01+）；
用户请求响应不经过用户空间，报文在内核完成http封装直接从内核响应给客户端，避免了响应报文从内核复制到用户空间，再从用户空间复制到内核空间在响应给客户，尽可能避免数据拷贝操作。</p>
</li>
<li>
<p>文件AIO（FreeBSD 4.3+, Linux 2.6.22+）；</p>
</li>
<li>
<p>DIRECTIO (FreeBSD 4.4+, Linux 2.4+, Solaris 2.6+, Mac OS X);</p>
</li>
<li>
<p>支持Accept-filters（FreeBSD 4.1+, NetBSD 5.0+）和 TCP_DEFER_ACCEPT（Linux 2.4+）；</p>
</li>
<li>
<p>支持连接过滤器，限制连接数</p>
</li>
<li>
<p>10000个非活跃的HTTP keep-alive连接仅占用约2.5M内存；</p>
</li>
</ul>
<h3> 模块类型</h3>
<ul>
<li>核心模块</li>
<li>Standard HTTP modules 标准http模块</li>
<li>Optional HTTP modules 可选http模块</li>
<li>Mail modules 邮件模块</li>
<li>3rd party modules 第三方模块</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>浅谈性能优化</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Performance/info/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Performance/info/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">浅谈性能优化</source>
      <description>JavaScript代码 作用域 随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加。访问全局变量总是要比访问局部变量慢，因为要遍历作用域链。 避免全局查找(少用全局变量)：将在一个函数中会多次用到的全局对象存储为局部变量总是没错的。 避免 with 语句：with会创建自己的作用域，因此会增加其中执行代码的 作用域链的长度。 DOM 用 innerHTML 代替DOM操作，减少DOM操作次数。 用 setTimeout 避免页面失去响应。 用变量保存 Ajax请求 结果，操作本地变量时不用请求，减少请求次数。 尽量使用 事件委托模式，避免批量绑定事件。</description>
      <category>性能优化</category>
      <pubDate>Fri, 24 Feb 2023 10:29:48 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">JavaScript代码</p>
<ul>
<li>作用域 <sup>随着作用域链中的作用域数量的增加，访问当前作用域以外的变量的时间也在增加。访问全局变量总是要比访问局部变量慢，因为要遍历作用域链。</sup>
<ol>
<li>避免全局查找(少用全局变量)：将在一个函数中会多次用到的全局对象存储为局部变量总是没错的。</li>
<li>避免 <strong>with</strong> 语句：with会创建自己的作用域，因此会增加其中执行代码的 <strong>作用域链的长度</strong>。</li>
</ol>
</li>
<li>DOM
<ol>
<li>用 <strong>innerHTML</strong> 代替DOM操作，减少DOM操作次数。</li>
<li>用 <strong>setTimeout</strong> 避免页面失去响应。</li>
</ol>
</li>
<li>用变量保存 <strong>Ajax请求</strong> 结果，操作本地变量时不用请求，减少请求次数。</li>
<li>尽量使用 <strong>事件委托模式</strong>，避免批量绑定事件。</li>
</ul>
</div>
<div class="hint-container info">
<p class="hint-container-title">HTML + css</p>
<ul>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>
</li>
<li>通过HTML设置 Viewport元标签， Viewport可以加速页面的渲染，如以下代码所示。
<code>&lt;meta name=viewport content=width=device=width,initial-scale=1&gt;</code></li>
<li>合理使用 <strong>CSS3动画</strong>，开启硬件加速，CSS中的属性（CSS3 transitions、CSS3 3D transforms、 Opacity、 Canvas、 WebGL、Video）触发 <strong>GPU渲染</strong>。
<ol>
<li>尽可能多地利用硬件能力，如使用3D变形来开启GPU加速，例如以下代码。
<ul>
<li><code>webkit-transform: translate 3d(0, 0, 0);</code></li>
<li><code>-moz-transform: translate3d(0,0, 0);</code></li>
<li><code>-ms-transform: translate 3d(0,0,0);</code></li>
<li><code>transform: translate3d(0,0,0);</code></li>
</ul>
</li>
<li>一个元素通过 translate3d右移500X的动画流畅度会明显优于使用left属性实现的动画移动，原因是CSS动画属性会触发整个页面重排、重绘、重组。paint通常是最耗性能的，尽可能避免使用触发 paint的CSS动画属性。如果动画执行过程中有闪烁（通常发生在动画开始的时候），可以通过如下方式处理。
<ul>
<li><code>-webkit-backface-visibility: hidden;</code></li>
<li><code>-moz-backface-visibility: hidden;</code></li>
<li><code>-ms-backface-visibility: hidden;</code></li>
<li><code>backface-visibility: hidden;</code></li>
<li><code>-webkit-perspective：1000;</code></li>
<li><code>-moz-perspective：1000;</code></li>
<li><code>-ms-perspective：1000;</code></li>
<li><code>perspective：1000;</code></li>
</ul>
</li>
<li>尽可能少使用box- shadows和 gradients，它们往往严重影响页面的性能，尤其是在一个元素中同时都使用时。</li>
<li>尽可能让动画元素脱离文档流，以减少重排，如以下代码所示。
<ul>
<li><code>position: fixed;</code></li>
<li><code>position: absolute;</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">图片</p>
<ul>
<li>优化图片文件，减小其尺寸</li>
<li>图片格式的选择(常用的图片格式：JPEG，GIF，和PNG。)
<ul>
<li>在同体积(24kb)下,jpeg图片显示效果最好。</li>
<li>gif更适合制作动画。</li>
<li>png对于非常小的 图片(小于5k)适用。</li>
</ul>
</li>
<li>为图片标明高度和宽度</li>
<li>对于图片懒加载，可以为页面添加一个滚动条事件，判断图片是否在可视区域内或者即将进入可视区域，优先加载。</li>
<li>如果为幻灯片、相册文件等，可以使用图片预加载技术，对于当前展示图片的前一张图片和后一张图片优先下载。</li>
<li>如果图片为CSS图片，可以使用 CSS Sprite、SVG sprite、 Icon font、Base64等技术。</li>
<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩得特别小的缩略图，以提高用户体验。</li>
<li>如果图片展示区域小于图片的真实大小，则应在服务器端根据业务需要先行进行图片压缩，图片压缩后，图片大小与展示的就一致了。</li>
<li>图片尽量避免使用 DataURL。DataURL图片没有使用图片的压缩算法，文件会变大，并且要在解码后再渲染，加载慢，耗时长。</li>
</ul>
</div>
</div>
<div class="hint-container info">
<p class="hint-container-title">移动端</p>
<ul>
<li>可以使用 <strong>touch事件</strong> 代替 <strong>click事件</strong>。</li>
<li>合理使用 <strong>requestAnimation Frame</strong>动画代替 <strong>setTimeout</strong>。</li>
<li>避免使用CSS3 <strong>渐变阴影</strong> 效果。</li>
</ul>
</div>
<div class="hint-container info">
<p class="hint-container-title">HTTP</p>
<ul>
<li>
<p>网址后面加斜杠(" <strong>/</strong> ")，服务器会直接找到 <strong>要处理的目录</strong>，如果后面不加斜杠，服务器会从文件开始找起，使加载时间延长。</p>
</li>
<li>
<p>使用 <strong>CDN</strong>、外部的JavaScript和CSS文件缓存，添加 <strong>Expires</strong> 头，在服务器端配置 <strong>Etag</strong>，减少DNS查找。 <sup>在浏览器地址栏中输入URL以后，浏览器首先要查询域名（hostname）对应服务器的IP地址，一般需要耗费20~120ms的时间。DNS查询完成之前，浏览器无法识别服务器IP，因此不下载任何数据。基于性能考虑，ISP运营商、局域网路由、操作系统、客户端（浏览器）均会有相应的DNS缓存机制。</sup></p>
<ol>
<li>正IE缓存30min，可以通过注册表中 DnsCacheTimeout项设置。</li>
<li>Firefox混存1 min，通过 network.dnsCacheExpiration配置。</li>
<li>在 Chrome中通过依次单击“设置”→“选项”→“高级选项”，并勾选“用预提取DNS提高网页载入速度”选项来配置缓存时间。</li>
</ol>
</li>
<li>
<p>减少 cookie头信息的大小，头信息越大，资源传输速度越慢。</p>
</li>
<li>
<p>初始首屏之外的图片资源按需加载，静态资源延迟加载。</p>
</li>
<li>
<p>合并静态资源（减少HTTP请求）</p>
</li>
<li>
<p>减少页面中的元素，网页中的图片,form,flash等元素都会发出http请求，尽量减少页面中非必要元素，可以减少http请求次数。</p>
</li>
<li>
<p>可以把一些图标制作成精灵图样式，使用background-image,background-position属性显示其中一小部分。</p>
</li>
<li>
<p>JS文件和CSS文件只有一个，合并脚本和css文件，减少http请求</p>
</li>
<li>
<p>使用 localstorage缓存和 mainfest 应用缓存</p>
</li>
</ul>
</div>
<div class="hint-container info">
<p class="hint-container-title">webpack</p>
<ul>
<li>压缩文件，开启GZIP。</li>
<li>文件压缩，文件的大小会直接影响浏览器的加载速度，可使用构建工具;webpack,gulp/grunt,rollup等构建工具</li>
<li>删除代码中无用的css，可以借助Uncss工具移除样式表中无用的css</li>
<li>压缩源码和图片（ JavaScript采用混淆压缩，CSS进行普通压缩，JPG图片根据具体质量压缩为50%~70%，把PNG图片从24色压缩成8色以去掉一些PNG格式信息等）。</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>性能优化方法</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Performance/Skill/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Performance/Skill/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">性能优化方法</source>
      <description>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 使得我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM。 但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题， 所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文内容分为以下三部分组成： Vue 代码层面的优化 webpack 配置层面的优化 基础的 Web 技术层面的优化 Vue 代码层面的优化</description>
      <category>性能优化</category>
      <pubDate>Wed, 01 Jun 2022 15:08:30 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分，</p>
<p>使得我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM。</p>
<p>但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，</p>
<p>所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文内容分为以下三部分组成：</p>
<ul>
<li>Vue 代码层面的优化</li>
<li>webpack 配置层面的优化</li>
<li>基础的 Web 技术层面的优化</li>
</ul>
<h2> Vue 代码层面的优化</h2>
<h3> v-if 和 v-show 区分使用场景</h3>
<p>v-if是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>v-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>
<blockquote>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
</blockquote>
<h3> computed 和 watch区分使用场景</h3>
<p>computed：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed的值.</p>
<p>watch：更多是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作.</p>
<blockquote>
<p>运用场景：
当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算.
当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
</blockquote>
<h3> v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h3>
<ol>
<li>v-for 遍历必须为 item 添加 key</li>
</ol>
<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>
<ol start="2">
<li>v-for 遍历避免同时使用 v-if</li>
</ol>
<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>
<p>推荐：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不推荐：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 长列表性能优化</h3>
<p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，
在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 事件的销毁</h3>
<p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 图片资源懒加载</h3>
<p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。
这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p>
<p>安装插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在入口文件 man.js 中引入并使用</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后再 vue 中直接使用</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者添加自定义选项</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。</p>
<h3> 路由懒加载</h3>
<p>Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。
如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p>
<p>路由懒加载：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第三方插件的按需引入</h3>
<p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助babel-plugin-component，然后可以只引入需要的组件，以达到减小项目体积的目的。
以下为项目中引入 element-ui 组件库为例：</p>
<p>首先，安装babel-plugin-component：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，将 .babelrc 修改为：</p>
<div class="language-json5 line-numbers-mode" data-ext="json5"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 main.js 中引入部分组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 优化无限列表性能</h3>
<p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。
你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller来优化这种无限列表的场景的。</p>
<h3> 服务端渲染 SSR or 预渲染</h3>
<p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<ul>
<li>服务端渲染的优点：</li>
</ul>
<p><strong>更好的 SEO</strong> ：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；</p>
<p>而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
<p><strong>更快的内容到达时间（首屏加载更快）</strong>：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</p>
<ul>
<li>服务端渲染的缺点：</li>
</ul>
<p><strong>更多的开发条件限制</strong>：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p>
<p><strong>更多的服务器负载</strong>：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
<p>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。</p>
<p>如果你的 Vue 项目只需改善少数营销页面（例如 /， /about，/contact等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。</p>
<p>优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</p>
]]></content:encoded>
    </item>
    <item>
      <title>二分查找理论</title>
      <link>https://jin-shaohui.gitee.io/Algorithm/Dichotomy/</link>
      <guid>https://jin-shaohui.gitee.io/Algorithm/Dichotomy/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">二分查找理论</source>
      <description>二分查找理论 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用 顺序存储结构 ，而且表中元素按关键字有序排列。 首先，假设表中元素是按升序排列，将表中间位置记录的 关键字 与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置 记录 将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的 记录 ，使查找成功，或直到子表不存在为止，此时查找不成功。 二分查找是我们降低算法复杂度的主要手段之一，只要我们可以题目中存在：</description>
      <category>算法</category>
      <pubDate>Mon, 06 Jun 2022 16:36:20 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 二分查找理论</h2>
<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用 顺序存储结构 ，而且表中元素按关键字有序排列。</p>
<p>首先，假设表中元素是按升序排列，将表中间位置记录的 关键字 与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置 记录  将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的 记录 ，使查找成功，或直到子表不存在为止，此时查找不成功。</p>
<p>二分查找是我们降低算法复杂度的主要手段之一，只要我们可以题目中存在：</p>
<ul>
<li>有序</li>
<li>查找</li>
</ul>
<p>两个因素，就可以用二分查找降低时间复杂度。</p>
<p>在最开始的阶段，二分查找的难点在于识别有序和查找。后面的难点在于如果通过建模手段把题目的数据变得存在有序和查找。</p>
<h2> 方式</h2>
<p>二分查找的精髓就是 3 点：</p>
<ol>
<li>目标值小于查找值时怎么办</li>
<li>目标值等于查找值时怎么办</li>
<li>目标值大于查找值时怎么办</li>
</ol>
<p>二分查找这么看就成为了填空题。</p>
<p>二分查找的作用就是在 Logn 的时间复杂度内找到想要的数据。共有 5 种类型的二分查找方式：</p>
<ul>
<li>数据无重复查找数据</li>
<li>数据有重复查找小于该数的最后一个数字的位置</li>
<li>数据有重复查找该数字第一次出现的位置</li>
<li>数据有重复查找该数字最后一次出现的位置</li>
<li>数据有重复查找第一个大于该数的数字的位置</li>
</ul>
<p>下面针对这五类进行代码介绍。</p>
<h2> 分类</h2>
<h3> 第一类 - 数据无重复查找数据</h3>
<p>位置：0 1 2 3 4 5 6 7 8 9</p>
<p>数据：1 2 3 4 5 6 7 8 9 10</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第二类 - 数据有重复查找小于该数的最后一个数字的位置</h3>
<p>位置：0 1 2 3 4 5 6 7 8 9</p>
<p>数据：1 1 2 2 3 3 3 3 4 4</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第三类 - 数据有重复查找该数字第一次出现的位置</h3>
<p>位置：0 1 2 3 4 5 6 7 8 9</p>
<p>数据：1 1 2 2 3 3 3 3 4 4</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第四类 - 数据有重复查找该数字最后一次出现的位置</h3>
<p>位置：0 1 2 3 4 5 6 7 8 9</p>
<p>数据：1 1 2 2 3 3 3 3 4 4</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 第五类 - 数据有重复查找第一个大于该数的数字的位置</h3>
<p>位置：0 1 2 3 4 5 6 7 8 9</p>
<p>数据：1 1 2 2 3 3 3 3 4 4</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 实战</h2>
<p>题目来自力扣。</p>
<h3> 搜索插入位置</h3>
<p>搜索插入位置</p>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
</div>
<p><code>示例 1</code></p>
<p>输入: nums = [1,3,5,6], target = 5</p>
<p>输出: 2</p>
<p><code>示例 2</code></p>
<p>输入: nums = [1,3,5,6], target = 2</p>
<p>输出: 1</p>
<p><code>示例 3</code></p>
<p>输入: nums = [1,3,5,6], target = 7</p>
<p>输出: 4</p>
<h4> 思路与算法</h4>
<p>假设题意是叫你在排序数组中寻找是否存在一个目标值，那么训练有素的读者肯定立马就能想到利用二分法在 O(\log n)O(logn) 的时间内找到是否存在目标值。但这题还多了个额外的条件，即如果不存在数组中的时候需要返回按顺序插入的位置，那我们还能用二分法么？答案是可以的，我们只需要稍作修改即可。</p>
<p>考虑这个插入的位置 pos，它成立的条件为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中 nums 代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：「在一个有序数组中找第一个大于等于 target 的下标」。</p>
<p>问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 target 的下标 。下文给出的代码是笔者习惯的二分写法，ans 初值设置为数组长度可以省略边界条件的判断，因为存在一种情况是 target 大于数组中的所有数，此时需要插入到数组长度的位置。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 有序数组中的单一元素</h3>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。</p>
<p>请你找出并返回只出现一次的那个数。</p>
<p>你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。</p>
</div>
<p><code>示例 1</code></p>
<p>输入: nums = [1,1,2,3,3,4,4,8,8]</p>
<p>输出: 2</p>
<p><code>示例 2</code></p>
<p>输入: nums = [3,3,7,7,10,11,11]</p>
<p>输出: 10</p>
<h4> 思路与算法</h4>
<p>因为找出唯一一个没有重复的数，且其他相同的数只有两个，所以利用二分查找时，根据 mid 和它的前后来进行判断。</p>
<p>那么怎么知道不重复的在 mid 的左边还是右边呢？</p>
<p>根据 mid 的左侧和右侧个数来判断，因为 mid 指的是下标。</p>
<ul>
<li>
<p>假设 mid 是偶数，则前面有 <code>2 * n</code> 的数，如果 <code>nums[mid] == nums[mid - 1]</code>，则代表左侧必有不重复的数，因为前面原本有 <code>2 * n</code> 的数，则假设正好存在 <code>n / 2</code> 个重复的数，但是显然 <code>nums[mid] == nums[mid - 1]</code>，所以左侧必有唯一的数。（0 - mid 之间不取 mid 是偶数，取了 mid 则是奇数，奇数之间肯定有一个唯一的数）</p>
</li>
<li>
<p>假设 mid 是奇数，则前面有 <code>2 * n - 1</code> 个数，如果 <code>nums[mid] == nums[mid - 1]</code>，则代表右侧的必有不重复的数，因为前面原本有 <code>2 * n - 1</code> 的数，则假设正好存在 2 个重复的数 + 一个不重复的数，但是显然 <code>nums[mid] == nums[mid - 1]</code>，所以右侧必有唯一的数。（0 - mid 之间不取 mid 是奇数，取了 mid 则是偶数，偶数之间不存在唯一的数，所以只有右侧有）</p>
</li>
<li>
<p><code>nums[mid] == nums[mid + 1]</code> 同理 ......</p>
</li>
</ul>
<p>如果最终 <code>mid</code> 是 <code>0</code> 或者 <code>nums.length - 1</code>，则 <code>0</code> 或者 <code>nums.length - 1</code> 就是唯一数的下标。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>动态规划算法</title>
      <link>https://jin-shaohui.gitee.io/Algorithm/DynamicProgram/</link>
      <guid>https://jin-shaohui.gitee.io/Algorithm/DynamicProgram/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">动态规划算法</source>
      <description>算法认识 动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。 动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</description>
      <category>算法</category>
      <pubDate>Mon, 06 Jun 2022 16:38:19 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 算法认识</h2>
<p>动态规划（Dynamic Programming）简称 DP，对于子问题重叠的情况特别有效，因为它将子问题的解保存在表格中，当需要某个子问题的解时，直接取值即可，从而避免重复计算。</p>
<p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p>
<p>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</p>
<p>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。</p>
<p>所以动态规划实际上是将问题分化成很多的子问题，然后将当前子问题计算过的最优结果存储起来，当另一个子问题也打算求该结果时，直接返回即可，因为已经是最优解。</p>
<p>动态规划的题目分为两大类，一种是求最优解类，典型问题是背包问题，另一种就是计数类，它们都存在一定的递推性质。前者的递推性质还有一个名字，叫做 「最优子结构」 ——即当前问题的最优解取决于子问题的最优解，后者类似，当前问题的方案数取决于子问题的方案数。所以在遇到求方案数的问题时，我们可以往动态规划的方向考虑。</p>
<h2> 算法性质</h2>
<p>动态规划有很多的「高大上」的术语和性质，这些性质也是算法需要考虑的步骤。</p>
<h3> 子问题重叠</h3>
<p>子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。</p>
<p>也就是在求解的过程中，许多子问题的解被反复地使用。为了避免重复计算，动态规划算法采用了填表来保存子问题解。</p>
<h3> 状态转移方程</h3>
<p><strong>动态规划最难的就是求解出状态转移方程</strong>，就类似于递推的公式，如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>f(n)</code> 由 <code>f(n - 1)</code> 和 <code>f(n - 2)</code> 不断转移，直至 n 才得到结果，这就是状态转移方程。</p>
<h3> 最优子结构</h3>
<p>如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。</p>
<p>原问题的解是由多个子问题的最优解构成，比如说，原问题是考出最高的总成绩，那么子问题就是要把语文考到最高，数学考到最高等，为了每门课考到最高，要把每门课相应的选择题分数拿到最高，填空题分数拿到最高等等，当然，最终就是每门课都是满分，这就是最高的总成绩。所以得到了最后正确的结果：最高的总成绩就是总分。</p>
<h3> 无后效性</h3>
<p>即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>如 A -&gt; B -&gt; C，那么 B 和 C 的结果不会影响 A，同理 C 不会影响 B，但是 A 能影响 B 和 C，毕竟 B 和 C 是通过 A 的结果来算出。</p>
<h3> 自底向上</h3>
<p>动态规划的特点就是从最底部（0 或者 1）蔓延到上面（n），假设存在长度 n，我们知道递归是从 n 到 n - 1 往下遍历，直至到 1，这叫 <strong>自顶向下</strong>。而动态规划是 <strong>自底向上</strong>，也就是从 1 到 2 往上遍历，直至到 n。</p>
<p>因为动态规划是自底向上，所以我们在求解的时候需要由一些原始条件，如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样才有具体的值来自底向上：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 步骤实战</h2>
<p>动态规划遵循一套固定的流程：<strong>递归的暴力解法</strong> -&gt; <strong>带备忘录的递归解法</strong> -&gt; <strong>非递归的动态规划解法</strong>。这个过程是层层递进的解决问题的过程，如果没有前面的铺垫，直接看最终的非递归的动态规划解法，会难理解。</p>
<h3> 斐波那契式子</h3>
<p>斐波那契式子为：<code>F(0) = 0，F(1) = 1, F(n) = F(n - 1) + F(n - 2)</code>。</p>
<h4> 暴力的递归算法</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要想计算原问题 f(20)，就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，依次类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果。</p>
<p>子问题个数为 O(2^n)，所以这个算法的时间复杂度为 O(2^n)，效率很低。</p>
<p>这就是我们需要解决动态规划问题的第一个性质：<strong>重叠子问题</strong></p>
<h4> 带备忘录的递归解法</h4>
<p>即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；后面每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>「备忘录」可以是数组，也可以是哈希表，key 为子问题的唯一标识，value 就是解决后的结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p>
<p>子问题个数为 O(n)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，效率大幅度提升很多。</p>
<p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<h4> 动态规划</h4>
<p>有「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，叫做 dp，在这张表上完成「自底向上」的推算。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>dp[i] = dp[i - 1] + dp[i - 2];</code> 就是 <strong>状态转移方程</strong>，它是解决问题的核心。我们也很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p><strong>动态规划问题最困难的就是写出状态转移方程</strong>。</p>
<blockquote>
<p>动态规划优化</p>
</blockquote>
<p>根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 dp 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 硬币凑钱</h3>
<p>给 k 种面值的硬币，面值分别为 c1，c2，...，ck，再给一个总金额 n，问最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1 。</p>
<p>比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 <code>11 = 5 + 5 + 1</code>。</p>
<h4> 暴力的递归算法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总时间复杂度为 O(k*n^k)。</p>
<h4> 带备忘录的递归算法</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 动态规划</h4>
<p>如果我们有面值为 1 元、3 元和 5 元的硬币若干枚，如何用最少的硬币凑够 11 元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如 1 元换成 2 元的时候)</p>
<p>如何用最少的硬币凑够i元（i &lt; 11）？ 两个原因：</p>
<ul>
<li>当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论</li>
<li>这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题（规模变小后的问题其实是原问题的子问题）</li>
</ul>
<p>当 i = 0，即需要多少个硬币来凑够 0 元。 由于 1，3，5 都大于 0，即没有比 0 小的币值，因此凑够 0 元最少需要 0 个硬币。这时候可以用一个 <strong>标记</strong> 来表示「凑够 0 元最少需要 0 个硬币」。</p>
<p>那么， 我们用 <code>d(i) = j</code> 来表示凑够 i 元最少需要 j 个硬币。于是我们已经得到了 <code>d(0) = 0</code>，表示凑够 0 元最小需要 0 个硬币。</p>
<p>当 i = 1 时，只有面值为 1 元的硬币可用，因此我们拿起一个面值为 1 的硬币，接下来只需要凑够 0 元即可，即 <code>d(0) = 0</code>。所以有：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 i = 2 时，仍然只有面值为 1 的硬币可用，于是我拿起一个面值为 1 的硬币，接下来我只需要再凑够 2 - 1 = 1 元即可， 所以有：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 i = 3 时，我们能用的硬币就有两种了：1 元和 3 元。既然能用的硬币有两种，于是就有两种方案。如果我拿了一个 1 元的硬币，我的目标就变为了： 凑够 3 - 1 = 2 元需要的最少硬币数量。即</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方案说的是，我拿 3 个 1 元的硬币；第二种方案是我拿起一个 3 元的硬币，我的目标就变成：凑够 3 - 3 = 0元需要的最少硬币数量。即</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个方案说的是，我拿 1 个 3 元的硬币。</p>
<p>这两种方案哪种更优呢？题目要求使用用最少的硬币数量来凑够 3 元的。所以，选择 <code>d(3) = 1</code>，所以我们得到了 <strong>转移状态方程</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>从以上的文字中， 我们要得到动态规划里非常重要的两个概念：<strong>状态</strong> 和 <strong>状态转移方程</strong>。</p>
<p>上文中 d(i) 表示凑够 i 元需要的最少硬币数量，我们将它定义为该问题的 <strong>状态</strong>， 这个状态是怎么找出来的呢？要根据子问题定义状态，找到子问题，状态也就浮出水面了。最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够 11 元最少需要多少个硬币。</p>
<p>那状态转移方程是什么呢？既然我们用 d(i) 表示状态，那么状态转移方程应该包含了状态 d(i)，上文中包含状态 d(i) 的方程是：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>于是它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以最终代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 例题实战</h2>
<h3> 爬楼梯</h3>
<p>下面介绍先通过典型的动态规划题目总结 <strong>计算步骤</strong>，然后利用计算步骤完成动态规划的题目。</p>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>如 n = 2 时，有两种方法，分别是：</p>
<ul>
<li>1 阶 + 1 阶</li>
<li>直接 2 阶</li>
</ul>
<p>如 n = 3，有三种方法，分别是：</p>
<ul>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ul>
<h4> 计算步骤</h4>
<ul>
<li><strong>特例确定</strong>，也就是「剪枝」，判断满足某些条件，直接返回，不需要计算，一般针对起始位置或末尾位置</li>
<li><strong>状态定义</strong>：定义状态的空间位置，确保动态规划有足够的空间存放子问题的解，如下题 f[i] 代表走过 i 阶需要的总方法</li>
<li><strong>初始状态</strong>，动态规划自底向上，所以底部（0 或者 1）至少要有一个已知的值，然后慢慢推到后面的值</li>
<li><strong>状态转移方程</strong>，动态规划最难的就是求解出状态转移方程，这是一种递推规律的公式</li>
<li><strong>返回值</strong>：确定最终的返回值</li>
</ul>
<h4> 简单动态规划</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 优化动态规划</h4>
<p>因为我们只需要 3 中状态，也就是只需要 3 种子问题的解，即 n、n - 1、n - 2，其他的不需要，所以就利用变量来替换</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 最小路径和</h3>
<p>题目来自 <code>https://leetcode-cn.com/problems/minimum-path-sum/</code></p>
<p>解题思路参考：<code>https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-dong-tai-gui-hua-gui-fan-liu-c/</code></p>
<p><code>题目</code></p>
<ul>
<li>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小</li>
<li><strong>说明</strong>：每次只能向下或者向右移动一步</li>
</ul>
<p>示例 1：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此题是典型的动态规划题目。</p>
<p>下面按动态规划的步骤进行计算：</p>
<p><code>特例确定</code></p>
<p>如果 DP 长度为 0，返回 0。</p>
<p><code>状态定义</code></p>
<p>设 DP 为大小 <code>m x n</code> 矩阵，其中 <code>dp[i][j]</code> 的值代表直到走到 (i,j) 的最小路径和。</p>
<p><code>初始状态</code></p>
<p>DP 初始化即可，不需要赋初始值。</p>
<p><code>状态转移方程</code></p>
<p>题目要求，只能向右或向下走，换句话说，当前单元格 (i, j) 只能从左方单元格 (i−1, j) 或上方单元格 (i, j−1) 走到，因此只需要考虑矩阵左边界和上边界。</p>
<p>走到当前单元格 (i, j) 的最小路径和 =「从左方单元格 (i-1, j) 与从上方单元格 (i, j−1) 走来的两个最小路径和中较小的」 + 当前单元格值 <code>dp[i][j]</code> 。具体分为以下 3 种情况：</p>
<ul>
<li>矩阵的第一列进行求和，然后覆盖原来的值。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>矩阵的第一行进行求和，然后覆盖原来的值。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><strong>当左边和上边都不是矩阵边界时</strong>： 即当 i、j 不等于 0 时，有</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>返回值</code></p>
<p>返回 DP 矩阵右下角值，即走到终点的最小路径和。</p>
<p><code>复杂度分析</code></p>
<p>时间复杂度 O(M x N)：遍历整个 grid 矩阵元素。</p>
<p>空间复杂度 O(1)：直接修改原矩阵，不使用额外空间。</p>
<p>grid 代表 DP</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 不同路径</h3>
<p>题目来自：<code>https://leetcode-cn.com/problems/unique-paths/</code></p>
<p><code>题目</code></p>
<ul>
<li>一个机器人位于一个 m x n 网格的左上角</li>
<li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，即 m x n 的终点（对角线的末尾）</li>
<li>问总共有多少条不同的路径？</li>
</ul>
<p>下面按动态规划的步骤进行计算：</p>
<p><code>特例确定</code></p>
<p>无特例。</p>
<p><code>初始状态</code></p>
<p>DP 初始化即可，不需要赋初始值。</p>
<p><code>状态定义</code></p>
<p>设 m x n 矩阵有 <code>dp[i][j]</code>，其中 i 代表矩阵的第 i 行，j 代表第 j 列。</p>
<p><code>状态转移方程</code></p>
<p>规律：</p>
<ul>
<li>如果位置处于第一行或者第一列，则总路径 = 1</li>
<li>不在第一行或者第一列，则某个位置的总路径 = 它上面位置的总路径 + 它左侧位置的总路径</li>
</ul>
<p>状态转移方程为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>返回值</code></p>
<p>返回 DP 矩阵右下角值，即走到终点的总路径和。</p>
<p><code>复杂度分析</code></p>
<p>时间复杂度 O(m x n)：遍历整个 DP 矩阵元素。</p>
<p>空间复杂度 O(n)：直接修改原矩阵，不使用额外空间。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 适用场景</h2>
<p>适合用动态规划来解决的问题，都具有下面三个特点：最优化原理、最优化原理、有重叠子问题。</p>
<p>如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。某阶段状态（定义的新子问题）一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与其以前的状态有关。子问题之间是不独立的（分治法是独立的），一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）。</p>
<h2> 算法局限</h2>
<p>动态规划对于解决多阶段决策问题的效果是明显的，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是「维数障碍」。</p>
<p>动态规划大部分都是 <strong>空间换时间</strong>，因为动态规划需要一个 DP 来存已经计算的子问题的解，所以需要利用大量的空间来存解值，但是在时间上就很快找出该解值，不需要重新求解值。</p>
]]></content:encoded>
    </item>
    <item>
      <title>优先遍历算法</title>
      <link>https://jin-shaohui.gitee.io/Algorithm/PriorityTraversal/</link>
      <guid>https://jin-shaohui.gitee.io/Algorithm/PriorityTraversal/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">优先遍历算法</source>
      <description>深度优先遍历 深度优先遍历（Depth First Search，简称 DFS）就是找准一条路不停深入的搜索方法， 当发现这条路走不通的时候就会回退到上一个探索的节点，如果上一个节点存在没有探索的分支，便继续探索若没有则继续回退。 深度优先遍历就有点像二叉树中的前序遍历、中序遍历和后序遍历。 它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。 深度优先遍历的关键就在于如何找到已经探索过节点的上一个节点，也就是如何回溯。</description>
      <category>算法</category>
      <pubDate>Fri, 24 Jun 2022 14:38:26 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 深度优先遍历</h2>
<p>深度优先遍历（Depth First Search，简称 DFS）就是找准一条路不停深入的搜索方法，
当发现这条路走不通的时候就会回退到上一个探索的节点，如果上一个节点存在没有探索的分支，便继续探索若没有则继续回退。
深度优先遍历就有点像二叉树中的前序遍历、中序遍历和后序遍历。</p>
<p>它的特点是不撞南墙不回头，先走完一条路，再换一条路继续走。</p>
<p>深度优先遍历的关键就在于如何找到已经探索过节点的上一个节点，也就是如何回溯。</p>
<!-- more -->

<ul>
<li>从根节点 1 开始遍历，它相邻的节点有 2，3，4，先遍历节点 2，再遍历 2 的子节点 5，然后再遍历 5 的子节点 9</li>
<li>此时 2 以及下面的节点遍历完后，回到根节点 1，继续遍历 3，6，10，7</li>
<li>此时 3 以及下面的节点遍历完后，回到根节点 1，继续遍历 4，8</li>
<li>完整的遍历顺序图如下：</li>
</ul>

<p>另一个利用栈的动图描述：</p>

<h3> 递归实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 迭代实现</h3>
<p>根据深度优先算法的特性，可以使用栈先入后出的特性实现。</p>
<p>将探索过的点存入栈内，遇到走不通的时候将栈顶元素出栈回到上一个元素，实现回溯</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不难发现，上面的图这就是树的前序遍历，实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。</p>
<p>详细关于 DFS 的前序遍历、中序遍历、后序遍历的讲解，请看 二叉树遍历。</p>
<h2> 广度优先遍历</h2>
<p>广度优先遍历（Breath First Search，简称 BFS）一层一层遍历，每一层得到的所有新节点，要用队列存储起来以备下一层遍历的时候再遍历。</p>

<p>可以看出，遍历的顺序先是 2，3，4，接着是 5，6，7，8，最后是 9，10。属于一层一层遍历。</p>
<p>另一个利用队列的动图描述：</p>

<p>深度优先遍历用的是栈，而广度优先遍历要用队列来实现。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>简而言之</title>
      <link>https://jin-shaohui.gitee.io/DesignPattern/Info/</link>
      <guid>https://jin-shaohui.gitee.io/DesignPattern/Info/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">简而言之</source>
      <description>设计模式是什么？ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 大白话就是，在合适的场景使用合适的设计模式： 代码比较稳定 代码比较高效 代码维护性强 代码比较规范 工厂模式</description>
      <category>设计模式</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 设计模式是什么？</h3>
<p>设计模式（Design pattern）代表了<code>最佳的实践</code>，通常被有经验的面向对象的软件开发人员所采用。</p>
<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>
<p>大白话就是，在<code>合适的场景</code>使用<code>合适的设计模式</code>：</p>
<ul>
<li>代码比较稳定</li>
<li>代码比较高效</li>
<li>代码维护性强</li>
<li>代码比较规范</li>
</ul>
<h3> 工厂模式</h3>
<p>工厂模式通俗点说就是：<code>更方便地去创建实例</code></p>
<p>大家开发中应该使用过 <strong>axios.create()</strong> 这个方法吧？这其实就是工厂模式的实践之一</p>
<p>简单分析一下 <strong>axios.create()</strong> 的原理（不一定跟源码一模一样）</p>
<p><strong>axios.create()</strong> 每次返回的都是一个全新的实例~</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这就是工厂模式~</p>
</blockquote>
<h3> 单例模式</h3>
<p>单例模式通俗点说就是：<code>定义一个类，生成一个实例，并且整个项目仅此这一个实例</code></p>
<p>相信大家在项目中都封装使用过<code>Axios</code>吧</p>
<p>我们会先定义封装一个请求的实例然后暴露出去</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后在项目中各处去使用这一个请求实例</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这就是单例模式~</p>
</blockquote>
<h3> 策略模式</h3>
<p>策略模式通俗点说就是：<code>根据不同的策略去做不同的事情</code></p>
<p>比如我需要根据不同的年龄去做不同的处理</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但其实这样做有很多坏处：</p>
<ul>
<li>可读性一般（实际代码比这更复杂）</li>
<li>可维护性差，如果以后多一种<strong>age</strong>判断，又要修改这个<strong>doSomething</strong>函数，规范的话是<code>不建议</code>去过多修改函数本身的</li>
<li>可拓展性差，多一种age判断只能修改原函数体</li>
</ul>
<p>所以我们可以这么做</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这就是策略模式模式~</p>
</blockquote>
<h3> 适配器模式</h3>
<p>适配器模式通俗点说就是：<code>将一种格式适配成你所需要的格式</code></p>
<p>比如有一个场景：后端给你返回了三种数据格式，但是你需要把这三种格式转成你前端所需要的格式</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个时候你需要定义几个适配器类</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当你需要转换成你需要的数据时，调用这些类就行</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这就是适配器模式模式~</p>
<h3> 装饰器模式</h3>
<p>装饰器模式通俗点说就是：<code>定义一个类，在不改这个类的前提下，给这个类拓展功能</code></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这就是装饰器模式~</p>
</blockquote>
<h3> 代理模式</h3>
<p>代理模式通俗易懂点说就是：<code>为对象提供一种代理，便以控制对这个对象的访问，不能直接访问目标对象</code></p>
<p>最好的实践场景就是ES6 Proxy</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这就是代理模式~</p>
</blockquote>
<h1> 观察者模式</h1>
<p>观察者模式通俗点讲就是：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>
<p>我们平时使用的框架Vue，它的响应式就是基于观察者模式去做的，下面是简单展示一下它的原理</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>这就是观察者模式~</p>
</blockquote>
<h3> 发布订阅模式</h3>
<p><code>发布订阅模式</code>跟<code>观察者模式</code>很像，他们其实都有<code>发布者</code>和<code>订阅者</code>，但是他们是有区别的</p>
<p>-观察者模式的<code>发布</code>和<code>订阅</code>是<code>互相依赖</code>的
-发布订阅模式的<code>发布</code>和<code>订阅</code>是<code>不互相依赖</code>的，因为有一个<code>统一调度中心</code></p>
<p>为了更好区分这两种设计模式，我举一个现实中的生活例子吧！</p>
<p><strong>例子一：</strong> A想转手一部手机，B想买，于是两个人互加联系方式，B买了手机后，每次有手机系统更新时，都需要A去联系B进行升级教学</p>
<p><strong>例子二：</strong> A想转手一部手机，所以挂在了某平台转卖，B在平台看到手机并买下，每次有手机系统更新时，A只需要跟平台反馈并提供升级教程，平台自然会通知B进行升级教学</p>
<p>我们<code>Vue EventBus</code>就是用了<code>发布订阅模式</code></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>观察者模式</title>
      <link>https://jin-shaohui.gitee.io/DesignPattern/Observer/</link>
      <guid>https://jin-shaohui.gitee.io/DesignPattern/Observer/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">观察者模式</source>
      <description>观察者模式 我们学习vue的时候，经常会遇到消息通信，但大部分组件不是父子关系，就是兄弟关系。 那如果两个没有任何关系的组件，既要进行消息通信，要保证通信不丢失，那么这时候 观察者模式（发布-订阅模式） 就很好用了。 发布-订阅 发布：数据推送方，如：组件A想获取组件B数据，组件B抛出组件A需要的数据 订阅：提出诉求方，如：组件A想获取组件B数据，抛出了个接收数据的&amp;apos;getData&amp;apos;方法 代码编写 首先我们要定义一个观察者（数据处理中心），用来存储事件和回调函数信息。</description>
      <category>设计模式</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 观察者模式</h1>
<p>我们学习vue的时候，经常会遇到消息通信，但大部分组件不是父子关系，就是兄弟关系。
那如果两个没有任何关系的组件，既要进行消息通信，要保证通信不丢失，那么这时候 <strong>观察者模式（发布-订阅模式）</strong> 就很好用了。</p>
<h2> 发布-订阅</h2>
<blockquote>
<p>发布：数据推送方，如：组件A想获取组件B数据，组件B抛出组件A需要的数据</p>
<p>订阅：提出诉求方，如：组件A想获取组件B数据，抛出了个接收数据的'getData'方法</p>
</blockquote>
<h2> 代码编写</h2>
<ul>
<li>首先我们要定义一个观察者（数据处理中心），用来存储事件和回调函数信息。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>其次我们要定义一个发布的函数，当然，为了防止发布者比订阅者提早生成，将发布内容存储于 <strong>caches</strong>，使订阅者生成后直接发布。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>然后我们要定义一个订阅的函数，当发布者比订阅者提早生成时，要先将caches中存有的发布数据发布出去，再存入观察者中。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>最后，当页面销毁的时候，我们就需要定义一个销毁订阅的方法。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 实际应用</h2>
<p>首先我们使用vue-cli直接 <strong>vue create demo</strong> 创建应用，
在app.vue中引入两个组件 comp1 以及 comp2， 代码如下：</p>
<ul>
<li>comp1.vue</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>comp2.vue</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>最后的结果是：</li>
</ul>

]]></content:encoded>
    </item>
    <item>
      <title>Git</title>
      <link>https://jin-shaohui.gitee.io/Git/</link>
      <guid>https://jin-shaohui.gitee.io/Git/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Git</source>
      <description>前言 作为当前世界上最强大的代码管理工具Git相信大家都很熟悉， 但据我所知有很大一批人停留在clone、commit、pull、push...的阶段， 是不是对rebase心里没底只敢用merge？碰见版本回退就抓瞎？ 别问我怎么知道的，问就是：“我曾经就是这样啊～～”。针对这些问题， 今天我就将这几年对Git的认知和理解分享出来，尽可能的从本质去讲解Git， 帮助你一步一步去了解Git的底层原理，相信读完本篇文章你便可以换种姿态， 更加风骚得使用Git各种指令。 基本概念 Git的优势 Git是一个分布式代码管理工具，在讨论分布式之前避免不了提及一下什么是中央式代码管理仓库</description>
      <category>Git</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p>作为当前世界上最强大的代码管理工具Git相信大家都很熟悉，
但据我所知有很大一批人停留在clone、commit、pull、push...的阶段，
是不是对rebase心里没底只敢用merge？碰见版本回退就抓瞎？
别问我怎么知道的，问就是：“我曾经就是这样啊～～”。针对这些问题，
今天我就将这几年对Git的认知和理解分享出来，尽可能的从本质去讲解Git，
帮助你一步一步去了解Git的底层原理，相信读完本篇文章你便可以换种姿态，
更加风骚得使用Git各种指令。</p>
<h2> 基本概念</h2>
<ul>
<li>Git的优势
Git是一个分布式代码管理工具，在讨论分布式之前避免不了提及一下什么是中央式代码管理仓库</li>
</ul>
<blockquote>
<p>中央式：所有的代码保存在中央服务器，所以提交必须依赖网络，并且每次提交都会带入到中央仓库，如果是协同开发可能频繁触发代码合并，进而增加提交的成本和代价。最典型的就是svn
分布式：可以在本地提交，不需要依赖网络，并且会将每次提交自动备份到本地。每个开发者都可以把远程仓库clone一份到本地，并会把提交历史一并拿过来。代表就是Git</p>
</blockquote>
<p>那Git相比于svn有什么优势呢？打个比方："巴拉巴拉写了一大堆代码，突然发现写的有问题，我想回到一个小时之前"，对于这种情况Git的优势就很明显了，因为commit的成本比较小并且本地会保存所有的提交记录，随时随刻可以进行回退。在这并不是说svn的不能完成这种操作，只是Git的回退会显得更加的优雅。Git相比于中央式工具还有很多优点，就不一一列举了，感兴趣的可自行了解。</p>
<ul>
<li>文件状态</li>
</ul>
<p>在Git中文件大概分为三种状态：已修改（modified）、已暂存（staged）、已提交（committed）</p>
<p>修改：Git可以感知到工作目录中哪些文件被修改了，然后把修改的文件加入到modified区域</p>
<p>暂存：通过add命令将工作目录中修改的文件提交到暂存区，等候被commit</p>
<p>提交：将暂存区文件commit至Git目录中永久保存</p>
<ul>
<li>commit节点</li>
</ul>
<p>在Git中每次提交都会生成一个节点,而每个节点都会有一个哈希值作为唯一标示，多次提交会形成一个线性节点链（不考虑merge的情况），如图</p>

<blockquote>
<p>节点上方是通过 SHA1计算的哈希值</p>
</blockquote>
<ul>
<li>HEAD</li>
</ul>
<p>HEAD是Git中非常重要的一个概念，你可以称它为指针或者引用，它可以指向任意一个节点，并且指向的节点始终为当前工作目录，换句话说就是当前工作目录(也就是你所看到的代码)就是HEAD指向的节点。</p>
<p>还以图1-1举例，如果HEAD指向C2那工作目录对应的就是C2节点。具体如何移动HEAD指向后面会讲到，此处不要纠结。</p>
<p>同时HEAD也可以指向一个分支，间接指向分支所指向的节点</p>
<p>1.5 远程仓库</p>
<p>虽然Git会把代码以及历史保存在本地，但最终还是要提交到服务器上的远程仓库。通过clone命令可以把远程仓库的代码下载到本地，同时也会将提交历史、分支、HEAD等状态一并同步到本地，但这些状态并不会实时更新，需要手动从远程仓库去拉取，至于何时拉、怎么拉后面章节会讲到。</p>
<p>通过远程仓库为中介，你可以和你的同事进行协同开发，开发完新功能后可以申请提交至远程仓库，同时也可以从远程仓库拉取你同事的代码。</p>
<p>注意点</p>
<p>因为你和你的同事都会以远程仓库的代码为基准，所以要时刻保证远程仓库的代码质量，切记不要将未经检验测试的代码提交至远程仓库</p>
<h2> 分支</h2>
<ul>
<li>什么是分支？</li>
</ul>
<p>分支也是Git中相当重要的一个概念，当一个分支指向一个节点时，当前节点的内容即是该分支的内容，它的概念和HEAD非常接近同样也可以视为指针或引用，不同的是分支可以存在多个，而HEAD只有一个。通常会根据功能或版本建立不同的分支</p>
<p>那分支有什么用呢？</p>
<blockquote>
<p>举个例子：你们的 App 经历了千辛万苦终于发布了v1.0版本，由于需求紧急v1.0上线之后便马不停蹄的开始v1.1，正当你开发的兴起时，QA同学说用户反馈了一些bug，需要修复然后重新发版，修复v1.0肯定要基于v1.0的代码，可是你已经开发了一部分v1.1了，此时怎么搞？</p>
</blockquote>
<p>面对上面的问题通过引入分支概念便可优雅的解决，如图</p>

<blockquote>
<p>先看左边示意图，假设C2节点既是v1.0版本代码，上线后在C2的基础上新建一个分支ft-1.0</p>
<p>再看右边示意图，在v1.0上线后可在master分支开发v1.1内容，收到QA同学反馈后提交v1.1代码生成节点C3，随后切换到ft-1.0分支做bug修复，修复完成后提交代码生成节点C4，然后再切换到master分支并合并ft-1.0分支，到此我们就解决了上面提出的问题</p>
</blockquote>
<p>除此之外利用分支还可以做很多事情，比如现在有一个需求不确定要不要上线，但是得先做，此时可以单独创建一个分支开发该功能，等到啥时候需要上线直接合并到主分支即可。分支适用的场景很多就不一一列举了。</p>
<p>注意点</p>
<blockquote>
<p>当在某个节点创建一个分支后，并不会把该节点对应的代码复制一份出来，只是将新分支指向该节点，因此可以很大程度减少空间上的开销。一定要记着不管是HEAD还是分支它们都只是引用而已，量级非常轻</p>
</blockquote>
<h2> 命令详解</h2>
<h3> 提交相关</h3>
<p>前面我们提到过，想要对代码进行提交必须得先加入到暂存区，Git中是通过命令 add 实现</p>
<h4> 添加某个文件到暂存区</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 添加所有文件到暂存区</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同时Git也提供了撤销<strong>工作区</strong>和<strong>暂存区</strong>命令</p>
<h4> 撤销工作区改动</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 清空暂存区</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 提交</h4>
<p>将改动文件加入到暂存区后就可以进行提交了，提交后会生成一个新的提交节点，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 分支相关</h3>
<h4> 创建分支</h4>
<p>创建一个分支后该分支会与HEAD指向同一节点，说通俗点就是HEAD指向哪创建的新分支就指向哪，命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 切换分支</h4>
<p>当切换分支后，默认情况下HEAD会指向当前分支，即HEAD间接指向当前分支指向的节点</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同时也可以创建一个分支后立即切换，命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 删除分支</h4>
<p>为了保证仓库分支的简洁，当某个分支完成了它的使命后应该被删除。比如前面所说的单独开一个分支完成某个功能，当这个功能被合并到主分支后应该将这个分支及时删除。</p>
<p>删除命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 合并相关</h3>
<p>关于合并的命令是最难掌握同时也是最重要的。我们常用的合并命令大概有三个merge、rebase、cherry-pick</p>
<h4> 合并 merge</h4>
<p>merge是最常用的合并命令，它可以将某个分支或者某个节点的代码合并至当前分支。具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果需要合并的分支完全领先于当前分支，如图所示</p>

<p>由于分支ft-1完全领先分支ft-2即ft-1完全包含ft-2，所以ft-2执行了“git merge ft-1”后会触发fast forward(快速合并)，此时两个分支指向同一节点，这是最理想的状态。但是实际开发中我们往往碰到是是下面这种情况：如图3-2(左)</p>

<p>这种情况就不能直接合了，当ft-2执行了“git merge ft-1”后Git会将节点C3、C4合并随后生成一个新节点C5，最后将ft-2指向C5 如图</p>
<p>注意点：</p>
<blockquote>
<p>如果C3、C4同时修改了同一个文件中的同一句代码，这个时候合并会出错，因为Git不知道该以哪个节点为标准，所以这个时候需要我们自己手动合并代码</p>
</blockquote>
<h4> 变基 rebase</h4>
<p>rebase也是一种合并指令，命令行如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>与merge不同的是rebase合并看起来不会产生新的节点(实际上是会产生的，只是做了一次复制)，而是将需要合并的节点直接累加 如图</p>

<p>当左边示意图的ft-1.0执行了git rebase master后会将C4节点复制一份到C3后面，也就是C4'，C4与C4'相对应，但是哈希值却不一样。</p>
<p>rebase相比于merge提交历史更加线性、干净，使并行的开发流程看起来像串行，更符合我们的直觉。既然rebase这么好用是不是可以抛弃merge了？其实也不是了，下面我罗列一些merge和rebase的优缺点：</p>
<ul>
<li>merge优缺点：</li>
</ul>
<blockquote>
<p>优点：每个节点都是严格按照时间排列。当合并发生冲突时，只需要解决两个分支所指向的节点的冲突即可</p>
<p>缺点：合并两个分支时大概率会生成新的节点并分叉，久而久之提交历史会变成一团乱麻</p>
</blockquote>
<ul>
<li>rebase优缺点：</li>
</ul>
<blockquote>
<p>优点：会使提交历史看起来更加线性、干净</p>
<p>缺点：虽然提交看起来像是线性的，但并不是真正的按时间排序，比如上图中，不管C4早于或者晚于C3提交它最终都会放在C3后面。并且当合并发生冲突时，理论上来讲有几个节点rebase到目标分支就可能处理几次冲突</p>
</blockquote>
<p>对于网络上一些只用rebase的观点，作者表示不太认同，如果不同分支的合并使用rebase可能需要重复解决冲突，这样就得不偿失了。但如果是本地推到远程并对应的是同一条分支可以优先考虑rebase。所以我的观点是 根据不同场景合理搭配使用merge和rebase，如果觉得都行那优先使用rebase</p>
<h4> 筛选合并 cherry-pick</h4>
<p>cherry-pick的合并不同于merge和rebase，它可以选择某几个节点进行合并，如图</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>
<p>假设当前分支是master，执行了git cherry-pick C3(哈希值)，C4(哈希值)命令后会直接将C3、C4节点抓过来放在后面，对应C3'和C4'</p>
<h3> 回退相关</h3>
<h4> 分离HEAD</h4>
<p>在默认情况下HEAD是指向分支的，但也可以将HEAD从分支上取下来直接指向某个节点，此过程就是分离HEAD，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于哈希值是一串很长很长的乱码，在实际操作中使用哈希值分离HEAD很麻烦，所以Git也提供了HEAD基于某一特殊位置(分支/HEAD)直接指向前一个或前N个节点的命令，也即相对引用，如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将HEAD分离出来指向节点有什么用呢？举个例子：如果开发过程发现之前的提交有问题，此时可以将HEAD指向对应的节点，修改完毕后再提交，此时你肯定不希望再生成一个新的节点，而你只需在提交时加上--amend即可，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 回退</h4>
<p>回退场景在平时开发中还是比较常见的，比如你巴拉巴拉写了一大堆代码然后提交，后面发现写的有问题，于是你想将代码回到前一个提交，这种场景可以通过reset解决，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>reset和相对引用很像，区别是reset会使分支和HEAD一并回退。</p>
<h3> 远程相关</h3>
<p>当我们接触一个新项目时，第一件事情肯定是要把它的代码拿下来，在Git中可以通过clone从远程仓库复制一份代码到本地，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>前面的章节我也有提到过，clone不仅仅是复制代码，它还会把远程仓库的引用(分支/HEAD)一并取下保存在本地，如图所示：</p>

<p>其中origin/master和origin/ft-1为远程仓库的分支，而远程的这些引用状态是不会实时更新到本地的，比如远程仓库origin/master分支增加了一次提交，此时本地是感知不到的，所以本地的origin/master分支依旧指向C4节点。我们可以通过fetch命令来手动更新远程仓库状态</p>
<p>小提示：</p>
<blockquote>
<p>并不是存在服务器上的才能称作是远程仓库，你也可以clone本地仓库作为远程，当然实际开发中我们不可能把本地仓库当作公有仓库，说这个只是单纯的帮助你更清晰的理解分布式</p>
</blockquote>
<h4> 下载 fetch</h4>
<p>说的通俗一点，fetch命令就是一次下载操作，它会将远程新增加的节点以及引用(分支/HEAD)的状态下载到本地，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 拉取 pull</h4>
<p>pull命令可以从远程仓库的某个引用拉取代码，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其实pull的本质就是fetch+merge，首先更新远程仓库所有状态到本地，随后再进行合并。合并完成后本地分支会指向最新节点</p>
<p>另外pull命令也可以通过rebase进行合并，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 推送 push</h4>
<p>push命令可以将本地提交推送至远程，具体命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果直接push可能会失败，因为可能存在冲突，所以在push之前往往会先pull一下，如果存在冲突本地解决。push成功后本地的远程分支引用会更新，与本地分支指向同一节点</p>
<h2> 综上所述</h2>
<ul>
<li>不管是HEAD还是分支，它们都只是引用而已，引用+节点是 Git 构成分布式的关键</li>
<li>merge相比于rebase有更明确的时间历史，而rebase会使提交更加线性应当优先使用</li>
<li>通过移动HEAD可以查看每个提交对应的代码</li>
<li>clone或fetch都会将远程仓库的所有提交、引用保存在本地一份</li>
<li>pull的本质其实就是fetch+merge，也可以加入--rebase通过rebase方式合并</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>CSS推荐</title>
      <link>https://jin-shaohui.gitee.io/Recommend/CSS/</link>
      <guid>https://jin-shaohui.gitee.io/Recommend/CSS/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">CSS推荐</source>
      <description>前端 - Css CSS 参考书 交互式在线 CSS 速记表 CSS 小花招 学习 CSS 布局 450 多个纯 CSS 实现的 UI 设计</description>
      <category>推荐</category>
      <pubDate>Wed, 01 Feb 2023 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 前端 - Css</h3>
<ul>
<li><a href="https://cssreference.io/" target="_blank" rel="noopener noreferrer">CSS 参考书</a></li>
<li><a href="https://htmlcheatsheet.com/css/" target="_blank" rel="noopener noreferrer">交互式在线 CSS 速记表</a></li>
<li><a href="https://css-tricks.com/" target="_blank" rel="noopener noreferrer">CSS 小花招</a></li>
<li><a href="https://zh.learnlayout.com/" target="_blank" rel="noopener noreferrer">学习 CSS 布局</a></li>
<li><a href="https://codemyui.com/tag/" target="_blank" rel="noopener noreferrer">450 多个纯 CSS 实现的 UI 设计</a></li>
</ul>
<h3> 前端 - JS</h3>
<ul>
<li><a href="https://animate.style/" target="_blank" rel="noopener noreferrer">CSS 动画集</a></li>
<li><a href="https://animxyz.com/" target="_blank" rel="noopener noreferrer">CSS 三维变换动画</a></li>
<li><a href="https://animista.net/play/" target="_blank" rel="noopener noreferrer">CSS 动画集，可自由调节动画参数，生成代码片段</a></li>
</ul>
<h3> 前端 - 边学边玩Css</h3>
<ul>
<li><a href="https://cssgridgarden.com/" target="_blank" rel="noopener noreferrer">通过给萝卜浇水，学习 CSS 网格布局</a></li>
<li><a href="http://www.flexboxdefense.com/" target="_blank" rel="noopener noreferrer">CSS 塔防游戏，学习 flex 布局</a></li>
<li><a href="https://flexboxfroggy.com/" target="_blank" rel="noopener noreferrer">送小青蛙回家，学习 flex 布局</a></li>
</ul>
<h3> 前端 - 在线工具</h3>
<ul>
<li><a href="https://glassgenerator.netlify.app/" target="_blank" rel="noopener noreferrer">磨砂透明效果</a></li>
<li><a href="https://coolbackgrounds.io/" target="_blank" rel="noopener noreferrer">酷酷的背景图</a></li>
<li><a href="https://www.pixelartcss.com/" target="_blank" rel="noopener noreferrer">自定义像素素材</a></li>
<li><a href="https://stripesgenerator.com/" target="_blank" rel="noopener noreferrer">布条背景图生成器</a></li>
<li><a href="https://grid.layoutit.com/" target="_blank" rel="noopener noreferrer">网格布局生成器</a></li>
<li><a href="https://csslayout.io/" target="_blank" rel="noopener noreferrer">纯 CSS 实现的一套页面元素、组件集</a></li>
<li><a href="https://www.30secondsofcode.org/css/" target="_blank" rel="noopener noreferrer">30 秒代码片段</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>其他推荐</title>
      <link>https://jin-shaohui.gitee.io/Recommend/Other/</link>
      <guid>https://jin-shaohui.gitee.io/Recommend/Other/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">其他推荐</source>
      <description>面试题 leetcode 最常见的 150 道前端面试题 为什么都说首屏html大小限制在14KB以内</description>
      <category>推荐</category>
      <pubDate>Wed, 01 Feb 2023 16:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 面试题</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/idLCZ32YvYPqUg83FUJOdA" target="_blank" rel="noopener noreferrer">leetcode 最常见的 150 道前端面试题</a></li>
<li><a href="https://mp.weixin.qq.com/s/JM9EjDC2FxrI--MB53SN1Q" target="_blank" rel="noopener noreferrer">为什么都说首屏html大小限制在14KB以内</a></li>
</ul>
<h2> JS</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/jsy3dDmpMdQ-MSXQNVehNA" target="_blank" rel="noopener noreferrer">24个 JavaScript 循环遍历方法，你都知道吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/361968852" target="_blank" rel="noopener noreferrer">【废话角度学 TS】泛型？Partial？Omit？关键字 extends？keyof？infer？大白话聊实现思路</a></li>
<li><a href="https://mp.weixin.qq.com/s/QNLbWevLtRTmq4reOFSxOA" target="_blank" rel="noopener noreferrer">22个ES6知识点汇总，爆肝了</a></li>
<li><a href="https://juejin.cn/post/7028744289890861063#heading-7" target="_blank" rel="noopener noreferrer">这几个高级前端常用的API，你用到了吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/vSqnsW5xJXzp1rwc_LtE2w" target="_blank" rel="noopener noreferrer">基于js管理大文件上传以及断点续传</a></li>
<li><a href="https://juejin.cn/post/7040671388025225229" target="_blank" rel="noopener noreferrer">面试官: 如何让localStorage支持过期时间设置?</a></li>
</ul>
<h2> TS</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/l1T_vB5vbw0XnMgQDO_60g" target="_blank" rel="noopener noreferrer">基于 TypeScript 实现一个基于 Proxy 的缓存库</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/361968852" target="_blank" rel="noopener noreferrer">【废话角度学 TS】泛型？Partial？Omit？关键字 extends？keyof？infer？大白话聊实现思路</a></li>
<li><a href="https://mp.weixin.qq.com/s/7aUzT5ayagnnmL6591672g" target="_blank" rel="noopener noreferrer">React+Ts，这样学起来确实简单！！！</a></li>
<li><a href="https://mp.weixin.qq.com/s/Sc80uwj1eNs-fO8ukw5R9w" target="_blank" rel="noopener noreferrer">「超长1.9W字总结」通俗易懂的 TS 教程，一步到位</a></li>
<li><a href="https://mp.weixin.qq.com/s/DOB8RVncf8k0a8_oEZsQTw" target="_blank" rel="noopener noreferrer">如何进阶TypeScript功底？一文带你理解TS中各种高级语法</a></li>
<li><a href="https://mp.weixin.qq.com/s/uoTFX_1VVyEgLQ8z6PkACA" target="_blank" rel="noopener noreferrer">Typescript 类型编程，从入门到念头通达</a></li>
</ul>
<h2> VUE</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw" target="_blank" rel="noopener noreferrer">来吧，解锁vue3全家桶+Ts的正确姿势</a></li>
<li><a href="https://mp.weixin.qq.com/s/rJM9OaDI5Hnn-GBR-cT5JA" target="_blank" rel="noopener noreferrer">万万没想到，Vue3 的 setup 还能这么玩</a></li>
<li><a href="https://mp.weixin.qq.com/s/rqoZ5KWqT_1QAx91bJMeIg" target="_blank" rel="noopener noreferrer">每个人都需要掌握的「Vue2」50个知识点！</a></li>
<li><a href="https://mp.weixin.qq.com/s/A1uRq0XwhZPRIZetrEFM0g" target="_blank" rel="noopener noreferrer">为什么Proxy一定要配合Reflect使用？</a></li>
<li><a href="https://juejin.cn/post/6844904120290131982" target="_blank" rel="noopener noreferrer">Vue 的计算属性真的会缓存吗？（保姆级教学，原理深入揭秘）</a></li>
<li><a href="https://mp.weixin.qq.com/s/D9Z0rET7WgNQc2eMy7y1pg" target="_blank" rel="noopener noreferrer">从理解路由到实现一套Router（路由）</a></li>
<li><a href="https://mp.weixin.qq.com/s/CfnTV0RJJ-h8fPmXw4DkkA" target="_blank" rel="noopener noreferrer">Vue2 到 Vue3，重学这 5 个常用的 API</a></li>
</ul>
<h1> react</h1>
<ul>
<li><a href="https://mp.weixin.qq.com/s/LBgLd9Iz6RLteQAJyQfSSQ" target="_blank" rel="noopener noreferrer">「万字总结」动画 + 大白话讲清楚React渲染原理</a></li>
</ul>
<h1> 性能优化</h1>
<ul>
<li><a href="https://juejin.cn/post/6911472693405548557#heading-1" target="_blank" rel="noopener noreferrer">前端性能优化</a></li>
<li><a href="https://mp.weixin.qq.com/s/jO7zNYtOkDHX5UFURwy0Og" target="_blank" rel="noopener noreferrer">前端性能优化到底该怎么做（上）- 开门见山</a></li>
<li><a href="https://mp.weixin.qq.com/s/SvvNRZCSZSxeJc8R9ULKPQ" target="_blank" rel="noopener noreferrer">前端性能优化到底该怎么做（下）- 直捣黄龙</a></li>
</ul>
<h2> 前端知识库</h2>
<ul>
<li>
<p><a href="https://www.html5iq.com/5feb26ddf72c21052324d0fd.html" target="_blank" rel="noopener noreferrer">https://www.html5iq.com/5feb26ddf72c21052324d0fd.html</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/7016593221815910408#heading-91" target="_blank" rel="noopener noreferrer">连八股文都不懂还指望在前端混下去么</a></p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/BV1zV411z7RX?spm_id_from=333.999.0.0" target="_blank" rel="noopener noreferrer">8分钟带你了解V8引擎是如何运行JS</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6844903966573068301" target="_blank" rel="noopener noreferrer">浏览器层合成与页面渲染优化</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/V_YWbswXoea-Em-l_K97sw" target="_blank" rel="noopener noreferrer">手写一个虚拟DOM库，彻底让你理解diff算法</a></p>
</li>
<li>
<p><a href="https://www.kancloud.cn/hiyang/nginx/364780" target="_blank" rel="noopener noreferrer">nginx的功能</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/36-rfSJ-PF9pk2qLITQQoQ" target="_blank" rel="noopener noreferrer">比较全面的 Dockerfile 文件详解！</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/XaoHrP_-_hpIK8ixEAi1tA" target="_blank" rel="noopener noreferrer">零基础上手低代码，揭秘如何写一个页面设计器</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/vz9CRQaCXsQfl2JLn1sn5g" target="_blank" rel="noopener noreferrer">拖拽牛逼，轻松实现一个自由拖拽的组件</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/Kyr5TBpMpXTBG9wIhmsPHg" target="_blank" rel="noopener noreferrer">前端开发者应该知道的 Centos/Docker/Nginx/Node/Jenkins 操作(长文，建议收藏)</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/vYBuO2lOw0k2dBKx9Uy0yw" target="_blank" rel="noopener noreferrer">Webpack来了！三心教你实现一个Vue-Cli的「基础搭建」</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/COzqLGzEOhMlU9MeYAD_6g" target="_blank" rel="noopener noreferrer">15个 Webpack 优化点，速度提升70%，体积减小80%！</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/6PE1knh9gyj41-7yfbfK_Q" target="_blank" rel="noopener noreferrer">一道面试题牵出12个前端硬核知识点，你知道几个？</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/gKb4Hbs3eH1ddyXepunQjg" target="_blank" rel="noopener noreferrer">Vue + Node.js 从 0 到 1 实现自动化部署工具</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/k4C4TxFglDfVuUwX_dhpkA" target="_blank" rel="noopener noreferrer">万恶的 eval() ？很少人去了解它~</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/86426969" target="_blank" rel="noopener noreferrer">三次握手四次挥手</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/u589UJ8zhZiocFxVEzrfpg" target="_blank" rel="noopener noreferrer">中高级前端工程师都需要熟悉的技能--前端缓存</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/R_alNKqlH4yBKrKb-ChEVA" target="_blank" rel="noopener noreferrer">一文彻底深入搞懂JS事件循环机制（Event Loop）、同步异步、宏任务、微任务、调用堆栈</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/-g2W_yrslumyYSBdRk7EPQ" target="_blank" rel="noopener noreferrer">这么多年你还在怕正则吗？</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/d73fuX4Wve2WHxoR4v4tkA" target="_blank" rel="noopener noreferrer">【设计模式】面试中被问的最频繁的「策略模式」</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/pWoyPMadDw51BaJFECMoBQ" target="_blank" rel="noopener noreferrer">前端性能优化——包体积压缩82%、打包速度提升65%</a></p>
</li>
<li>
<p><a href="https://mp.weixin.qq.com/s/Ear2yeHfbNdnJnP8S2xTIQ" target="_blank" rel="noopener noreferrer">一起玩转Vue中的JSX：让你一次性掌握它的特性!</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>服务器</title>
      <link>https://jin-shaohui.gitee.io/Server/</link>
      <guid>https://jin-shaohui.gitee.io/Server/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">服务器</source>
      <description>远程连接问题 修改登录客户端，即本地计算机的设置。 运行gpedit.msc打开本地组策略编辑器，依次展开“计算机配置”-&amp;gt;“管理模板”-&amp;gt;“系统”-&amp;gt;“凭据分配”，选择设置项： 加密 Oracle 修正 然后右键编辑，改为 启用，保护级别为 易受攻击，确定。设置完成后即可正常远程。 查看网卡配置 cd /etc/sysconfig/network-scripts/</description>
      <category>服务器</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 远程连接问题</h2>

<p>修改登录客户端，即本地计算机的设置。
运行gpedit.msc打开本地组策略编辑器，依次展开“计算机配置”-&gt;“管理模板”-&gt;“系统”-&gt;“凭据分配”，选择设置项： 加密 Oracle 修正
然后右键编辑，改为 启用，保护级别为 易受攻击，确定。设置完成后即可正常远程。</p>
<h2> 查看网卡配置</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 按时间显示文件</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 查看具体网卡信息</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 查看eth0的配置</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 配置IP、子网掩码、网关</h2>
<h3> 重启网卡</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 配置</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 配置文件</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Lambda</title>
      <link>https://jin-shaohui.gitee.io/Java/Lambda/</link>
      <guid>https://jin-shaohui.gitee.io/Java/Lambda/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Lambda</source>
      <description>Lambda 表达式(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。 表达式的结构 一个 Lambda 表达式可以有零个或多个参数 参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c) 空圆括号代表参数集为空。例如：() -&amp;gt; 42 当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&amp;gt; return a * a Lambda 表达式的主体可包含零条或多条语句 如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致 如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</description>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 11:26:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>Lambda 表达式(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。</p>
<h2> 表达式的结构</h2>
<ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li>
<li>空圆括号代表参数集为空。例如：() -&gt; 42</li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a * a</li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h2> 表达式的使用</h2>
<p>下面我们先使用一个简单的例子来看看Lambda的效果吧。
比如我们对Map 的遍历 传统方式遍历如下:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用Lambda进行遍历:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>List也同理，不过List还可以通过双冒号运算符遍历:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>Lambda除了在for循环遍历中使用外，它还可以代替匿名的内部类。比如下面这个例子的线程创建:</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注: 这个例子中使用Lambda表达式的时候，编译器会自动推断：根据线程类的构造函数签名 Runnable r { }，将该 Lambda 表达式赋Runnable 接口。</p>
<p>Lambda 表达式与匿名类的区别使用匿名类与 Lambda 表达式的一大区别在于关键词的使用。对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为写就 Lambda 的外部类。</p>
<h2> 注意事项</h2>
<p>Lambda虽然简化了代码的编写，但同时也减少了可读性。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Stream</title>
      <link>https://jin-shaohui.gitee.io/Java/Stream/</link>
      <guid>https://jin-shaohui.gitee.io/Java/Stream/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Stream</source>
      <description>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。 Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。 这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。 特性 不是数据结构：它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 不支持索引访问：但是很容易生成数组或者 List 。 惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。 并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。 注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。</description>
      <category>Java</category>
      <pubDate>Mon, 16 May 2022 11:26:43 GMT</pubDate>
      <content:encoded><![CDATA[<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。
Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。
这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<h2> 特性</h2>
<ul>
<li>不是数据结构：它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li>
<li>不支持索引访问：但是很容易生成数组或者 List 。</li>
<li>惰性化：很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。Intermediate 操作永远是惰性化的。</li>
<li>并行能力。当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li>
<li>可以是无限的：集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li>
<li>注意事项：所有 Stream 的操作必须以 lambda 表达式为参数。</li>
</ul>
<h2> 流操作类型</h2>
<ul>
<li>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</li>
<li>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</li>
</ul>
<h2> 基本使用</h2>
<p>这里我们依旧使用一个简单示例来看看吧。在开发中，我们有时需要对一些数据进行过滤，如果是传统的方式，我们需要对这批数据进行遍历过滤，会显得比较繁琐，如果使用stream流方式的话，那么可以很方便的进行处理。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>是不是很简洁和方便呢。其实Stream流还有更多的使用方法，filter只是其中的一角而已。那么在这里我们就来学习了解下这些用法吧。</p>
<h2> 构造Stream流的方式</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的之间的转换</h2>
<p>注意:一个Stream流只可以使用一次，这段代码为了简洁而重复使用了数次，因此会抛出 stream has already been operated upon or closed 异常。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的map使用</h2>
<p>map方法用于映射每个元素到对应的结果，一对一。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的filter使用</h2>
<p>filter方法用于通过设置的条件过滤出元素。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的flatMap使用</h2>
<p>flatMap 方法用于映射每个元素到对应的结果，一对多。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的limit使用</h2>
<p>limit 方法用于获取指定数量的流。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的sort使用</h2>
<p>sorted方法用于对流进行升序排序。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的peek使用</h2>
<p>peek对每个元素执行操作并返回一个新的Stream</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的parallel使用</h2>
<p>parallelStream 是流并行处理程序的代替方法。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的max/min/distinct使用</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的Match使用</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的reduce使用</h2>
<p>reduce 主要作用是把 Stream 元素组合起来进行操作。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的iterate使用</h2>
<p>iterate 跟 reduce 操作很像，接受一个种子值，和一个UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的Supplier使用</h2>
<p>通过实现Supplier类的方法可以自定义流计算规则。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的groupingBy/partitioningBy使用</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Stream流的summaryStatistics使用</h2>
<p>IntSummaryStatistics 用于收集统计信息(如count、min、max、sum和average)的状态对象。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Stream 介绍就到这里了，JDK1.8中的Stream流其实还有很多很多用法，更多的用法则需要大家去查看JDK1.8的API文档了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>工具类</title>
      <link>https://jin-shaohui.gitee.io/Java/Utils/</link>
      <guid>https://jin-shaohui.gitee.io/Java/Utils/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">工具类</source>
      <description>加解密 AES加解密 public static void main(String[] args) throws Exception { DeshfuUtil desUtil = new DeshfuUtil(); System.out.println(&amp;quot;加密:&amp;quot;+encrypt(&amp;quot;abcdef&amp;quot;) .toUpperCase()); System.out.println(&amp;quot;解密:&amp;quot;+decrypt(&amp;quot;7E91EA4F56943F90&amp;quot;)); }</description>
      <category>Java</category>
      <pubDate>Fri, 24 Feb 2023 15:34:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 加解密</h2>
<h3> AES加解密</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> RSA加解密</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 文件</h2>
<h3> 文件上传下载</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Sftp</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 图片处理</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 图片转换</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Excel</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 数据</h2>
<h3> 时间</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 人民币大写</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 字符串</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> XML转对象</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 驼峰转换</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 对象转换</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> POJO、XML、JavaBean类型转换</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 解析</h2>
<h3> URL参数解析</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 身份证校验</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 解析IP</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 其他</h2>
<h3> Redis</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SMS</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>(dev)Dependencies</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Configuration/Dependencies/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Configuration/Dependencies/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">(dev)Dependencies</source>
      <description>浑水摸鱼的说法？ 以前说到 dependencies 和 devDependencies 的时候，大家会想到啥？ dependencies：生产环境需要的依赖 devDependencies：开发环境需要的依赖 但是我们装依赖的时候真的会去考虑 npm install -D 还是 npm install -S 吗？ 其实并不会去关心哪些是生产环境所需依赖，哪些是开发环境所需依赖，但是这也正常，因为其实在SPA项目中，这两个东西并不需要区分！所以平时没有过多了解也正常！！！</description>
      <category>PackageJson</category>
      <pubDate>Fri, 27 May 2022 15:54:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 浑水摸鱼的说法？</h2>
<p>以前说到 <code>dependencies</code> 和 <code>devDependencies</code> 的时候，大家会想到啥？</p>
<ul>
<li><code>dependencies</code>：生产环境需要的依赖</li>
<li><code>devDependencies</code>：开发环境需要的依赖</li>
</ul>
<p>但是我们装依赖的时候真的会去考虑 <code>npm install -D</code> 还是 <code>npm install -S</code> 吗？</p>
<p>其实<code>并不会</code>去关心哪些是<code>生产环境</code>所需依赖，哪些是<code>开发环境</code>所需依赖，但是这也正常，因为其实在<code>SPA</code>项目中，这两个东西并<code>不需要区分</code>！所以平时没有过多了解也正常！！！</p>
<h2> SPA项目</h2>
<p>所谓SPA项目，其实指的就是<code>单页面应用</code>，比如说<code>Vue</code>、<code>React</code>项目这些</p>
<h3> 开发环境</h3>
<p>开发项目时，肯定是两种包都需要安装的</p>
<h3> 生产环境</h3>
<p>生产环境中，是将开发环境的代码，使用某些打包工具，例如<code>Webpack</code>，将整个项目代码<code>打包</code>成一些<code>静态的文件</code>，然后将这些<code>静态文件</code>部署到<code>服务器</code>上，也就是到达生产环境。</p>
<p>所以大家也看到了，只有<code>开发环境</code>时需要<code>装包</code>，<code>生产环境</code>是<code>不需要装包</code>的，所以把包放在<code>dependencies</code>和<code>devDependencies</code>中是<code>没有区别</code>的。</p>
<p>为什么这么说呢？因为其实无论把包放在哪里都好，只要你代码中<code>引用</code>到了这个包，那么<code>Webpack</code>打包时就会把这个包<code>打包</code>进静态文件中。</p>
<p>所以，在开发SPA项目时，<code>dependencies和devDependencies并没啥区分意义</code>。</p>
<h2> Nodejs项目</h2>
<p><code>Nodejs</code>项目<code>上线</code>的话，是<code>不用打包</code>的，是将整个<code>完整项目代码</code>扔到<code>服务器</code>上，然后运行，所以它是<code>需要</code>区分<code>dependencies</code>和<code>devDependencies</code>的。</p>
<p>因为当它部署到服务器上之后，也就是生产环境之后，它是需要再 <code>npm install</code> 一次的。</p>
<div class="hint-container danger">
<p class="hint-container-title">警告</p>
</div>
<h2> NPM包</h2>
<p>开发了一个NPM包，叫做<code>npm-lsx</code>，在开发的过程中，需要对所开发的这个包进行<code>单元测试</code>，所以安装了所需的依赖包<code>npm-test</code>，也就是依赖关系是<code>npm-lsx -&gt; npm-test</code></p>
<p>小明在做一个<code>项目A</code>，他项目中装了<code>npm-lsx</code>这个包，而大家都知道，装一个包时，会连同这个包所依赖的包都一起装，所以按理说<code>npm-lsx</code>、<code>npm-test</code>都会装，但是大家想想，<code>项目A</code>需要<code>npm-test</code>这个包吗？</p>
<p>并不需要，这个包对于项目A来说<code>没意义</code>。</p>
<p>你可以理解为，项目A的 <code>开发环境</code>，其实就是 <code>npm-lsx</code> 的 <code>生产环境</code>。</p>
<p>所以在开发<code>npm-lsx</code>的时候会把<code>npm-test</code>装在<code>devDependencies</code>中，这样，项目A就可以少装一些<code>没意义的包</code>，加快整体装包速度！</p>
<p>所以在<code>NPM</code>项目中，<code>dependencies</code> 和 <code>devDependencies</code>是有区分意义的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>手写Webpack</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Configuration/Webpack/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Configuration/Webpack/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">手写Webpack</source>
      <description>前言 Webpack在前端构建工具中可以堪称中流砥柱般的存在，日常业务开发、前端基建工具、高级前端面试...任何场景都会出现它的身影。 也许对于它的内部实现机制，我们也许会感到疑惑，日常工作中基于Webpack Plugin/Loader之类查阅API仍然不明白各个参数的含义和应用方式。其实这一切原因本质上都是基于Webpack工作流没有一个清晰的认知导致了所谓的“面对API无从下手”开发。 下面，我们会从如何实现 模块分析项目打包 的角度出发，使用 最通俗，最简洁，最明了 的代码带你揭开Webpack背后的神秘面纱，带你实现一个简易版Webpack，从此对于任何webpack相关底层开发了然于胸。用最通俗易懂的代码带你走进webpack的工作流。 可以根据 代码 一边看一边尝试</description>
      <category>Webpack</category>
      <pubDate>Fri, 27 May 2022 15:54:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><code>Webpack</code>在前端构建工具中可以堪称中流砥柱般的存在，日常业务开发、前端基建工具、高级前端面试...任何场景都会出现它的身影。</p>
<p>也许对于它的内部实现机制，我们也许会感到疑惑，日常工作中基于<code>Webpack Plugin/Loader</code>之类查阅<code>API</code>仍然不明白各个参数的含义和应用方式。其实这一切原因本质上都是基于<code>Webpack</code>工作流没有一个清晰的认知导致了所谓的“面对<code>API</code>无从下手”开发。</p>
<p>下面，我们会从如何实现 <strong>模块分析项目打包</strong> 的角度出发，使用 <strong>最通俗，最简洁，最明了</strong> 的代码带你揭开<code>Webpack</code>背后的神秘面纱，带你实现一个简易版<code>Webpack</code>，从此对于任何<code>webpack</code>相关底层开发了然于胸。用最通俗易懂的代码带你走进<code>webpack</code>的工作流。</p>
<blockquote>
<p>可以根据 <a href="https://gitee.com/jin-shaohui/webpack-demo" target="_blank" rel="noopener noreferrer">代码</a> 一边看一边尝试</p>
</blockquote>
<!-- more -->
<h2> 前置知识</h2>
<ul>
<li>
<p><strong>Tapable</strong></p>
<p>Tapable包本质上是为我们更方面创建自定义事件和触发自定义事件的库，类似于<code>Nodejs</code>中的<code>EventEmitter Api</code>。<code>Webpack</code>中的插件机制就是基于Tapable实现与打包流程解耦，插件的所有形式都是基于<code>Tapable</code>实现。</p>
</li>
<li>
<p><strong>Webpack Node Api</strong></p>
<p>基于学习目的，会着重于<code>Webpack Node Api</code>流程去讲解，实际上前端日常使用的<code>npm run build</code>命令也是通过环境变量调用<code>bin</code>脚本去调用<code>Node Api</code>去执行编译打包。</p>
</li>
<li>
<p><strong>Babel</strong></p>
<p><code>Webpack</code>内部的<code>AST</code>分析同样依赖于<code>Babel</code>进行处理，如果你对<code>Babel</code>不是很熟悉。建议可以先去阅读下这两篇文章 <strong>「前端基建」带你在Babel的世界中畅游</strong>、<strong>从Tree Shaking来走进Babel插件开发者的世界</strong>。</p>
</li>
</ul>
<blockquote>
<p>当然后续也会去详解这些内容在<code>Webpack</code>中的应用，但是我更加希望在阅读文章之前你可以去点一点上方的文档稍微了解一下前置知识。</p>
</blockquote>
<h2> 流程梳理</h2>
<p>在开始之前我们先对于整个打包流程进行一次梳理。这里仅仅是一个全流程的梳理，现在没有必要非常详细的去思考每一个步骤发生了什么，我们会在接下来的步骤中去一步一步带你串联它们。</p>
<p>整体将会从上边5个方面来分析<code>Webpack</code>打包流程:</p>
<ol>
<li>
<p>初始化参数阶段</p>
<p>这一步会从配置的<code>webpack.config.js</code>中读取到对应的配置参数和<code>shell</code>命令中传入的参数进行合并得到最终打包配置参数。</p>
</li>
<li>
<p>开始编译准备阶段</p>
<p>这一步我们会通过调用<code>webpack()</code>方法返回一个<code>compiler</code>方法，创建我们的<code>compiler</code>对象，并且注册各个<code>Webpack Plugin</code>。找到配置入口中的<code>entry</code>代码，调用<code>compiler.run()</code>方法进行编译。</p>
</li>
<li>
<p>模块编译阶段</p>
<p>从入口模块进行分析，调用匹配文件的<code>loaders</code>对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作。</p>
</li>
<li>
<p>完成编译阶段</p>
<p>在递归完成后，每个引用模块通过<code>loaders</code>处理完成同时得到模块之间的相互依赖关系。</p>
</li>
<li>
<p>输出文件阶段</p>
<p>整理模块依赖关系，同时将处理后的文件输出到<code>ouput</code>的磁盘目录中。
d</p>
</li>
</ol>
<h2> 创建目录</h2>
<p>工欲善其事，必先利其器。首先让我们创建一个良好的目录来管理我们需要实现的<code>Packing tool</code>吧！</p>
<p>让我们来创建这样一个目录:</p>

<h2> 初始化参数阶段</h2>
<p>往往，我们在日常使用阶段有两种方式去给<code>webpack</code>传递打包参数，让我们先来看看如何传递参数:</p>
<h3> <code>Cli</code>命令行传递参数</h3>
<p>通常，我们在使用调用<code>webpack</code>命令时，有时会传入一定命令行参数，比如:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> <code>webpack.config.js</code>传递参数</h3>
<p>另一种方式，我相信就更加老生常谈了。</p>
<p>我们在项目根目录下使用<code>webpack.config.js</code>导出一个对象进行<code>webpack</code>配置:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>当然这里的<code>loader</code>和<code>plugin</code>目前你可以不用理解，接下来我们会逐步实现这些东西并且添加到我们的打包流程中去。</p>
</blockquote>
<h3> 实现合并参数阶段</h3>
<p>这一步，让我们真正开始动手实现我们的<code>webpack</code>吧！</p>
<p>首先让我们在<code>webpack/core</code>下新建一个<code>index.js</code>文件作为核心入口文件。</p>
<p>同时建立一个<code>webpack/core</code>下新建一个<code>webpack.js</code>文件作为<code>webpack()</code>方法的实现文件。</p>
<p>首先，我们清楚在<code>NodeJs Api</code>中是通过<code>webpack()</code>方法去得到<code>compiler</code>对象的。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时让我们按照原本的<code>webpack</code>接口格式来补充一下<code>index.js</code>中的逻辑:</p>
<ul>
<li>我们需要一个<code>webpack</code>方法去执行调用命令。</li>
<li>同时我们引入<code>webpack.config.js</code>配置文件传入<code>webpack</code>方法。</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>嗯，看起来还不错。接下来让我们去实现一下<code>webpack.js</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们需要额外说明的是</p>
<p><code>webpack</code>文件中需要导出一个名为<code>webpack</code>的方法，同时接受外部传入的配置对象。这个是我们在上述讲述过的。</p>
<p>当然关于我们合并参数的逻辑，是将<strong>外部传入的对象和执行<code>shell</code>时的传入参数进行最终合并</strong>。</p>
<p>在<code>Node Js</code>中我们可以通过<code>process.argv.slice(2)</code>来获得<code>shell</code>命令中传入的参数，比如:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然<code>_mergeOptions</code>方法就是一个简单的合并配置参数的方法，相信对于大家来说就是小菜一碟。</p>
<p>恭喜大家🎉，千里之行始于足下。<strong>这一步我们已经完成了打包流程中的第一步：合并配置参数</strong>。</p>
<h2> 编译阶段</h2>
<p>在得到最终的配置参数之后，我们需要在<code>webpack()</code>函数中做以下几件事情:</p>
<ul>
<li>通过参数创建<code>compiler</code>对象。我们看到官方案例中通过调用<code>webpack(options)</code>方法返回的是一个<code>compiler</code>对象。并且同时调用<code>compiler.run()</code>方法启动的代码进行打包。</li>
<li>注册我们定义的<code>webpack plugin</code>插件。</li>
<li>根据传入的配置对象寻找对应的打包入口文件。</li>
</ul>
<h3> 创建<code>compiler</code>对象</h3>
<p>让我们先来完成<code>index.js</code>中的逻辑代码补全:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，核心编译实现在于<code>webpack()</code>方法返回的<code>compiler.run()</code>方法上。</p>
<p>一步一步让我们来完善这个<code>webpack()</code>方法：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>让我们在<code>webpack/core</code>目录下同样新建一个<code>compiler.js</code>文件，作为<code>compiler</code>的核心实现文件:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们的<code>Compiler</code>类就先搭建一个基础的骨架代码。</p>
<p>目前，我们拥有了:</p>
<ul>
<li><code>webpack/core/index.js</code>作为打包命令的入口文件，这个文件引用了我们自己实现的<code>webpack</code>，同时引用了外部的<code>webpack.config.js(options)</code>。调用<code>webpack(options).run()</code>开始编译。</li>
<li><code>webpack/core/webpack.js</code>这个文件目前处理了参数的合并以及传入合并后的参数<code>new Compiler(mergeOptions)</code>，同时返回创建的<code>Compiler</code>实力对象。</li>
<li><code>webpack/core/compiler</code>，此时我们的<code>compiler</code>仅仅是作为一个基础的骨架，存在一个<code>run()</code>启动方法。</li>
</ul>
<h3> 编写<code>Plugin</code></h3>
<p>还记得我们在<code>webpack.config.js</code>中使用了两个<code>plugin</code>---<code>pluginA</code>、<code>pluginB</code>插件吗。接下来让我们来依次实现它们:</p>
<p>在实现<code>Plugin</code>前，我们需要先来完善一下<code>compiler</code>方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，我们在<code>Compiler</code>这个类的构造函数中创建了一个属性<code>hooks</code>，它的值是三个属性<code>run</code>、<code>emit</code>、<code>done</code>。</p>
<p>关于这三个属性的值就是我们上文提到前置知识的<code>tapable</code>的<code>SyncHook</code>方法，本质上你可以简单将<code>SyncHook()</code>方法理解称为一个<code>Emitter Event</code>类。</p>
<p>当我们通过<code>new SyncHook()</code>返回一个对象实例后，我们可以通过<code>this.hook.run.tap('name',callback)</code>方法为这个对象上添加事件监听，然后在通过<code>this.hook.run.call()</code>执行所有<code>tap</code>注册的事件。</p>
<blockquote>
<p>当然<code>webpack</code>真实源码中，这里有非常多的<code>hook</code>。以及分别存在同步/异步钩子，这里更多的是为大家讲解清楚流程，所以仅列举了三个常见且简单的同步钩子。</p>
</blockquote>
<p>此时，我们需要明白，我们可以通过<code>Compiler</code>类返回的实例对象上<code>compiler.hooks.run.tap</code>注册钩子。</p>
<p>接下来让我们切回到<code>webpack.js</code>中，让我们来填充关于插件注册的逻辑:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们在创建完成<code>compiler</code>对象后，调用了<code>_loadPlugin</code>方法进行<strong>注册插件</strong>。</p>
<p>有接触过<code>webpack</code>插件开发的同学，或多或少可能都有了解过。<strong>任何一个<code>webpack</code>插件都是一个类(当然类本质上都是funciton的语法糖)，每个插件都必须存在一个<code>apply</code>方法</strong>。</p>
<p>这个<code>apply</code>方法会接受一个<code>compiler</code>对象。我们上边做的就是依次调用传入的<code>plugin</code>的<code>apply</code>方法并且传入我们的<code>compiler</code>对象。</p>
<blockquote>
<p><strong>这里请记住上边的流程，日常我们编写<code>webpack plugin</code>时本质上就是操作<code>compiler</code>对象从而影响打包结果进行。</strong></p>
</blockquote>
<p>接下来让我们去编写这些个插件:</p>
<p>不了解插件开发的同学可以去稍微看一下<strong>官方的介绍</strong>，其实不是很难，强烈建议如果不了解可以先去看看再回来结合上变讲的内容你一定会有所收获的。</p>
<p>首先让我们先创建文件（plugin1.js、plugin2.js）:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看到这里我相信大部分同学都已经反应过来了，<code>compiler.hooks.run.tap</code>和<code>compiler.hooks.done.tap</code>不就是上边讲到的通过<code>tapable</code>创建一个<code>SyncHook</code>实例然后通过<code>tap</code>方法注册事件吗？</p>
<p>没错！的确是这样，关于<code>webpack</code>插件<strong>本质上就是通过发布订阅的模式，通过<code>compiler</code>上监听事件。然后再打包编译过程中触发监听的事件从而添加一定的逻辑影响打包结果</strong>。</p>
<p>我们在每个插件的<code>apply</code>方法上通过<code>tap</code>在编译准备阶段(也就是调用<code>webpack()</code>函数时)进行订阅对应的事件，当我们的编译执行到一定阶段时发布对应的事件告诉订阅者去执行监听的事件，从而达到在编译阶段的不同生命周期内去触发对应的<code>plugin</code>。</p>
<blockquote>
<p>所以这里应该清楚，在进行<code>webpack</code>插件开发时，<code>compiler</code>对象上存放着本次打包的所有相关属性，比如<code>options</code>打包的配置，以及之后讲到的各种属性。</p>
</blockquote>
<h3> 寻找<code>entry</code>入口</h3>
<p>这之后，绝大多数内容都会放在<code>compiler.js</code>中去实现<code>Compiler</code>这个类实现打包的核心流程。</p>
<p><strong>任何一次打包都需要入口文件，接下来让我们就从真正进入打包编译阶段。首当其冲的事情就是，我们需要根据入口配置文件路径寻找到对应入口文件。</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一步我们通过<code>options.entry</code>处理获得入口文件的绝对路径。</p>
<p>这里有几个需要注意的小点:</p>
<ul>
<li><code>this.hooks.run.call()</code></li>
</ul>
<p>在我们<code>_loadePlugins</code>函数中对于每一个传入的插件在<code>compiler</code>实例对象中进行了订阅，那么当我们调用<code>run</code>方法时，等于真正开始执行编译。这个阶段<strong>相当于我们需要告诉订阅者，发布开始执行的订阅</strong>。此时我们通过<code>this.hooks.run.call()</code>执行关于<code>run</code>的所有<code>tap</code>监听方法，从而触发对应的<code>plugin</code>逻辑。</p>
<ul>
<li><code>this.rootPath</code>:</li>
</ul>
<p>在上述的外部<code>webpack.config.js</code>中我们配置了一个 <code>context: process.cwd()</code>，其实真实<code>webpack</code>中这个<code>context</code>值默认也是<code>process.cwd()</code>。</p>
<p>简而言之，这个路径就是我们项目启动的目录路径，任何<code>entry</code>和<code>loader</code>中的相对路径都是针对于<code>context</code>这个参数的相对路径。</p>
<p>这里我们使用<code>this.rootPath</code>在构造函数中来保存这个变量。</p>
<ul>
<li><code>toUnixPath</code>工具方法:</li>
</ul>
<p>因为不同操作系统下，文件分隔路径是不同的。这里我们统一使用<code>\</code>来替换路径中的<code>//</code>来替换模块路径。后续我们会<strong>使用模块相对于<code>rootPath</code>的路径作为每一个文件的唯一ID</strong>，所以这里统一处理下路径分隔符。</p>
<ul>
<li><code>entry</code>的处理方法:</li>
</ul>
<p>关于<code>entry</code>配置，<code>webpack</code>中其实有很多种。我们这里考虑了比较常见的两种配置方式:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种方式任何方式都会经过<code>getEntry</code>方法最终转化称为<code>{ [模块名]:[模块绝对路径]... }</code>的形式，关于<code>getEntry()</code>方法其实非常简单，这里就不过于累赘这个方法的实现过程了。</p>
<p>这一步，我们就通过<code>getEntry</code>方法获得了一个<code>key</code>为<code>entryName</code>,<code>value</code>为<code>entryAbsolutePath</code>的对象了，接来下就让我们从入口文件出发进行编译流程吧。</p>
<h2> 模块编译阶段</h2>
<p>上边我们讲述了关于编译阶段的准备工作:</p>
<ul>
<li>目录/文件基础逻辑补充。</li>
<li>通过<code>hooks.tap</code>注册<code>webpack</code>插件。</li>
<li><code>getEntry</code>方法获得各个入口的对象。</li>
</ul>
<p>接下来让我们继续完善<code>compiler.js</code>。</p>
<p>在模块编译阶段，我们需要做的事件:</p>
<ul>
<li>根据入口文件路径，分析入口文件，对于入口文件进行匹配对应的<code>loader</code>进行处理入口文件。</li>
<li>将<code>loader</code>处理完成的入口文件使用<code>webpack</code>进行编译。</li>
<li>分析入口文件依赖，重复上边两个步骤编译对应依赖。</li>
<li>如果嵌套文件存在依赖文件，递归调用依赖模块进行编译。</li>
<li>递归编译完成后，组装一个个包含多个模块的<code>chunk</code></li>
</ul>
<p>首先，我们先来给<code>compiler.js</code>的构造函数中补充一下对应的逻辑:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们通过给<code>compiler</code>构造函数中添加一些列属性来保存关于编译阶段生成的对应资源/模块对象。</p>
<blockquote>
<p>关于<code>entries\modules\chunks\assets\files</code>这几个<code>Set</code>对象是贯穿我们核心打包流程的属性，它们各自用来储存编译阶段不同的资源，从而最终通过对应的属性进行生成编译后的文件。</p>
</blockquote>
<h3> 根据入口文件路径分析入口文件</h3>
<p>上边说到我们在<code>run</code>方法中已经可以通过<code>this.getEntry();</code>获得对应的入口对象了～</p>
<p>接下来就让我们从入口文件开始去分析入口文件吧！</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们添加了一个名为<code>buildEntryModule</code>方法作为入口模块编译方法。循环入口对象，得到每一个入口对象的名称和路径。</p>
<blockquote>
<p>假使我们在开头传入<code>entry:{ main:'./src/main.js' }</code>的话，<code>buildEntryModule</code>获得的形参<code>entry</code>为<code>{ main: "/src...[你的绝对路径]" }</code>，此时我们<code>buildModule</code>方法接受的<code>entryName</code>为<code>main</code>，<code>entryPath</code>为入口文件<code>main</code>对应的的绝对路径。单个入口编译完成后，我们会在<code>buildModule</code>方法中返回一个对象。这个对象就是我们编译入口文件后的对象。</p>
</blockquote>
<h3> buildModule模块编译方法</h3>
<p>在进行代码编写之前，我们先来梳理一下<code>buildModule</code>方法它需要做哪些事情:</p>
<ul>
<li><code>buildModule</code>接受两个参数进行模块编译，<strong>第一个为模块所属的入口文件名称</strong>，第二个为需要编译的模块路径。</li>
<li><code>buildModule</code>方法要进行代码编译的前提就是，通过<code>fs</code>模块根据入口文件路径读取文件源代码。</li>
<li>读取文件内容之后，调用所有匹配的loader对模块进行处理得到返回后的结果。</li>
<li>得到<code>loader</code>处理后的结果，通过<code>babel</code>分析<code>loader</code>处理后的代码，进行代码编译。(这一步编译主要是针对<code>require</code>语句，修改源代码中<code>require</code>语句的路径)。</li>
<li>如果该入口文件没有依赖与任何模块(<code>require</code>语句)，那么返回编译后的模块对象。</li>
<li>如果该入口文件存在依赖的模块，递归<code>buildModule</code>方法进行模块编译。</li>
</ul>
<h4> 读取文件内容</h4>
<p>我们先调用<code>fs</code>模块读取文件内容。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 调用<code>loader</code>处理匹配后缀文件</h4>
<p>​	接下来我们获得了文件的具体内容之后，就需要匹配对应<code>loader</code>对我们的源代码进行编译了。</p>
<h5> 实现简单自定义loader</h5>
<p>在进行<code>loader</code>编译前，先来实现一下上方传入的自定义<code>loader</code>吧。<code>webpack-demo/loader</code>目录下新建<code>loader1.js</code>,<code>loader2.js</code>:</p>
<p>首先我们需要清楚<strong>简单来说<code>loader</code>本质上就是一个函数，接受我们的源代码作为入参同时返回处理后的结果。</strong></p>
<blockquote>
<p>因为文章主要讲述打包流程所以<code>loader</code>简单的作为倒序处理。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 使用loader处理文件</h5>
<p>搞清楚了<code>loader</code>就是一个单纯的函数之后，让我们在进行模块分析之前将内容先交给匹配的loader去处理下吧。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里通过<code>handleLoader</code>函数，对于传入的文件路径匹配到对应后缀的<code>loader</code>后，依次倒序执行loader处理代码<code>this.moduleCode</code>并且同步更新每次<code>moduleCode</code>。</p>
<p>最终，在每一个模块编译中<code>this.moduleCode</code>都会经过对应的<code>loader</code>处理。</p>
<h4> webpack模块编译阶段</h4>
<p>上一步经历过<code>loader</code>处理了入口文件代码，并且得到了处理后的代码保存在了<code>this.moduleCode</code>中。</p>
<p>此时，经过<code>loader</code>处理后就要进入<code>webpack</code>内部的编译阶段了。</p>
<p>这里我们需要做的是：<strong>针对当前模块进行编译，将当前模块所有依赖的模块(<code>require()</code>)语句引入的路径变为相对于跟路径(<code>this.rootPath</code>)的相对路径</strong>。</p>
<blockquote>
<p>总之需要搞明白的是，这里编译的结果是期望将源代码中的依赖模块路径变为相对跟路径的路径，同时建立基础的模块依赖关系。后续会说明为什么针对路径进行编译。</p>
</blockquote>
<p>继续来完善<code>buildModule</code>方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一步关于<code>webpack</code>编译的阶段就完成了。</p>
<p>需要注意的是:</p>
<ul>
<li>
<p>这里使用<code>babel</code>相关的<code>API</code>针对于<code>require</code>语句进行了编译。</p>
</li>
<li>
<p>同时代码中引用了一个<code>tryExtensions()</code>工具方法，这个方法是针对于后缀名不全的工具方法，稍后你就可以看到这个方法的具体内容。</p>
</li>
<li>
<p>针对于每一次文件编译，我们都会返回一个<strong>module</strong>对象，这个对象是重中之重。</p>
</li>
<li>
<ul>
<li><code>id</code>属性，表示当前模块针对于<code>this.rootPath</code>的相对目录。</li>
<li><code>dependencies</code>属性，它是一个<code>Set</code>内部保存了该模块依赖的所有模块的模块ID。</li>
<li><code>name</code>属性,它表示该模块属于哪个入口文件。</li>
<li><code>_source</code>属性，它存放模块自身经过<code>babel</code>编译后的字符串代码。</li>
</ul>
</li>
</ul>
<h5> tryExtensions方法实现</h5>
<p>在上文的<code>webpack.config.js</code>有这么一个配置：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>熟悉<code>webpack</code>配置可能清楚，<strong>resolve.extensions</strong>是针对于引入依赖时，在没有书写文件后缀的情况下，<code>webpack</code>会自动帮我们按照传入的规则为文件添加后缀。</p>
<p>在清楚了原理后我们来一起看看<code>utils/tryExtensions</code>方法的实现:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法很简单，我们通过<code>fs.existsSync</code>检查传入文件结合<code>extensions</code>依次遍历寻找对应匹配的路径是否存在，如果找到则直接返回。如果未找到则给予用于一个友好的提示错误。</p>
<blockquote>
<p>需要注意 <code>extensions.unshift('');</code>是防止用户如果已经传入了后缀时，我们优先尝试直接寻找，如果可以找到文件那么就直接返回。找不到的情况下才会依次尝试。</p>
</blockquote>
<h4> 递归处理</h4>
<p>经过上一步处理，针对入口文件我们调用<code>buildModule</code>可以得到这样的返回对象。</p>
<p>我们先来看看运行<code>webpack/core/index.js</code>得到的返回结果吧。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我在<code>buildEntryModule</code>中打印了处理完成后的<code>entries</code>对象。可以看到正如我们之前所期待的:</p>
<ul>
<li><code>id</code>为每个模块相对于跟路径的模块.(这里我们配置的<code>context:process.cwd()</code>)为<code>webpack</code>目录。</li>
<li><code>dependencies</code>为该模块内部依赖的模块，这里目前还没有添加。</li>
<li><code>name</code>为该模块所属的入口文件名称。</li>
<li><code>_source</code>为该模块编译后的源代码。</li>
</ul>
<p>此时打开<code>src</code>目录为入口文件添加一些依赖和内容吧:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时让我们重新运行<code>webpack-demo/core/index.js</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>OK，目前为止针对于<code>entry</code>的编译可以暂时告一段落了。</p>
<p><strong>总之也就是，这一步通过方法将<code>entry</code>进行分析编译后得到一个对象。将这个对象添加到<code>this.entries</code>中去。</strong></p>
<p>接下来去处理依赖的模块。</p>
<p>其实对于依赖的模块无非也是相同的步骤：</p>
<ul>
<li>检查入口文件中是否存在依赖。</li>
<li>存在依赖的话，递归调用<code>buildModule</code>方法编译模块。传入<code>moduleName</code>为当前模块所属的入口文件。<code>modulePath</code>为当前被依赖模块的绝对路径。</li>
<li>同理检查递归检查被依赖的模块内部是否仍然存在依赖，存在的话递归依赖进行模块编译。这是一个<strong>深度优先</strong>的过程。</li>
<li>将每一个编译后的模块保存进入<code>this.modules</code>中去。</li>
</ul>
<p>接下来只要稍稍在<code>handleWebpackCompiler</code>方法中稍稍改动就可以了:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里对于依赖的模块进行了递归调用<code>buildModule</code>,将输出的模块对象添加进入了<code>this.modules</code>中去。</p>
<p>此时让重新运行<code>webpack/core/index.js</code>进行编译，这里在<code>buildEntryModule</code>编译结束后打印了<code>assets</code>和<code>modules</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到已经将<code>demo.js</code>这个依赖如愿以偿加入到<code>modules</code>中了，同时它也经过<code>loader</code>的处理。但是我们发现它被重复加入了两次。</p>
<p>这是因为<strong>demo.js</strong>这个模块被引用了两次，它被<code>entry1</code>和<code>entry2</code>都已进行了依赖，在进行递归编译时进行了两次<code>buildModule</code>相同模块。</p>
<p>那么来处理下这个问题：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里在每一次代码分析的依赖转化中，首先判断<code>this.module</code>对象是否已经存在当前模块了（通过唯一的模块id路径判断）。</p>
<p>如果不存在则添加进入依赖中进行编译，如果该模块已经存在过了就证明这个模块已经被编译过了。所以此时不需要将它再次进行编译，仅仅需要更新这个模块所属的chunk，为它的<code>name</code>属性添加当前所属的<code>chunk</code>名称。</p>
<p>重新运行，再来看看打印结果:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时针对“模块编译阶段”基本已经结束了，这一步对于所有模块从入口文件开始进行分析。</p>
<ul>
<li>从入口出发，读取入口文件内容调用匹配<code>loader</code>处理入口文件。</li>
<li>通过<code>babel</code>分析依赖，并且同时将所有依赖的路径更换为相对于项目启动目录<code>options.context</code>的路径。</li>
<li>入口文件中如果存在依赖的话，递归上述步骤编译依赖模块。</li>
<li>将每个依赖的模块编译后的对象加入<code>this.modules</code>。</li>
<li>将每个入口文件编译后的对象加入<code>this.entries</code>。</li>
</ul>
<h2> 编译完成阶段</h2>
<p>在上一步完成了模块之间的编译，并且为<code>module</code>和<code>entry</code>分别填充了内容。</p>
<p>在将所有模块递归编译完成后，需要<strong>根据上述的依赖关系，组合最终输出的<code>chunk</code>模块</strong>。</p>
<p>继续改造我们的<code>Compiler</code>吧:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里，根据对应的入口文件通过每一个模块(<code>module</code>)的<code>name</code>属性查找对应入口的所有依赖文件。</p>
<p>先来看看<code>this.chunks</code>最终会输出什么:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这一步，<strong>得到了<code>Webpack</code>中最终输出的两个<code>chunk</code></strong>。</p>
<p>它们分别拥有:</p>
<ul>
<li><code>name</code>:当前入口文件的名称</li>
<li><code>entryModule</code>: 入口文件编译后的对象。</li>
<li><code>modules</code>: 该入口文件依赖的所有模块对象组成的数组，其中每一个元素的格式和<code>entryModule</code>是一致的。</li>
</ul>
<p>此时编译完成，拼装<code>chunk</code>的环节就圆满完成。</p>
<h2> 输出文件阶段</h2>
<h3> 分析原始打包输出结果</h3>
<p>这里，我把<code>webpack-demo/core/index.js</code>中做了如下修改:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>运用原本的<code>webpack</code>代替自己实现的<code>webpack</code>先进行一次打包。</p>
<p>运行<code>webpack-demo/core/index.js</code>后，我们会在<code>webpack-demo/src/build</code>中得到两个文件:<code>main.js</code>和<code>second.js</code>，以其中一个<code>main.js</code>来看看它的内容:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来稍微分析一下原始打包生成的代码：</p>
<p><code>webpack</code>打包后的代码内部定义了一个<code>__webpack_require__</code>的函数代替了<code>NodeJs</code>内部的<code>require</code>方法。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这块代码相比大家都很熟悉吧，这就是自己编译后的入口文件代码。同时顶部的代码是该入口文件依赖的所有模块定义的一个对象:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里定义了一个<code>__webpack__modules</code>的对象，对象的<code>key</code>为该依赖模块相对于跟路径的相对路径，对象的<code>value</code>该依赖模块编译后的代码。</p>
<h3> 输出文件阶段</h3>
<p>接下里在分析完<code>webpack</code>原始打包后的代码之后，来继续上一步。通过<code>this.chunks</code>来尝试输出最终的效果吧。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>buildEntryModule</code>模块编译完成之后，通过<code>this.exportFile</code>方法实现导出文件的逻辑。</p>
<p>来一起看看<code>this.exportFile</code>方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>exportFile</code>做了如下几件事:</p>
<ul>
<li>首先获取配置参数的输出配置，迭代我们的<code>this.chunks</code>，将<code>output.filename</code>中的<code>[name]</code>替换称为对应的入口文件名称。同时根据<code>chunks</code>的内容为<code>this.assets</code>中添加需要打包生成的文件名和文件内容。</li>
<li>将文件写入磁盘前调用<code>plugin</code>的<code>emit</code>钩子函数。</li>
<li>判断<code>output.path</code>文件夹是否存在，如果不存在，则通过<code>fs</code>新建这个文件夹。</li>
<li>将本次打包生成的所有文件名(<code>this.assets</code>的<code>key</code>值组成的数组)存放进入<code>files</code>中去。</li>
<li>循环<code>this.assets</code>，将文件依次写入对应的磁盘中去。</li>
<li>所有打包流程结束，触发<code>webpack</code>插件的<code>done</code>钩子。</li>
<li>同时为<code>NodeJs Webpack APi</code>呼应，调用<code>run</code>方法中外部传入的<code>callback</code>传入两个参数。</li>
</ul>
<p>总的来说，<code>this.assets</code>做的事情也比较简单，就是通过分析<code>chunks</code>得到<code>assets</code>然后输出对应的代码到磁盘中。</p>
<p>仔细看过上边代码，会发现<code>this.assets</code>这个<code>Map</code>中每一个元素的<code>value</code>是通过调用<code>getSourceCode(chunk)</code>方法来生成模块对应的代码的。</p>
<p>那么<code>getSourceCode</code>这个方法是如何根据<code>chunk</code>来生成最终编译后的代码呢？一起来看看吧！</p>
<h3> <code>getSourceCode</code>方法</h3>
<p>首先简单明确一下这个方法的职责，需要<code>getSourceCode</code>方法接受传入的<code>chunk</code>对象。从而返回该<code>chunk</code>的源代码。</p>
<p>废话不多说，其实这里用了一个比较偷懒的办法，但是完全不妨碍理解<code>Webpack</code>流程，上边分析过原本<code>webpack</code>打包后的代码<strong>仅仅只有入口文件和模块依赖是每次打包不同的地方，关于<code>require</code>方法之类都是相通的</strong>。</p>
<p>把握每次的不同点，直接先来看看它的实现方式:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码其实非常简单，远远没有想象难！有点返璞归真的感觉是吗哈哈。</p>
<p>在<code>getSourceCode</code>方法中，通过组合而来的<code>chunk</code>获得对应的:</p>
<ul>
<li><code>name</code>: 该入口文件对应输出文件的名称。</li>
<li><code>entryModule</code>: 存放该入口文件编译后的对象。</li>
<li><code>modules</code>:存放该入口文件依赖的所有模块的对象。</li>
</ul>
<p><strong>通过字符串拼接的方式去实现了<code>__webpack__modules</code>对象上的属性，同时也在底部通过<code>${entryModule._source}</code>拼接出入口文件的代码。</strong></p>
<blockquote>
<p>上文提到过为什么要将模块的<code>require</code>方法的路径转化为相对于跟路径(<code>context</code>)的路径，看到这里相信大家都已经了然于胸了。因为最终实现的<code>__webpack_require__</code>方法全都是针对于模块相对于跟路径的相对路径实现的<code>require</code>方法。同时如果不太清楚<code>require</code>方法是如何转成为<code>__webpack_require__</code>方法，可以重新回到编译环节重新阅读～通过<code>babel</code>在<code>AST</code>转化阶段将<code>require</code>方法调用变成了<code>__webpack_require__</code>。</p>
</blockquote>
<h1> 大功告成</h1>
<p>至此，让我们回到<code>webpack-demo/core/index.js</code>中去。重新运行这个文件，你会发现<code>webpack-demo/example</code>目录下会多出一个<code>build</code>目录。</p>
<p>到这实现属于我们自己的<code>webpack</code>。</p>
<p>实质上，对于实现一个简单版的<code>webpack</code>核心，还是希望大家可以在理解它的工作流的同时彻底理解<code>compiler</code>这个对象。</p>
<p>在之后的关于<code>webpack</code>相关底层开发中，真正做到对于<code>compiler</code>的用法了然于胸。了解<code>compiler</code>上的各种属性是如何影响到编译打包结果的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Canvas 入门</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Draw/Canvas/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Draw/Canvas/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Canvas 入门</source>
      <description>Canvas 是什么？ Canvas 中文名叫 画布，是 HTML5 新增的一个标签。 Canvas 允许开发者通过JS在这个标签上绘制各种图案。 Canvas 拥有多种绘制路径、矩形、圆形、字符以及图片的方法。 Canvas 在某些情况下可以 代替 图片。 Canvas 可用于动画、游戏、数据可视化、图片编辑器、实时视频处理等领域。 Canvas 和 SVG 的区别</description>
      <category>Canvas</category>
      <pubDate>Mon, 25 Jul 2022 16:17:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Canvas 是什么？</h2>
<blockquote>
<p>Canvas 中文名叫 <code>画布</code>，是 HTML5 <code>新增</code>的一个<code>标签</code>。</p>
<p>Canvas 允许开发者通过JS在这个标签上绘制各种图案。</p>
<p>Canvas 拥有多种绘制路径、矩形、圆形、字符以及图片的方法。</p>
<p>Canvas 在某些情况下可以 <code>代替</code> 图片。</p>
<p>Canvas 可用于动画、游戏、数据可视化、图片编辑器、实时视频处理等领域。</p>
</blockquote>
<h3> Canvas 和 SVG 的区别</h3>
<table>
<thead>
<tr>
<th>Canvas</th>
<th>SVG</th>
</tr>
</thead>
<tbody>
<tr>
<td>用<code>JS</code>动态生成元素（一个HTML元素）</td>
<td>用<code>XML</code>描述元素（类似HTML元素那样，可用多个元素来描述一个图形）</td>
</tr>
<tr>
<td>位图（受屏幕分辨率影响）</td>
<td>矢量图（不受屏幕分辨率影响）</td>
</tr>
<tr>
<td>不支持事件</td>
<td>支持事件</td>
</tr>
<tr>
<td>数据发生变化需要重绘</td>
<td>不需要重绘</td>
</tr>
</tbody>
</table>
<p>上面的描述可能有点难懂，可以打开 <code>AntV</code> 旗下的<code>图形编辑引擎</code>做对比。<code>G6</code> 是使用 canvas 开发的，<code>X6</code> 是使用 svg 开发的。</p>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>如果要展示的<code>数据量比较大</code>，比如一条数据就是一个元素节点，那使用 canvas 会比较合适；如果用户操作的<code>交互比较多</code>，而且对<code>清晰度</code>有要求（矢量图），那么使用 svg 会比较合适。</p>
</div>
<h2> 起步 - 画条直线</h2>
<ul>
<li>在 HTML 中创建 canvas 元素</li>
<li>通过 js 获取 canvas 标签</li>
<li>从 canvas 标签中获取到绘图工具</li>
<li>通过绘图工具，在 canvas 标签上绘制图形</li>
</ul>

<h3> 默认<code>宽高</code></h3>
<p>canvas 有 <code>默认</code>的 <code>宽度(300px)</code> 和 <code>高度(150px)</code></p>
<p>如果不在 canvas 上设置宽高，那 canvas 元素的默认宽度是300px，默认高度是150px。</p>
<h3> 设置 canvas 宽高</h3>
<p>canvas 元素提供了 <code>width</code> 和 <code>height</code> 两个属性，可设置它的宽高。</p>
<p>需要注意的是，这两个属性只需传入数值，不需要传入单位（比如 px 等）。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 不能通过 <code>CSS</code> 设置画布的宽高</h3>
<p>使用 css 设置 canvas 的宽高，会出现 <code>内容被拉伸</code> 的后果！！！ canvas 的默认宽度是<code>300px</code>，默认高度是<code>150px</code>。</p>
<p>如果使用 css 修改 canvas 的宽高（比如变成 400px * 400px），那宽度就由 <code>300px 拉伸到 400px</code>，高度由 <code>150px 拉伸到 400px</code>。使用 <code>js</code> 获取 canvas 的宽高，此时返回的是 canvas 的<code>默认值</code>。最后出现的效果如下所示。</p>

<h3> <code>线条</code>默认<code>宽度</code>和<code>颜色</code></h3>
<p>线条的默认宽度是 <code>1px</code> ，默认颜色是 <code>黑色</code>。</p>
<p>但由于默认情况下 canvas 会将线条的<code>中心点</code>和<code>像素的底部</code>对齐，所以会导致显示效果是 <code>2px</code> 和<code>非纯黑色</code>问题。</p>
<ul>
<li>IE兼容性高</li>
</ul>
<p>暂时只有 <code>IE 9</code> 以上才支持 canvas 。</p>
<p>如需兼容 IE 7 和 8 ，可以使用 <code>ExplorerCanvas</code> 。但即使是使用了 ExplorerCanvas 仍然会有所限制，比如无法使用 <code>fillText()</code> 方法等。</p>
<h2> 基础图形</h2>
<h3> 坐标系</h3>
<p>在绘制基础图形之前，需要先搞清楚 Canvas 使用的坐标系。</p>
<p>Canvas 使用的是 W3C 坐标系 ，也就是遵循我们屏幕、报纸的阅读习惯，<code>从上往下，从左往右</code>。</p>

<p>W3C 坐标系 和 数学直角坐标系 的 <code>X轴</code> 是<code>一样的</code>，只是 <code>Y轴</code> 的<code>方向相反</code>。</p>
<h3> 直线</h3>
<p>最简单的起步方式是画一条直线。这里所说的 <code>直线</code> 是几何学里的 <code>线段</code> 的意思。</p>
<p>需要用到这3个方法：</p>
<ul>
<li>moveTo(x1, y1)：起点坐标 (x, y)</li>
<li>lineTo(x2, y2)：下一个点的坐标 (x, y)</li>
<li>stroke()：将所有坐标用一条线连起来</li>
</ul>

<h3> 多条直线</h3>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>仔细观察一下，为什么两条线的粗细不一样的？</p>
</div>
<p>明明使用的方法都是一样的，只是第二条直线的 <code>Y轴</code> 的值是有<code>小数点</code>。</p>

<p>线的<code>中心点</code>会和<code>画布像素点</code>的底部对齐，所以会线<code>中间是黑色</code>的，但由于<code>一个像素不能再切割</code>了，所以会有<code>半个像素</code>被<code>染色</code>，就变成了<code>浅灰色</code>。</p>
<h4> 样式</h4>
<ul>
<li>lineWidth：线的粗细</li>
<li>strokeStyle：线的颜色</li>
<li>lineCap：线帽：默认: butt; 圆形: round; 方形: square</li>
</ul>

<h4> 新开路径</h4>
<p>开辟新路径的方法：<code>beginPath()</code></p>
<p>在绘制<code>多条线段</code>的同时，还要设置线段<code>样式</code>，通常需要<code>开辟新路径</code>，要不然<code>样式</code>之间会<code>相互污染</code>。</p>

<p>如果不想相互污染，需要做<code>2件事</code>：</p>
<ul>
<li>使用 <code>beginPath()</code> 方法，重新开一个路径</li>
<li>设置<code>新线段的样式</code>（必须项）</li>
</ul>
<p><code>如果上面2步缺了其中1步都会有影响。</code></p>
<h5> 使用 beginPath() 同时 不设置样式</h5>

<p>第一条线的<code>样式</code>会<code>影响之后的线</code>。</p>
<p>但如果使用了 <code>beginPath()</code> ，后面的线段不会影响前面的线段。</p>
<h5> 使用 beginPath() 同时 设置样式</h5>

<h5> 不使用 beginPath() 同时 设置样式</h5>

<h3> 折线</h3>
<p>和 <code>直线</code> 差不多，都是使用 <code>moveTo()</code> 、<code>lineTo()</code> 和 <code>stroke()</code> 方法可以<code>绘制折线</code>。</p>

<h3> 矩形</h3>
<p>根据前面的基础，我们可以 使用<code>线段</code>来<code>描绘矩形</code>，但 canvas 也提供了 <code>rect()</code> 等方法可以直接生成矩形。</p>
<h4> 线段描绘矩形</h4>

<h4> strokeRect() 描边矩形</h4>
<ul>
<li>strokeStyle：设置描边的属性（<code>颜色</code>、<code>渐变</code>、<code>图案</code>）</li>
<li>strokeRect(x, y, width, height)：描边矩形（x和y是矩形<code>左上角起点</code>；<code>width</code> 和 <code>height</code> 是矩形的<code>宽高</code>）</li>
<li>strokeStyle 必须写在 strokeRect() 前面，不然样式不生效。</li>
</ul>

<h4> fillRect() 填充矩形</h4>
<p><code>fillRect()</code> 和 <code>strokeRect()</code> 方法差不多，但 fillRect() 的作用是<code>填充</code>。</p>
<p>需要注意的是，<code>fillStyle</code> 必须写在 <code>fillRect()</code> <code>之前</code>，不然样式不生效。</p>

<h4> strokeRect() 和 fillRect()</h4>
<p>会产生<code>描边</code>和<code>填充</code>的效果</p>

<h4> rect() 生成矩形</h4>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p><code>rect()</code> 和 <code>fillRect()</code> 、<code>strokeRect()</code> 的用法差不多，唯一的<code>区别</code>是：</p>
<p>strokeRect() 和 fillRect() 这两个方法调用后会<code>立即绘制</code>；</p>
<p><code>rect()</code> 方法被调用后，<code>不会立刻绘制矩形</code>，而是需要调用 <code>stroke()</code> 或 <code>fill()</code> 辅助渲染。</p>
</div>

<p>等价公式：</p>
<div class="language-JavaScript line-numbers-mode" data-ext="JavaScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> clearRect() 清空矩形</h4>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>canvas 画布元素是矩形，所以可以通过下面的代码把整个<code>画布清空</code>掉。</p>
<p>要清空的区域：从画布<code>左上角</code>开始，直到画布的<code>宽</code>和画布的<code>高</code>为止。</p>
<div class="language-JavaScript line-numbers-mode" data-ext="JavaScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<h3> 多边形</h3>
<p>Canvas 要画多边形，需要使用 <code>moveTo()</code> 、 <code>lineTo()</code> 和 <code>closePath()</code> 。</p>
<h3> 三角形</h3>
<p>虽然三角形是常见图形，但 canvas 并<code>没有</code>提供类似 <code>rect()</code> 的方法来绘制<code>三角形</code>。</p>
<p>需要确定三角形<code>3个点</code>的<code>坐标位置</code>，然后使用 <code>stroke()</code> 或者 <code>fill()</code> 方法生成三角形。</p>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>默认情况下<code>不会自动</code>从最后一个<code>点</code>连接到<code>起点</code>。最后一步需要设置一下 <code>cxt.lineTo(50, 50)</code> ，让它与 <code>cxt.moveTo(50, 50)</code> 一样。这样可以让路径<code>回到起点</code>，形成一个<code>闭合</code>效果。</p>
<p>但这样做其实是有点问题的，而且也比较麻烦，要记住起始点坐标。</p>
</div>
<h4> lineWidth 和 lineJoin</h4>
<p>上面的闭合操作，如果遇到设置了 <code>lineWidth</code> 或者 <code>lineJoin</code> 就会有问题：当线段变粗后，起始点和结束点的链接处，拐角就出现<code>不正常</code>现象。</p>
<p>如果需要真正闭合，可以使用 <code>closePath()</code> 方法自动将<code>终点</code>和<code>起始点</code>连接起来，此时看上去就正常多了。比如：</p>

<h3> 菱形</h3>

<h3> 圆形</h3>
<p>绘制圆形的方法是 <code>arc(x, y, r, sAngle, eAngle，counterclockwise)</code>。</p>
<ul>
<li>x 和 y: <code>圆心</code>坐标</li>
<li>r: 半径</li>
<li>sAngle: 开始角度</li>
<li>eAngle: 结束角度</li>
<li>counterclockwise: 绘制方向（true: 逆时针; false: 顺时针），默认 <code>false</code></li>
</ul>
<p>开始角度和结束角度，都是以<code>弧度</code>为<code>单位</code>。例如 <code>180°</code>就写成 <code>Math.PI</code> ，<code>360°</code>写成 <code>Math.PI * 2</code> ，以此类推。</p>
<blockquote>
<p>在实际开发中，为了更容易看懂弧度的<code>数值</code>，<code>1°</code>应该写成 <code>Math.PI / 180</code></p>
<p>100°: <code>100 * Math.PI / 180</code></p>
<p>110°: <code>110 * Math.PI / 180</code></p>
<p>241°: <code>241 * Math.PI / 180</code></p>
<p>注意：绘制圆形之前，<code>必须</code>先调用 <code>beginPath()</code> 方法！！！在绘制<code>完成</code>之后，还需要调用 <code>closePath()</code> 方法！！！</p>
</blockquote>

<h3> 半圆</h3>
<p>如果使用 <code>arc()</code> 方法画圆时，没做到刚好绕完一周（360°）就直接闭合路径，就会出现<code>半圆</code>的状态。</p>

<p>cxt.arc 最后一个参数没传，默认是 <code>false</code> ，所以是<code>顺时针</code>绘制。如果希望半圆的弧面在<code>上方</code>，可以将 cxt.arc 最后一个参数设置成 <code>true</code>。</p>

<h3> 弧线</h3>
<p>使用 arc() 方法画半圆时，如果最后<code>不调用closePath()</code>方法，就不会出现闭合路径。也就是说，那是一条<code>弧线</code>。</p>
<p>在 canvas 中，画弧线有2中方法：<code>arc()</code> 和 <code>arcTo()</code>。</p>
<h4> arc()</h4>
<p>如果想画一条 <code>0° ~ 30°</code> 的弧线，可以这样写</p>

<h4> arcTo()</h4>
<p><code>arcTo(cx, cy, x2, y2, radius)</code></p>
<ul>
<li>cx: 两切线交点的横坐标</li>
<li>cy: 两切线交点的纵坐标</li>
<li>x2: 结束点的横坐标</li>
<li>y2: 结束点的纵坐标</li>
<li>radius: 半径</li>
</ul>
<p>其中，<code>(cx, cy)</code> 也叫<code>控制点</code>，<code>(x2, y2)</code> 也叫<code>结束点</code>。</p>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
</div>

<h2> 基础样式</h2>
<h3> stroke() 描边</h3>
<p>前面的案例中，其实已经知道使用 <code>stroke()</code> 方法进行描边了。这里就不再赘述。</p>
<h3> lineWidth 线条宽度</h3>
<p>lineWidth 默认值是 <code>1</code> ，默认单位是 <code>px</code>。</p>

<h3> strokeStyle 线条颜色</h3>

<h3> lineCap 线帽</h3>
<p>线帽指的是线段的<code>开始</code>和<code>结尾处</code>的样式，使用 <code>lineCap</code> 可以设置</p>
<p>属性值包括：</p>
<ul>
<li>butt: 默认值，无线帽</li>
<li>square: 方形线帽</li>
<li>round: 圆形线帽</li>
</ul>

<p>使用 <code>square</code> 和 <code>round</code> 的话，会使线条变得<code>稍微长一点点</code>，这是给线条<code>增加线帽</code>的部分，日常开发中<code>需要注意</code>。</p>
<p>线帽只对线条的<code>开始</code>和<code>结尾</code>处产生作用，对拐角不会产生任何作用。</p>
<h3> lineJoin 拐角样式</h3>
<p>属性值包括：</p>
<ul>
<li>miter: 默认值，尖角</li>
<li>round: 圆角</li>
<li>bevel: 斜角</li>
</ul>

<h3> setLineDash() 虚线</h3>
<p>虚线分3种情况:</p>
<ul>
<li>只传1个值</li>
<li>有2个值</li>
<li>有3个以上的值</li>
</ul>

<p>此外:</p>
<p><code>cxt.getLineDash()</code> 获取虚线不重复的距离；</p>
<p><code>cxt.lineDashOffset</code> 设置虚线的偏移位。</p>
<h3> fill 填充</h3>

<p>可以使用 fillStyle 设置填充颜色，默认是<code>黑色</code>。</p>
<h4> 非零环绕填充</h4>
<p>在使用 fill() 方法填充时，需要注意一个规则：非零环绕填充。</p>
<p>在使用 moveTo 和 lineTo 描述图形时，如果是按<code>顺时针绘制</code>，计数器会<code>加1</code>；如果是<code>逆时针</code>，计数器会<code>减1</code>。</p>
<p>当图形所处的位置，计数器的<code>结果为0</code>时，它就<code>不会</code>被<code>填充</code>。</p>

<p>请看看上面的代码，画了<code>2个矩形</code>，它们都没有用 <code>beginPath()</code> 方法开辟新路径。</p>
<p>内层矩形是<code>逆时针绘制</code>的，所以内层的值是 <code>-1</code> 。外层矩形是<code>顺时针绘制</code>，所以经过外层时值 <code>+1</code>，最终内层的值为 <code>0</code> ，所以<code>不会被填充</code>。</p>
<h3> 文本</h3>
<h4> font 样式</h4>
<p>和 <code>CSS</code> 设置 <code>font</code> 差不多，Canvas 也可以通过 <code>font</code> 设置<code>样式</code>。</p>
<p>语法：<code>cxt.font = 'font-style font-variant font-weight font-size/line-height font-family'</code></p>
<p>如果需要设置字号 <code>font-size</code>，需要同事设置 <code>font-family</code>。</p>
<p><code>cxt.font = '30px 宋体'</code></p>
<h4> strokeText() 描边</h4>
<p>语法：<code>strokeText(text, x, y, maxWidth)</code></p>
<ul>
<li>text: <code>字符串</code>，要绘制的内容</li>
<li>x: <code>横坐标</code>，文本左边要对齐的坐标（默认<code>左对齐</code>）</li>
<li>y: <code>纵坐标</code>，文本底边要对齐的坐标</li>
<li>maxWidth: 可选参数，表示文本渲染的<code>最大宽度（px</code>），如果文本<code>超出</code> maxWidth 设置的值，文本会被<code>压缩</code>。</li>
</ul>

<h5> strokeStyle 设置描边颜色</h5>

<h4> fillText() 填充</h4>
<p>语法：<code>fillText(text, x, y, maxWidth)</code></p>

<h5> fillStyle 设置填充颜色</h5>

<h4> measureText() 获取文本长度</h4>
<p><code>measureText().width</code> 方法可以获取文本的<code>长度</code>，单位是 <code>px</code> 。</p>

<h4> textAlign 水平对齐方式</h4>
<ul>
<li>start: 默认。在指定位置的<code>横坐标开始</code>。</li>
<li>end: 在指定坐标的<code>横坐标结束</code>。</li>
<li>left: <code>左</code>对齐。</li>
<li>right: <code>右</code>对齐。</li>
<li>center: <code>居中</code>对齐。</li>
</ul>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>从上面的例子看，<code>start</code> 和 <code>left</code> 的效果好像是一样的，<code>end</code> 和 <code>right</code> 也好像是一样的。</p>
<p>在大多数情况下，它们的确一样。</p>
<p>但在某些国家或者某些场合，阅读文字的习惯是 <code>从右往左</code> 时，<code>start</code> 就和 <code>right</code> 一样了，<code>end</code> 和 <code>left</code> 也一样。这是需要注意的地方。</p>
</div>
<h4> textBaseline 垂直对齐方式</h4>
<ul>
<li>alphabetic: 默认。文本基线是普通的<code>字母基线</code>。</li>
<li>top: 文本基线是 em 方框的<code>顶端</code>。</li>
<li>bottom: 文本基线是 em 方框的<code>底端</code>。</li>
<li>middle: 文本基线是 em 方框的<code>正中</code>。</li>
<li>hanging: 文本基线是<code>悬挂基线</code>。</li>
</ul>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>在绘制文字的时候，默认是以文字的左下角作为参考点进行绘制</p>
</div>
<h3> 图片</h3>
<p>在 Canvas 中可以使用 drawImage() 方法绘制图片。</p>
<h4> 渲染图片</h4>
<p>渲染图片的方式有两种，一种是在<code>JS里加载图片</code>再渲染，另一种是把<code>DOM里的图片</code>拿到 <code>canvas</code> 里渲染。</p>
<p>语法：<code>drawImage(image, dx, dy)</code></p>
<ul>
<li>image: 要渲染的图片对象。</li>
<li>dx: 图片左上角的横坐标位置。</li>
<li>dy: 图片左上角的纵坐标位置。</li>
</ul>
<h5> JS版</h5>
<p>在 JS 里加载图片并渲染，有以下几个步骤：</p>
<ol>
<li>创建 Image 对象</li>
<li>引入图片</li>
<li>等待图片加载完成</li>
<li>使用 drawImage() 方法渲染图片</li>
</ol>

<h5> DOM版</h5>

<p>因为图片是从 <code>DOM</code> 里获取到的，所以一般来说，只要在 <code>window.onload</code> 这个生命周期内使用 <code>drawImage</code> 都可以<code>正常渲染</code>图片。前提是dom元素图片<code>加载完成</code>。</p>
<h4> 设置图片宽高</h4>
<p>前面的例子都是直接加载图片，图片<code>默认</code>的宽高是多少就加载多少。</p>
<p>如果需要指定图片宽高，可以在前面的基础上再添加两个参数：</p>
<p><code>drawImage(image, dx, dy, dw, dh)</code></p>

<h4> 截取图片</h4>
<p>截图图片同样使用<code>drawImage()</code> 方法，只不过传入的参数<code>数量</code>比之前都<code>多</code>，而且<code>顺序</code>也有点<code>不一样</code>了。</p>
<p><code>drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh)</code></p>
<ul>
<li>image: 图片对象</li>
<li>sx: 开始截取的横坐标</li>
<li>sy: 开始截取的纵坐标</li>
<li>sw: 截取的宽度</li>
<li>sh: 截取的高度</li>
<li>dx: 图片左上角的横坐标位置</li>
<li>dy: 图片左上角的纵坐标位置</li>
<li>dw: 图片宽度</li>
<li>dh: 图片高度</li>
</ul>

]]></content:encoded>
    </item>
    <item>
      <title>Svg 入门</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Draw/Svg/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Draw/Svg/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Svg 入门</source>
      <description>简介 SVG 是 Scalable Vector Graphics 的缩写，意为可缩放矢量图形。于 2003年1月14日 SVG 1.1 被Sun公司（已被Oracle公司收购）、Adobe、苹果公司、IBM 以及柯达共同确立成为W3C推荐标准。 概念 SVG是 Scalable Vector Graphics 的缩写 意为可缩放矢量图形 SVG是一个基于文本的开放网络标准，用来定义用于网络的矢量图形 SVG图像在放大或改变尺寸的情况下其图形质量不会有所损失，因此能够优雅而简洁地渲染不同大小的图形，并和CSS，DOM，JavaScript和SMIL等其他网络标准无缝衔接 SVG 使用 XML 格式定义图形 SVG是万维网联盟的标准与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体</description>
      <category>Svg</category>
      <pubDate>Fri, 19 Aug 2022 11:33:25 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>SVG 是 <code>Scalable Vector Graphics</code> 的缩写，意为<code>可缩放矢量图形</code>。于 2003年1月14日 SVG 1.1 被Sun公司（已被Oracle公司收购）、Adobe、苹果公司、IBM 以及柯达共同确立成为<code>W3C</code>推荐标准。</p>
<h3> 概念</h3>
<ol>
<li>SVG是 <code>Scalable Vector Graphics</code> 的缩写 意为<code>可缩放矢量图形</code></li>
<li>SVG是一个基于<code>文本</code>的<code>开放网络标准</code>，用来定义用于<code>网络</code>的<code>矢量图形</code></li>
<li>SVG图像在<code>放大</code>或<code>改变尺寸</code>的情况下其图形<code>质量不会有所损失</code>，因此能够优雅而简洁地渲染不同大小的图形，并和<code>CSS</code>，<code>DOM</code>，<code>JavaScript</code>和<code>SMIL</code>等其他网络标准无缝衔接</li>
<li>SVG 使用 <code>XML</code> 格式定义图形</li>
<li>SVG是万维网联盟的标准与诸如 <code>DOM</code> 和 <code>XSL</code> 之类的 <code>W3C</code> 标准是一个整体</li>
</ol>
<!-- more -->
<h3> 优势</h3>
<ol>
<li><code>SVG</code> 与 <code>JPEG</code> 和 <code>GIF</code> 图像比起来，<code>尺寸更小</code>，且<code>可压缩性更强</code>。</li>
<li>SVG图像中的文本是<code>可选</code>的，同时也是<code>可搜索</code>的，且可以与 <code>JavaScript</code> 技术一起运行</li>
<li>SVG可在图像<code>质量不下降</code>的情况下被<code>放大</code>和<code>缩小</code></li>
<li>SVG可被非常多的工具<code>读取</code>和<code>修改</code>（比如文本编辑器）</li>
<li>SVG图像<code>不依赖分辨率</code>，可在任何的分辨率下被<code>高质量</code>地打印</li>
<li>SVG文件是纯粹的<code>XML</code></li>
<li>SVG是<code>开放的标准</code></li>
</ol>
<h3> 缺点</h3>
<ol>
<li>SVG<code>复杂度</code>越<code>高</code>渲染速度就会越<code>慢</code>（任何过度使用DOM的应用都不快）</li>
<li>SVG<code>不适合游戏</code>应用，只能结合<code>Canvas</code>来实现</li>
<li>SVG不能动态的<code>修改动画</code>内容</li>
</ol>
<p><strong>PS</strong>: 需要注意的是因为<code>XML</code>和<code>HTML</code>不同，<code>XML</code>是区分大小写的，而<code>SVG</code>是使用<code>XML</code>格式来定义图形，所以在编写SVG的的时候<code>元素</code>和<code>属性</code>必须按<code>标准格式</code>书写。</p>
<h3> 浏览器兼容性</h3>
<p>这里直接放一张 Can I Use 的详细兼容表。</p>

<h2> 语法</h2>
<p>SVG的语法如下：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上面的语法所示，SVG的<code>绘制</code>其实就是一个<code>SVG标签</code>，然后在标签内绘制要绘制的内容，比如上面的语法是在SVG标签中绘制了一个圆形<code>(cx、cy为圆的坐标，r为圆的半径)</code>。</p>
<h3> 属性</h3>
<h4> width、height <code>SVG</code>的<code>宽高</code></h4>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>注意：在<code>不设置</code>宽高的情况下，默认为<code>300 * 150</code>，当<code>内部元素</code>大于<code>300 * 150</code>时，大于部分会被隐藏。</p>
</div>
<p>在坐标为<code>（100， 100）</code>的地方绘制一个<code>半径</code>为<code>100</code>的<code>圆</code></p>

<h4> viewBox 可以<code>显示</code>的<code>区域</code>。</h4>
<p><strong>语法：</strong> <code>viewBox="x y w h"</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为<code>起始点</code></li>
<li>w、h为<code>显示区域</code>的<code>宽高</code></li>
</ul>

<p>如图SVG里面的圆只显示了一部份，原因是<code>viewBox</code>定义了一个：从·点开始，宽高为<code>100 * 100</code>的显示区域。而这个<code>100 * 100</code>的显示区域会放到<code>300 * 300(svg宽高)</code>的SVG中去显示，整体就<code>放大</code>了<code>3</code>倍。</p>
<h4> version 指明SVG的版本</h4>
<p>version属性纯粹就是一个<code>说明</code>，对<code>渲染</code>或<code>处理</code>没有任何影响。且目前只有 <code>1.0</code> 和 <code>1.1</code> 这两个版本。</p>
<p><strong>语法：</strong> <code>version="1.1"</code></p>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>下面是来自维基百科的一些版本信息：</p>
<ul>
<li>版本 1.x</li>
</ul>
<ol>
<li><code>SVG 1.0</code>于 2001 年 9 月 4 日成为 <code>W3C</code> 推荐标准。</li>
<li><code>SVG 1.1</code> 于 2003 年 1 月 14 日成为 <code>W3C</code> 推荐标准。SVG 1.1 规范是<code>模块化</code>的，以便允许将<code>子集</code>定义为<code>配置文件</code>。除此之外，SVG 1.1 和 SVG 1.0 之间几乎没有区别。</li>
<li><code>SVG Tiny</code> 和 <code>SVG Basic</code>（移动 SVG 配置文件）于 2003 年 1 月 14 日成为 <code>W3C</code> 推荐标准。这些被描述为 SVG 1.1 的<code>配置文件</code>。</li>
<li><code>SVG Tiny 1.2</code> 于 2008 年 12 月 22 日成为 <code>W3C</code> 推荐标准。它最初是作为计划中的 <code>SVG Full 1.2</code> 的配置文件（后来被 SVG 2 放弃），但后来被重构为<code>独立规范</code>。它通常得不到很好的支持。</li>
<li><code>SVG 1.1 第二版</code>，包括所有勘误表和说明，但在 2011 年 8 月 16 日发布的原始 <code>SVG 1.1</code> 没有新功能。</li>
<li><code>SVG Tiny 1.2 Portable/Secure</code>，<code>SVG Tiny 1.2</code> 配置文件的<code>更安全</code>子集，于 2020 年 7 月 29 日作为 <code>IETF</code> 草案标准引入。也称为 <code>SVG Tiny P/S</code>。<code>SVG Tiny 1.2 Portable/Secure</code> 是<code>BIMI</code>草案标准的要求。</li>
</ol>
<ul>
<li>版本 2</li>
</ul>
<ol>
<li><code>SVG 2</code> 删除了几个<code>字体元素</code>，例如<code>glyph</code>和altGlyph（由 <code>WOFF</code> 字体格式替换）。</li>
<li>不推荐使用该<code>xml:space</code>属性以支持 CSS。</li>
<li>添加了 <code>HTML5</code> 功能，例如 <code>translate</code> 和 <code>data-*</code> 属性。</li>
<li><code>SVG Tiny 1.2</code> 中的<code>文本处理功能</code>被注释为包含在内，但<code>尚未</code>在文本中<code>正式化</code>。其他一些 <code>1.2</code> 特性是<code>精选</code>的。但 <code>SVG 2</code> 通常 <code>不是</code> <code>SVG tiny 1.2</code> 的<code>超集</code>。</li>
<li><code>SVG 2</code> 于 2016 年 9 月 15 日进入候选推荐阶段，修订版于 2018 年 8 月 7 日和 2018 年 10 月 4 日发布。最新草案于 2022 年 3 月 21 日发布。</li>
</ol>
</div>
<h4> xmlns 和 xmlns:xlink</h4>
<p>上面我们说过SVG使用XML格式定义图形，SVG文件是纯粹的XML文件。</p>
<p>在XML中，<code>标签</code>和<code>属性</code>属于<code>命名空间</code>，这是为了防止来自不同技术的<code>标签</code>和<code>属性</code>发生<code>冲突</code>。</p>
<ul>
<li>案例</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>在<code>SVG</code>中存在<code>a标签</code>，在<code>HTML</code>中也存在<code>a标签</code>，那么怎么区分这个a标签属于哪一种技术，这就需要使用<code>命名空间</code>了。</p>
<p>加入命名空间以后就能知道哪一个是<code>svg:a</code>，哪一个又是<code>html:a</code>，这样就可以区分出不同的<code>标签</code>和<code>属性</code>。</p>
</div>
<h5> xmlns</h5>
<p>xmlns用于声明<code>命名空间</code>（<code>namespace</code>），在此声明之下的所有<code>子标签</code>都属于这个空间内。这里看起来是一个<code>url</code>，但实际上仅仅是一个字符串，这样使用只是惯例。因此很多时候都会被称为 <code>namespace url</code> 而不是 <code>namespace name</code>。</p>
<p>在SVG中加入xmlns时，因为它定义了<code>默认命名空间</code>，因此不需要前缀，直接在SVG标签中写一个a标签，<code>a标签</code>和<code>UA</code>就知道它是SVG的a标签而不是HTML的a标签</p>
<h5> xmlns:xlink</h5>
<p><code>xmlns:xlink</code> 表示前缀为<code>xlink</code>的<code>标签</code>和<code>属性</code>，应该由理解该规范的 <code>UA</code> 使用 <code>xlink</code> 规范 来解释。</p>
<p>注解：UA是<code>User Agent</code>的简称。<code>User Agent</code>是<code>Http</code>协议中的一部分，属于<code>头域</code>的组成部分。通俗地讲<code>UA</code>是一种向<code>访问网站</code>提供你所使用的<code>浏览器类型</code>、<code>操作系统</code>、<code>浏览器内核</code>等信息的<code>标识</code>。通过这个标识，用户所访问的网站可以显示不同的排版，从而为用户提供更好的<code>体验</code>或者进行<code>信息统计</code>。</p>
<h3> 基本图形</h3>
<h4> 圆形（circle）</h4>
<p><strong>语法：</strong> <code>&lt;circle cx="100" cy="100" r="100"/&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>cx</code>、<code>cy</code>为圆的坐标</li>
<li><code>r</code>为圆的半径</li>
</ul>

<h4> 矩形（rect）</h4>
<p><strong>语法：</strong> <code>&lt;rect x="0" y="0" rx="5" ry="5" width="300" height="200"/&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为矩形的起<code>始点坐标</code></li>
<li>rx、ry为圆角x、y轴方向的半径</li>
<li>width、height为矩形的宽高</li>
</ul>

<h4> 椭圆（ellipse）</h4>
<p><code>ellipse</code>标签比<code>circle</code>标签功能更强大，<code>ellipse</code>标签也可以实现<code>圆形</code>的绘制，并且还可以分别缩放圆形的<code>长轴半径</code>和<code>短轴半径</code>，从而达到<code>椭圆</code>的效果。</p>
<p><strong>语法：</strong> <code>&lt;ellipse cx="100" cy="100" rx="100" ry="50"/&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>cx</code>、<code>cy</code>为椭圆的坐标</li>
<li><code>rx</code>为椭圆的x轴半径</li>
<li><code>ry</code>为椭圆的y轴半径</li>
</ul>

<h4> 线条（line）</h4>
<p><strong>语法：</strong> <code>&lt;line x1="10" x2="50" y1="110" y2="150"/&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>x1</code>、<code>y1</code>为<code>起点</code>的坐标</li>
<li><code>x2</code>、<code>y2</code>为<code>终点</code>的坐标</li>
</ul>

<h4> 折线（polyline）</h4>
<p><strong>语法：</strong> <code>&lt;polyline points="0 0, 20 40, 70 80, 100 90, 200 30, 250 50" /&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>points</code>为<code>点集数列</code>，其中每个点都必须包含<code>2个数字</code>，一个是<code>x坐标</code>，一个是<code>y坐标</code>。</li>
</ul>

<h4> 多边形（polygon）</h4>
<p><code>polygon</code>标签和<code>polyline</code>标签类似，都是由很多个点链接在一起的。但不同的是<code>polygon</code>路径中的<code>最后一个点</code>和<code>第一个点</code>是默认闭合的。</p>
<p><strong>语法：</strong> <code>&lt;polygon points="0 0, 20 40, 70 80, 100 90, 200 30, 250 50" /&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>points</code>为<code>点集数列</code>，其中每个点都必须包含<code>2个数字</code>，一个是<code>x坐标</code>，一个是<code>y坐标</code>。</li>
</ul>

<h4> 路径（path）</h4>
<p>path标签是所有图形中最复杂的，但他也是最强大的。在SVG中最常用的图形就是path标签，他可以绘制圆形、椭圆、矩形、线条、折线、多边形、贝塞尔曲线等。</p>
<p><strong>语法：</strong> <code>&lt;path d="M50 50 H 200 V 200 H 50 L 50 50"/&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>d为一个<code>点集数列</code>以及其它<code>绘制路径</code>的<code>信息</code>。</li>
</ul>

<h5> 命令</h5>
<p><code>path标签</code>的图形形状是通过<code>属性d</code>来定义的，属性d的值是以：<code>命令 + 参数</code> 的形式进行组合的，命令又是通过<code>关键字</code>来表示的。</p>
<p>那么究竟有哪些命令呢？总结了一下概括为以下<code>10</code>个命令：</p>
<ul>
<li>M = Move to</li>
<li>L = Line to</li>
<li>H = Horizontal Line to</li>
<li>V = Vertical Line to</li>
<li>Q = Quadratic Bezier Curve to</li>
<li>T = Smooth Quadratic Bezier Curve to</li>
<li>C = Curve to</li>
<li>S = Smooth Curve to</li>
<li>A = Elliptical Arc</li>
<li>Z = close path</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>所有命令中，<code>大写</code>为<code>绝对定位</code>，<code>小写</code>为<code>相对定位</code>。</p>
</div>
<h5> 直线命令</h5>
<h6> M（Move to）</h6>
<p><code>M</code>命令其实就是把画笔<code>移动</code>到<code>某个点</code>，就好像画笔提起来以后移动到一个新的位置准备开始绘制。但因为仅仅是<code>移动</code>画笔而<code>没有绘制</code>，所以M命令经常出现在路径的<code>起始点</code>，用来<code>指明</code>画笔应该从<code>何处</code>开始<code>绘制</code>。</p>
<p>每一段路径都<code>必须</code>以<code>M</code>命令<code>开头</code>，如果有<code>多个</code>M命令则表示<code>新路径</code>的<code>开始</code>。</p>
<p><strong>语法：</strong> M x y 或者 m x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为坐标</li>
</ul>
<h6> L（Line to）</h6>
<p><code>L</code>命令会<code>绘制一点</code>并且和之前的点（也就是L命令<code>前面的点</code>）连成一条<code>直线</code>。</p>
<p><strong>语法：</strong> L x y 或者 l x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为坐标</li>
</ul>

<h6> H（Horizontal Line to）</h6>
<p><code>H</code>命令可以从之前的点绘制一条<code>水平</code>的<code>直线</code>，<code>H</code>命令可以等价于<code>y值</code>和<code>之前点</code>相同的<code>L</code>命令</p>
<p><strong>语法：</strong> H x 或者 h x</p>
<p><strong>参数：</strong></p>
<ul>
<li>x 为X轴坐标</li>
</ul>

<h6> V（Vertical Line to）</h6>
<p><code>V</code>命令可以从之前的点绘制一条<code>垂直</code>的<code>直线</code>，<code>V</code>命令可以等价于<code>x值</code>和<code>之前点</code>相同的<code>L</code>命令</p>
<p><strong>语法：</strong> V y 或者 v y</p>
<p><strong>参数：</strong></p>
<ul>
<li>y 为Y轴坐标</li>
</ul>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>PS：注意连续的<code>H</code>命令和<code>V</code>命令取<code>大值</code></p>
</div>

<h6> Z（Close path）</h6>
<p><code>Z</code>命令是一个<code>闭合命令</code>，会从<code>当前点</code>画一条直线到路径的<code>起始点</code>。<code>Z</code>命令因为<code>没有参数</code>所以<code>Z</code>和<code>z</code>效果一样，所以不区分大小写，</p>
<p><strong>语法：</strong> Z 或者 z</p>

<h5> 曲线命令</h5>
<h6> Q（Quadratic Bezier Curve to）</h6>
<p><code>Q</code>命令可以用来绘制一条<code>二次贝塞尔曲线</code>，<code>二次贝塞尔曲线</code>需要一个<code>控制点</code>，用来确定<code>起点</code>和<code>终点</code>的<code>曲线斜率</code>。</p>
<p><strong>语法：</strong> Q x1 y1, x y 或者 q x1 y1, x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为<code>终点位置</code></li>
<li>x1、y1为<code>控制点</code></li>
</ul>

<h6> T（Smooth Quadratic Bezier Curve to）</h6>
<p><code>T</code>命令是一个 <code>延长</code> <code>二次贝塞尔曲线</code>的简化命令，<code>T</code>命令可以通过<code>前一个控制点</code>推断出<code>后一个控制点</code>，这也就是为什么<code>T</code>命令只需要<code>一个坐标</code>的原因。</p>
<p>需要注意的是<code>T</code>命令的的前面必须有一个<code>Q</code>命令或者其他的<code>T</code>命令。如果<code>T</code>命令单独使用，那么<code>控制点</code>就会被认为和<code>终点</code>是同一个点，所以画出来的将是<code>一条直线</code></p>
<p><strong>语法：</strong> T x y 或者 t x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为终点位置</li>
</ul>

<h6> C（Curve to）</h6>
<p><code>C</code>命令可用来绘制一条<code>三次贝塞尔曲线</code>，相对于<code>二次贝塞尔曲线</code>多了<code>一个控制点</code>。</p>
<p><strong>语法：</strong> C x1 y1, x2 y2, x y 或者 c x1 y1, x2 y2, x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为<code>终点位置</code></li>
<li>x1、y1为曲线<code>起始点</code>的<code>控制点</code></li>
<li>x2、y2为<code>曲线终止</code>的<code>控制点</code>。</li>
</ul>

<h6> S（Smooth Curve to）</h6>
<p><code>三次贝塞尔曲线</code>的<code>S</code>命令和<code>二次贝塞尔曲线</code>的<code>T</code>命令比较相似。<code>S</code>命令也可以用来创建与前面一样的<code>贝塞尔曲线</code>，但如果<code>S</code>命令跟在一个<code>C</code>命令或者另一个<code>S</code>命令的后面，那么它的第一个<code>控制点</code>，就会被假设成前一个<code>控制点</code>的<code>对称点</code>。</p>
<p>如果S命令单独使用，前面没有<code>C</code>命令或者另一个<code>S</code>命令，那么它的<code>两个控制点</code>就会被假设为<code>同一个点</code>。</p>
<p><strong>语法：</strong> S x2 y2, x y 或者 s x2 y2, x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>x、y为终点位置</li>
<li>x2、y2为曲线终止的控制点</li>
</ul>

<p><code>三次贝塞尔曲线</code>相对于<code>二次贝塞尔曲线</code>拥有更大的自由度，但两种曲线能达到的<code>效果</code>是差不多的。最终选择使用哪种贝塞尔曲线，通常取决于需求，以及对曲线对称性的依赖程度。</p>
<h6> A（Elliptical Arc）</h6>
<p><code>A</code>命令用于画<code>弧形</code>，它可以截取<code>圆</code>或<code>椭圆</code>的<code>弧形</code>成的曲线</p>
<p><strong>语法：</strong> A rx ry x-axis-rotation large-arc-flag sweep-flag x y 或者 a rx ry x-axis-rotation large-arc-flag sweep-flag x y</p>
<p><strong>参数：</strong></p>
<ul>
<li>rx、ry 分别为<code>X</code>轴的半径和<code>Y</code>轴的半径</li>
<li>x-axis-rotation 为弧度在<code>X</code>轴的<code>旋转角度</code></li>
<li>large-arc-flag 决定弧线是<code>大于</code>还是<code>小于</code>180度，<code>0</code>表示<code>小角度弧</code>，<code>1</code>表示<code>大角度弧</code></li>
<li>sweep-flag 为<code>弧</code>的<code>方向</code>，<code>0</code>表示从起点到终点沿<code>逆时针</code>画弧，1表示从起点到终点沿<code>顺时针</code>画弧</li>
<li>x、y 为弧形的<code>终点</code></li>
</ul>

<h5> 填充和轮廓</h5>
<h6> fill</h6>
<p><code>fill</code>属性用于<code>填充</code>图形的<code>颜色</code></p>
<p><strong>语法：</strong><code> fill= "color"</code> 或者 <code>style="fill: color"</code></p>

<p>从上面的示例中可以看出，在<code>不设置</code>fill属性的时候，其实<code>默认</code>是<code>黑色</code>的填充，这也就是为什么上面的很多例子设置了 <code>fill='none'</code> 其实就是去掉默认填充。</p>
<p>fill属性其实还有一些延伸属性：</p>
<h6> fill-opacity</h6>
<p><code>fill-opacity</code>属性用于设置填充颜色的<code>透明度</code></p>

<h6> fill-rule</h6>
<p><code>fill-rule</code>属性用来设置<code>复杂形状</code>的<code>填充规则</code>。它有两种填充方式：<code>nonzero</code> 和 <code>evenodd</code>。该属性简单说就是判断某点属于该形状的<code>内部</code>还是<code>外部</code>。那么判断的规则是什么呢？</p>
<ul>
<li>nonzero</li>
</ul>
<p>nonzero为<code>默认值</code>，</p>
<p>规则为：要判断一个点是否在图形内，从该点作<code>任意方向</code>的一条射线，然后检测<code>射线</code>与<code>图形路径</code>的<code>交点</code>情况。从0开始计数，路径从左向右（<code>顺时针</code>）穿过射线则计数<code>加1</code>，
从右向左（<code>逆时针</code>）穿过射线则计数<code>减1</code>。得出计数结果后，如果结果是<code>0</code>，则认为点在图形<code>外部</code>，否则认为在<code>内部</code>。</p>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>PS：示例中的<code>绿色三角形</code>只是用来辅助理解的，可以忽略，只需要了解规则是<code>如何填充</code>的就行。</p>
</div>
<ul>
<li>evenodd</li>
</ul>
<p>规则为：要判断一个点是否在图形内，从该点作<code>任意方向</code>的一条射线，然后检测<code>射线</code>与<code>图形路径</code>的<code>交点</code>的<code>数量</code>。如果结果是<code>奇数</code>则认为点在<code>内部</code>，是<code>偶数</code>则认为点在<code>外部</code>。</p>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>PS：上面示例中的绿色三角形只是用来辅助理解的，可以忽略，咱们只需要了解规则是如何填充的就行。</p>
</div>
<h6> stroke</h6>
<p>stroke属性用来定义<code>线条</code>、<code>文本</code>或<code>元素</code> <code>轮廓</code> 的颜色。</p>
<p><strong>语法：</strong> <code>stroke="color"</code> 或者 <code>style="stroke: color"</code></p>

<h6> stroke-width</h6>
<p><code>stroke-width</code>属性定义了轮廓的<code>宽度</code></p>

<h6> stroke-opacity</h6>
<p><code>stroke-opacity</code>属性用于设置轮廓的<code>透明度</code></p>

<h6> stroke-linecap</h6>
<p><code>stroke-linecap</code>属性定义了轮廓<code>终点</code>的<code>形状</code>，该属性有三个值：</p>
<ul>
<li>butt：默认值，以<code>直边</code>结束线段</li>
<li>round：以<code>圆角</code>结束线段，圆角的半径由<code>stroke-width（轮廓宽度）</code>控制的</li>
<li>square：也是以<code>直边</code>结束线段，但和<code>butt</code>不同的是会在结束位置多出一段由<code>stroke-width（轮廓宽度）</code>大小控制的长度。</li>
</ul>

<h6> stroke-linejoin</h6>
<p><code>stroke-linejoin</code>属性定义了轮廓<code>连接处</code>的<code>样式</code>。样式有三种类型：</p>
<ul>
<li>miter：默认值，表示用方形画笔在连接处形成<code>尖角</code></li>
<li>round：用<code>圆角</code>连接，实现<code>平滑</code>效果</li>
<li>bevel：连接处会形成一个<code>斜面</code></li>
</ul>

<h6> stroke-dasharray</h6>
<p><code>stroke-dasharray</code>属性可以定义轮廓为<code>虚线</code></p>
<p><strong>语法：</strong> <code>stroke-dasharray="xxx"</code></p>
<p><strong>参数：</strong></p>
<ul>
<li>xxx 为一列数字字符串，对应的是：线段 空格 线段 空格......</li>
</ul>

<h6> stroke-dashoffset</h6>
<p><code>stroke-dashoffset</code> 属性用于指定路径<code>开始</code>的<code>距离</code>。值可为<code>正值</code>、<code>负值</code>、<code>百分比</code>。</p>

<h6> stroke-miterlimit</h6>
<p>如果两条线交汇在一起形成一个<code>尖角</code>，而且属性 <code>stroke-linejoin</code> 指定了 <code>miter</code>，斜接有可能扩展到远远超过路径轮廓线的线宽。属性 stroke-miterlimit` 对斜接长度和stroke-width的比率强加了一个极限。当极限到达时，交汇处由斜接变成倒角。</p>

<h4> 文字</h4>
<h5> text</h5>
<p>通过<code>text</code>标签可以在SVG中<code>添加文字</code>，</p>

<h6> x 和 y</h6>
<p><code>x</code>和<code>y</code>属性决定了文字的<code>绘制起点</code>。</p>
<p>但需要注意的是<code>x</code>和<code>y</code>的值可以是一个<code>数列</code>。如果设置为了一个数列则会应用到<code>每一个字符</code>上</p>

<h6> dx 和 dy</h6>
<p><code>dx</code>和<code>dy</code>属性与<code>x</code>和<code>y</code>属性不同的是，<code>x</code>和<code>y</code>属性是<code>绝对的坐标</code>，而<code>dx</code>和<code>dy</code>属性是相对于当前位置的<code>偏移量</code>。</p>
<p>参数也可以是一个<code>数列</code>。如果设置为了一个数列则会应用到<code>每一个字符</code>上</p>

<h6> rotate</h6>
<p><code>rotate</code>属性可以把文字<code>旋转</code>一个<code>角度</code>。</p>
<p>同样的参数也可以是一个<code>数列</code>。如果设置为了一个数列则会应用到<code>每一个字符</code>上</p>

<h6> textLength</h6>
<p><code>textLength</code>属性给定了一个<code>字符串</code>的<code>计算长度</code>。在文字的<code>长度</code>和<code>textLength</code>属性给定的长度<code>不一致</code>的情况下渲染引擎会精细<code>调整字型的位置</code>。</p>

<h6> lengthAdjust</h6>
<p><code>lengthadjust</code>属性可以控制文本以<code>什么方式</code>伸展到由<code>_textLength_</code>属性定义的长度。</p>
<p><strong>参数：</strong></p>
<ul>
<li>spacing：只<code>拉伸</code>或<code>压缩间距</code>（文字<code>不变形</code>）</li>
<li>spacingAndGlyphs：同时<code>拉伸</code>或<code>压缩间距</code>和<code>文字本身</code>（文字变形）</li>
</ul>

<h6> fill 和 stroke</h6>
<p><code>填充</code>和<code>轮廓</code>也都可以应用于文字</p>

<h6> CSS文字属性</h6>
<p>一些<code>CSS</code>中的文字样式属性同样也可以应用于SVG的文字中。</p>
<p><strong>例如</strong>：<code>font-size</code>、<code>font-family</code>、<code>font-style</code>、<code>font-variant</code>、<code>font-stretch</code>、<code>font-size-adjust</code>、<code>kerning</code>、<code>letter-spacing</code>、<code>word-spacing</code>、<code>text-decoration</code>等。</p>

<h5> tspan</h5>
<p><code>tspan</code>标签和<code>text</code>标签一样都可以用来<code>添加文字</code>，但不同的是<code>tspan标</code>签的作用为标记<code>大块文本</code>内的<code>部分内容</code>。比如一段文本其中某个字需要<code>加粗</code>或者<code>颜色</code>不一致，就可以用到<code>tspan</code>标签。</p>
<p><code>tspan</code>标签的属性和<code>text</code>标签一致，上面说到的text标签的<code>属性</code>在tspan标签中也<code>适用</code>。</p>
<p>需注意的是<code>tspan</code>标签<code>必须</code>是一个text<code>元素的</code>子元素<code>或别的</code>子元素tspan<code>的</code>子元素`。</p>

<p>需要注意的是<code>tspan</code>标签的<code>x</code>、<code>y</code> 和 <code>dx</code>、<code>dy</code> 会对标签后面的内容造成影响</p>

<h5> tref</h5>
<p><code>tref</code>标签配合<code>xlink:href</code>属性能<code>引用</code>已经<code>定义的文本</code>，实现<code>复制</code>的效果。并且引用之后还可以单独定义样式。</p>
<p>但遗憾的是<code>tref</code>标签是<code>SVG 1.1</code>规范的内容，它已经从<code>SVG 2.0</code>规范中<code>删除</code>了。</p>
<p>因此此处可以使用<code>use</code>标签来代替它，这里说明一下：</p>
<p><code>defs</code>标签可以定义一些之后绘制中需要<code>重复使用</code>的图形元素，<code>defs</code>是<code>definitions</code>的缩写。 <code>use</code>标签可以在SVG文档内<code>读取目标节点</code>，并在别的地方<code>复制使用</code>。</p>

<h5> textPath</h5>
<p><code>textPath</code>标签可以利用它的<code>xlink:href</code>属性取得一个<code>任意路径</code>，并且可以让字符顺着路径渲染。</p>

<h3> 渐变</h3>
<p>渐变就是从一个颜色<code>过渡</code>到另一个颜色，且渐变都分为<code>两种</code>渐变：<code>线性渐变</code>和<code>径向渐变</code></p>
<p>但需要注意的是这里我们需要接触两个新的标签：</p>
<ul>
<li><code>defs</code>标签用来定义渐变</li>
<li><code>stop</code>标签用来定义渐变的颜色坡度，具有三个属性：<code>offset</code>定义渐变开始和结束的位置、<code>stop-color</code>（定义颜色）和<code>stop-opacity</code>（定义透明度）</li>
</ul>
<h4> 线性渐变（linearGradient）</h4>
<p><strong>语法：</strong> <code>&lt;linearGradient x1="" y1="" x2="" y2=""&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>x1</code>、<code>y1</code>定义线性渐变的<code>起点</code></li>
<li><code>x2</code>、<code>y2</code>定义渐变的<code>终点</code>。</li>
</ul>

<h4> 径向渐变（radialGradient）</h4>
<p><strong>语法：</strong> <code>&lt;radialGradient cx="" cy="" r="" fx="" fy=""&gt;</code></p>
<p><strong>参数：</strong></p>
<ul>
<li><code>cx</code>、<code>cy</code>、<code>r</code>分别为圆的<code>坐标</code>和<code>半径</code>，也就是渐变的<code>范围</code></li>
<li><code>fx</code>、<code>fy</code>定义渐变的<code>中心点</code>，也叫渐变的焦点</li>
</ul>

<h4> 文字的渐变</h4>

<h3> 裁剪和蒙层</h3>
<h4> 裁剪</h4>
<p>使用<code>clipPath</code>标签定义一条裁剪路径，用来裁<code>剪掉元素的部分内容</code>。且任何<code>透明度</code>的效果都是<code>无效的</code>，它只能要么裁剪掉要么不裁剪。</p>

<h4> 蒙层</h4>
<p>蒙层的功能主要实现标签就是<code>mask</code>标签，他的功能和名字正好相反，他<code>不是</code>用来<code>遮住元素</code>的部分内容，而是用来<code>显示元素</code>中<code>mask</code>标签<code>遮住的内容</code>。他和<code>clipPath</code>标签<code>不同</code>的是允许使用<code>透明度</code>（<code>透明度为0则无蒙层效果</code>）和<code>灰度值遮罩</code>计算得的<code>软边缘</code>。</p>

<h3> 动画</h3>
<h4> 基础动画</h4>
<h5> translate（平移）</h5>
<p><strong>语法：</strong> <code>transform="translate(x, y)"</code>
<strong>参数：</strong></p>
<ul>
<li>x为<code>X轴</code>上的平移距离</li>
<li>y为<code>Y轴</code>上的平移距离</li>
</ul>

<h5> scale（缩放）</h5>
<p><strong>语法：</strong>  <code>transform="scale(x, y)"</code>
<strong>参数：</strong></p>
<ul>
<li>x为<code>X轴</code>上的缩放大小</li>
<li>y为<code>Y轴</code>上的缩放大小</li>
</ul>

<h5> rotate（旋转）</h5>
<p><strong>语法：</strong> <code>transform="rotate(deg)"</code></p>
<p><strong>参数：</strong> <code>deg</code>为旋转的角度。</p>

<h5> transform-origin（旋转中心点）</h5>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>元素的<code>旋转中心点</code>是<code>(0, 0)</code>。如果想要<code>只是旋转而不位移</code>，那么就需要把旋转的中心点设置在<code>元素</code>的<code>中心点</code>。</p>
<p>以上面的例子为例，
元素的x坐标为<code>200</code>，本身宽度为<code>100</code>，则<code>x轴元素</code>的中心点就为<code>250</code>。
元素的y坐标为<code>0</code>，高度为<code>100</code>，则<code>y轴元素</code>的中心点为<code>50</code>。
因此元素的中心点就为<code>(250, 50)</code>。
但是原地旋转导致部分遮挡，所以稍微调整<code>初始y坐标</code>及<code>中心点y坐标</code>。</p>
</div>

<h5> skew（倾斜）</h5>
<p><strong>语法：</strong> <code>transform="skewX(x) skewY(y)"</code></p>
<p><strong>参数：</strong> x为X轴上的<code>倾斜度</code>，y为Y轴上的<code>倾斜度</code>。</p>
<p>在SVG中<code>skew</code>属性需要分开设置，x轴设置为<code>skewX</code>，y轴设置为<code>skewY</code>，不能合并起来用，写成 <code>skew(x, y)</code> 是<strong>不生效</strong>的。</p>

<h4> JS动画</h4>
<p>在文章最开始的时候就说过：SVG <code>不能</code> <code>动态</code> 的 <code>修改</code> 动画 <code>内容</code>。</p>
<p>所以CSS3的过渡属性就不好使了，那么想实现动画就只能使用js的定时器（setInterval）来实现。</p>

<p>那么SVG最拿得出手的<code>线条动画</code>又如何用js来实现呢？</p>
<p>比如需要变换图形：</p>

<h4> CSS动画</h4>
<p>这里需要用上三个属性：分别是 <code>stroke</code>、<code>stroke-dasharray</code>、<code>stroke-dashoffset</code>。</p>

<p>按照这个逻辑搞一个按钮的线条动画吧。</p>

<p>把<code>填充</code>和<code>轮廓</code>弄一些填充，效果就更好看了</p>

<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>到此就看完了SVG分别用<code>js</code>和<code>css</code>来实现<code>动画</code>的方法。</p>
<p>那是不是觉得都比较<code>繁琐</code>呢？首先想绘制一个复杂的SVG就很复杂，其次用<code>js</code>去<code>变化坐标</code>也很复杂，用<code>css</code>去做<code>动画</code>简单点，但实现的动画也相对简单。</p>
<p>那么有没有什么<code>捷径</code>可以走呢？那回答肯定是：必须有啊！<strong><code>GreenSock</code></strong> 这里就不多介绍了</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>打钩动画</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/Checked/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/Checked/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">打钩动画</source>
      <description>::: vue-demo :::</description>
      <category>CSS</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    <item>
      <title>登录页</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/Login/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/Login/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">登录页</source>
      <description>::: vue-demo:::</description>
      <category>CSS</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    <item>
      <title>百叶窗</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/Shutters/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/Shutters/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">百叶窗</source>
      <description>::: vue-demo:::</description>
      <category>CSS</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    <item>
      <title>流光按钮</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/StreamerButton/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/CssComponent/StreamerButton/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">流光按钮</source>
      <description>::: vue-demo:::</description>
      <category>CSS</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 执行机制</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/EventLoop/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/EventLoop/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">JavaScript 执行机制</source>
      <description>这一次，彻底弄懂 JavaScript 执行机制 不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作， 我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。 因为javascript是一门单线程语言，所以我们可以得出结论： javascript是按照语句出现的顺序执行的 看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁。。。</description>
      <category>JavaScript</category>
      <pubDate>Wed, 01 Jun 2022 16:15:33 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 这一次，彻底弄懂 JavaScript 执行机制</h1>
<p>不论你是javascript新手还是老鸟，不论是面试求职，还是日常开发工作，
我们经常会遇到这样的情况：给定的几行代码，我们需要知道其输出内容和顺序。
因为javascript是一门单线程语言，所以我们可以得出结论：</p>
<p>javascript是按照语句出现的顺序执行的
看到这里读者要打人了：我难道不知道js是一行一行执行的？还用你说？稍安勿躁。。。</p>
<!-- more -->
<p>正因为js是一行一行执行的，所以我们以为js都是这样的：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>
<p>然而实际上js是这样的：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>
<p>依照 <strong>js是按照语句出现的顺序执行</strong> 这个理念，自信的写下输出结果：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>去chrome上验证下，结果完全不对，瞬间懵了，说好的一行一行执行的呢？</p>

<p>我们真的要彻底弄明白javascript的执行机制了。</p>
<h2> 关于javascript</h2>
<p>javascript是一门 <strong>单线程</strong> 语言，在最新的HTML5中提出了Web-Worker，但javascript是单线程这一核心仍未改变。
所以一切javascript版的"多线程"都是用单线程模拟出来的，一切javascript多线程都是纸老虎！</p>
<h2> javascript事件循环</h2>
<p>既然js是单线程，那就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理js任务也要一个一个顺序执行。
如果一个任务耗时过长，那么后一个任务也必须等着。
那么问题来了，假如我们想浏览新闻，但是新闻包含的超清图片加载很慢，难道我们的网页要一直卡着直到图片完全显示出来？
因此聪明的程序员将任务分为两类：</p>
<ul>
<li>同步任务</li>
<li>异步任务</li>
</ul>
<p>当我们打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。
而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。
关于这部分有严格的文字定义，但本文的目的是用最小的学习成本彻底弄懂执行机制，所以我们用导图来说明：</p>

<p>导图要表达的内容用文字来表述的话：</p>
<ul>
<li>同步和异步任务分别进入不同的执行"场所"，同步的进入主线程，异步的进入Event Table并注册函数。</li>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。
我们不禁要问了，那怎么知道主线程执行栈为空啊？js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。</li>
</ul>
<p>说了这么多文字，不如直接一段代码更直白：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是一段简易的ajax请求代码：</p>
<ul>
<li>ajax进入Event Table，注册回调函数success。</li>
<li>执行console.log('代码执行结束')。</li>
<li>ajax事件完成，回调函数success进入Event Queue。</li>
<li>主线程从Event Queue读取回调函数success并执行。
相信通过上面的文字和代码，你已经对js的执行顺序有了初步了解。接下来我们来研究进阶话题：setTimeout。</li>
</ul>
<h2> 又爱又恨的setTimeout</h2>
<p>大名鼎鼎的setTimeout无需再多言，大家对他的第一印象就是异步可以延时执行，我们经常这么实现延时3秒执行：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>渐渐的setTimeout用的地方多了，问题也出现了，
有时候明明写的延时3秒，实际却5，6秒才执行函数，这又咋回事啊？</p>
<p>先看一个例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据前面我们的结论，setTimeout是异步的，应该先执行console.log这个同步任务，所以我们的结论是：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>去验证一下，结果正确！ 然后我们修改一下前面的代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看其实差不多嘛，但我们把这段代码在chrome执行一下，却发现控制台执行task()需要的时间远远超过3秒，说好的延时三秒，为啥现在需要这么长时间啊？</p>
<p>这时候我们需要重新理解setTimeout的定义。我们先说上述代码是怎么执行的：</p>
<ul>
<li>task()进入Event Table并注册,计时开始。</li>
<li>执行sleep函数，很慢，非常慢，计时仍在继续。</li>
<li>3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep也太慢了吧，还没执行完，只好等着。</li>
<li>sleep终于执行完了，task()终于从Event Queue进入了主线程执行。
上述的流程走完，我们知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，
又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。</li>
</ul>
<p>我们还经常遇到 <strong>setTimeout(fn,0)</strong> 这样的代码，0秒后执行又是什么意思呢？是不是可以立即执行呢？</p>
<p>答案是不会的，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，
只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行。举例说明：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于setTimeout要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。有兴趣的同学可以自行了解。</p>
<h2> 又恨又爱的setInterval</h2>
<p>上面说完了setTimeout，当然不能错过它的孪生兄弟setInterval。他俩差不多，只不过后者是循环的执行。
对于执行顺序来说，setInterval会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。</p>
<p>唯一需要注意的一点是，对于setInterval(fn,ms)来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入Event Queue。
一旦setInterval的回调函数fn执行时间超过了延迟时间ms，那么就完全看不出来有时间间隔了。这句话请读者仔细品味。</p>
<h2> Promise与process.nextTick(callback)</h2>
<p>传统的定时器我们已经研究过了，接着我们探究Promise与process.nextTick(callback)的表现。</p>
<p>Promise的定义和功能本文不再赘述，不了解的读者可以学习一下阮一峰老师的<a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener noreferrer">Promise</a>。
而process.nextTick(callback)类似node.js版的"setTimeout"，在事件循环的下一次循环中调用 callback 回调函数。</p>
<p>我们进入正题，除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p>
<ul>
<li>macro-task(宏任务)：包括整体代码script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<p>不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。</p>
<p>事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。
接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。
听起来有点绕，我们用文章最开始的一段代码说明：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>这段代码作为宏任务，进入主线程。</li>
<li>先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述)</li>
<li>接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。</li>
<li>遇到console.log()，立即执行。</li>
<li>好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。</li>
<li>k，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。</li>
<li>结束。</li>
</ul>
<p>事件循环，宏任务，微任务的关系如图所示：</p>

<p>我们来分析一段较复杂的代码，看看你是否真的掌握了js的执行机制：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一轮事件循环流程分析如下：</p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到console.log，输出1。</li>
<li>遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。</li>
<li>遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。</li>
<li>遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。</li>
<li>又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">宏任务Event Queue</th>
<th style="text-align:center">微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setTimeout1</td>
<td style="text-align:center">process1</td>
</tr>
<tr>
<td style="text-align:center">setTimeout2</td>
<td style="text-align:center">then1</td>
</tr>
</tbody>
</table>
<ul>
<li>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。</li>
<li>我们发现了process1和then1两个微任务。</li>
<li>执行process1,输出6。</li>
<li>执行then1，输出8。</li>
</ul>
<p><strong>好了，第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</strong></p>
<p>那么第二轮时间循环从setTimeout1宏任务开始：</p>
<ul>
<li>首先输出2。</li>
<li>接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。</li>
<li>new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">宏任务Event Queue</th>
<th style="text-align:center">微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">setTimeout2</td>
<td style="text-align:center">process2</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">then2</td>
</tr>
</tbody>
</table>
<ul>
<li>第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。</li>
<li>输出3。</li>
<li>输出5。</li>
</ul>
<p><strong>第二轮事件循环结束，第二轮输出2，4，3，5。</strong></p>
<ul>
<li>第三轮事件循环开始，此时只剩setTimeout2了，执行。</li>
<li>直接输出9。</li>
<li>将process.nextTick()分发到微任务Event Queue中。记为process3。</li>
<li>直接执行new Promise，输出11。</li>
<li>将then分发到微任务Event Queue中，记为then3。</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">宏任务Event Queue</th>
<th style="text-align:center">微任务Event Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">process3</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">then3</td>
</tr>
</tbody>
</table>
<ul>
<li>第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。</li>
<li>输出10。</li>
<li>输出12。</li>
</ul>
<p><strong>第三轮事件循环结束，第三轮输出9，11，10，12。</strong></p>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。 (请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差)</p>
<h2> 写在最后</h2>
<p>(1)js的异步</p>
<p>我们从最开头就说javascript是一门单线程语言，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。</p>
<p>(2)事件循环Event Loop</p>
<p>事件循环是js实现异步的一种方法，也是js的执行机制。</p>
<p>(3)javascript的执行和运行</p>
<p>执行和运行有很大的区别，javascript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指javascript解析引擎，是统一的。</p>
<p>(4)setImmediate</p>
<p>微任务和宏任务还有很多种类，比如setImmediate等等，执行都是有共同点的，有兴趣的同学可以自行了解。</p>
<p>(5)最后的最后</p>
<ul>
<li>javascript是一门单线程语言</li>
<li>Event Loop是javascript的执行机制</li>
</ul>
<p>牢牢把握两个基本点，以认真学习javascript为中心，早日实现成为前端高手的伟大梦想！</p>

]]></content:encoded>
    </item>
    <item>
      <title>请使用JS完成一个JSON扁平化</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/FlatJson/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/FlatJson/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">请使用JS完成一个JSON扁平化</source>
      <description>代码实现 function expandJsonTool(data, k) { var jmap = {} var expandJson = function (jstr, mapIndex) { if (jstr instanceof Array) { for (var i in jstr) { expandJson(jstr[i], `${mapIndex}[${i}]`); } } else if (jstr instanceof Object) { for (var i in jstr) { // 如果mapIndex为false,null,&amp;apos;&amp;apos;时，则不加初始索引 if (!mapIndex) { var key = i; } else { var key = `${mapIndex}.${i}`; } // Array 是 Object 的子集，先判断是否为 Array,如果是，则不走Object的判断 if (jstr[i] instanceof Array) { for (var j in jstr[i]) { expandJson(jstr[i][j], `${key}[${j}]`); } } else if ((jstr[i] instanceof Object)) { expandJson(jstr[i], key); } else if (typeof jstr[i] === &amp;apos;string&amp;apos; &amp;amp;&amp;amp; jstr[i].includes(&amp;apos;{&amp;apos;) &amp;amp;&amp;amp; jstr[i].includes(&amp;apos;}&amp;apos;)) { expandJson(JSON.parse(jstr[i]), key); } else { jmap[key] = jstr[i] } } } } expandJson(data, k); return jmap }</description>
      <category>JavaScript</category>
      <pubDate>Sat, 25 Feb 2023 14:57:37 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 代码实现</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 函数使用</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 结果输出</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Jsonp</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Jsonp/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Jsonp/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Jsonp</source>
      <description>我们都知道， Ajax 请求是不能跨域[1]的，无论是 静态页面 、 动态网页 、 web服务等，只要是跨域请求，一律都不允许通过浏览器跨域的检测和阻拦。</description>
      <category>JavaScript</category>
      <pubDate>Thu, 23 Feb 2023 16:54:02 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们都知道， <code>Ajax</code> 请求是不能跨域<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">的，无论是 <code>静态页面</code> 、 <code>动态网页</code> 、  <code>web服务</code>等，只要是跨域请求，一律都不允许通过浏览器跨域的<code>检测</code>和<code>阻拦</code>。</a></p><a class="footnote-anchor" id="footnote-ref1">
<p>但是可以发现，web页面上调用 <code>js</code> 是不受跨域的影响，同时拥有 <code>src属性</code> 的标签也具有相同的能力，比如 &lt;<strong>script</strong>&gt;、&lt;<strong>img</strong>&gt;、&lt;<strong>iframe</strong>&gt;</p>
<p>于是如果想通过 <code>纯web端跨域</code> 访问数据就可以这样：在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理。</p>
<p>恰巧有一种叫做 <code>JSON</code> 的纯字符数据格式可以简洁的描述复杂数据，<strong>更巧的是JSON还被js原生支持</strong>，所以在客户端几乎可以随心所欲的处理这种格式的数据。</p>
<p>这样子解决方案就呼之欲出了，web客户端通过与调用脚本一样的方式，来调用跨域服务器上动态生成的js格式文件，显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装进去。</p>
<p>客户端在对js文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了。</p>
<p>为了便于客户端使用数据，逐渐形成了一种 <code>非正式传输协议</code> ，人们把它称作 <code>JSONP</code>，该协议的一个要点就是允许用户传递一个<code>callback</code>参数给服务端，
然后服务端返回数据时会将这个callback参数作为<code>函数名</code>来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr class="footnotes-sep">
</a><section class="footnotes"><a class="footnote-anchor" id="footnote-ref1">
</a><ol class="footnotes-list"><a class="footnote-anchor" id="footnote-ref1">
</a><li id="footnote1" class="footnote-item"><a class="footnote-anchor" id="footnote-ref1"></a><p><a class="footnote-anchor" id="footnote-ref1"><a href="/Network/CrossDomain/" target="blank">跨域可阅读这篇文章</a> </a><a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>请使用JS完成一个LRU缓存</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/LRU/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/LRU/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">请使用JS完成一个LRU缓存</source>
      <description>什么是 LRU？ LRU 英文全称是 Least Recently Used，英译过来就是 最近最少使用 的意思。 百度百科 LRU 是一种常用的页面置换算法，选择 最近 最久 未使用 的页面予以淘汰。 该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所 经历的时间t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。</description>
      <category>JavaScript</category>
      <pubDate>Sat, 25 Feb 2023 14:57:37 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是 LRU？</h2>
<p><code>LRU</code> 英文全称是 <code>Least Recently Used</code>，英译过来就是 <code>最近最少使用</code> 的意思。</p>
<h3> 百度百科</h3>
<p>LRU 是一种常用的页面置换算法，选择 <code>最近</code> <code>最久</code> <code>未使用</code> 的页面予以<code>淘汰</code>。</p>
<p>该算法赋予<code>每个页面</code>一个<code>访问字段</code>，用来记录一个页面自上次被访问以来所 <code>经历的时间t</code>，当须淘汰一个页面时，选择现有页面中其 <code>t</code> 值最大的，即<code>最近最少使用</code>的页面予以淘汰。</p>
<h3> 通俗的解释</h3>
<p>假如我们有一块<code>内存</code>，专门用来缓存我们<code>最近访问</code>的网页，访问一个<code>新网页</code>，我们就会往内存中添加一个<code>网页地址</code>，随着网页的不断增加，内存存满了，这个时候我们就需要考虑删除一些网页了。这个时候我们找到内存中<code>最早访问</code>的那个网页地址，然后把它<code>删掉</code>。
这一整个过程就可以称之为 L<code>RU</code> 算法。</p>
<p>虽然上面的解释比较好懂了，但是我们还有很多地方没有考虑到，比如如下几点：</p>
<ul>
<li>当我们访问内存中<code>已经存在</code>的<code>网址</code>，那么该网址是否需要<code>更新</code>在内存中的<code>存储顺序</code>。</li>
<li>当我们内存中还没有数据的时候，是否需要执行删除操作。</li>
</ul>
<h2> 使用场景</h2>
<p><code>LRU</code> 算法使用的场景非常多，这里简单举几个例子即可：</p>
<ol>
<li>操作系统底层的内存管理，其中就包括有 LRU 算法</li>
<li>我们常见的缓存服务，比如 redis 等等</li>
<li>浏览器的最近浏览记录存储，如下图：</li>
</ol>
<p>总之 LRU 算法的运用场景还是蛮多的，所以我们很有必要掌握它。</p>
<h2> 梳理 LRU 思路</h2>
<h3> 特点</h3>
<ol>
<li>需要一块<code>有限</code>的<code>存储空间</code>，因为无限的化就没必要使用 <code>LRU</code> 算法<code>删除数据</code>了。</li>
<li><code>存储空间</code>里面存储的数据需要是<code>有序的</code>，因为必须要<code>顺序</code>来<code>删除数据</code>，所以可以考虑使用 <code>Array</code>、<code>Map</code> 数据结构来存储。</li>
<li>能够<code>删除</code>或者<code>添加</code>以及<code>获取</code>到这块存储空间中的<code>指定数据</code>。</li>
<li>存储空间<code>存满</code>之后，在添加数据时，会自动删除时间<code>最久远</code>的那条数据。</li>
</ol>
<h3> 实现需求</h3>
<ol>
<li>实现一个 <code>LRUCache</code> 类型，用来充当<code>存储空间</code></li>
<li>采用 <code>Map</code> 数据结构<code>存储数据</code>，因为它的存取时间复杂度为 <code>O(1)</code>，数组为 <code>O(n)</code></li>
<li>实现 <code>get</code> 和 <code>set</code> 方法，用来<code>获取</code>和<code>添加</code>数据</li>
<li>存储空间有<code>长度限制</code>，所以<code>无需</code>提供<code>删除方法</code>，存储满之后，自动删除最久远的那条数据</li>
<li>当使用 <code>get</code> 获取数据后，该条数据需要<code>更新</code>到<code>最前面</code></li>
</ol>
<p>现在已经把 <code>LRU</code> 算法的特点以及实现思路列了出来，那么接下来就去实现它吧！</p>
<h2> 实现</h2>
<p>首先我们定义一个 <code>LRUCache</code> 类，封装所有的方法和变量。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码只是最简单的一个架子，我们需要去实现具体的 <code>get</code> 和 <code>set</code> 方法。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上段代码中实现实现了 <code>get</code> 和 <code>set</code> 方法，下面说一下这两个方法的<code>实现思路</code>：</p>
<p><code>set</code> 方法：往 <code>map</code> 里面<code>添加</code>新数据，如果添加的数据<code>存在</code>了，则<code>先删除</code>该条数据，然后<code>再添加</code>。如果添加数据后<code>超长</code>了，则需要删除<code>最久远</code>的一条数据。<code>data.keys().next().value</code> 便是获取最后一条数据的意思。
<code>get</code> 方法：首先从 <code>map</code> 对象中<code>拿出</code>该条数据，然后<code>删除</code>该条数据，最后再重新<code>插入</code>该条数据，确保将该条数据移动到<code>最前面</code>。</p>
<h2> 测试</h2>
<p>存储数据 set：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继续插入数据，此时会超长，代码如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时我们发现存储时间最久的 name 已经被移除了，新插入的数据变为了最前面的一个。</p>
<p>我们使用 <code>get</code> 获取数据，代码如下：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现此时 sex 字段已经跑到最前面去了。</p>
<h2> 总结</h2>
<p><code>LRU</code> 算法其实逻辑非常的简单，明白了原理之后实现起来非常的简单。</p>
<p>最主要的是需要使用什么<code>数据结构</code>来<code>存储数据</code>，因为 <code>map</code> 的存取非常快，所以采用了它，当然数组其实也可以实现的。还有一些小伙伴使用链表来实现 <code>LRU</code>，这当然也是可以的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript相关面试问题</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Question/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Question/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">JavaScript相关面试问题</source>
      <description>常问问题 回调地狱 详情 人们普遍以javaScript的执行顺序来编写代码,在执行异步代码时,无论以什么顺序简单的执行代码,通常情况会变成许多层级的回调函数堆积 下面代码使用promise多次加载图片，防止回调函数嵌套 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; &amp;lt;script src=&amp;quot;https://ajax.aspnetcdn.com/ajax/jquery/jquery-3.5.1.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const ID_BASE_URL = &amp;apos;https://jsonplaceholder.typicode.com/todos&amp;apos; const ROBOT_IMG_BASE_URL = &amp;apos;https://robohash.org&amp;apos; function getRobotId(url) { const promise = new Promise((resolve, reject) =&amp;gt; { $.get(url, function (data) { const id = data.id resolve(id) }) }) return promise } function createRobot(id) { const img = document.createElement(&amp;apos;img&amp;apos;) img.src = ROBOT_IMG_BASE_URL + `/${id}&amp;amp;size=200*200` document.body.appendChild(img) } getRobotId(ID_BASE_URL + &amp;apos;/1&amp;apos;).then(res1 =&amp;gt; { createRobot(res1) return getRobotId(ID_BASE_URL + &amp;apos;/2&amp;apos;) }).then(res2 =&amp;gt; { createRobot(res2) }).catch(e =&amp;gt; { alert(e) }) &amp;lt;/script&amp;gt;</description>
      <category>Question</category>
      <pubDate>Wed, 01 Jun 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 常问问题</h2>
<h3> 回调地狱</h3>
<details class="hint-container details"><summary>详情</summary>
<p>人们普遍以javaScript的执行顺序来编写代码,在执行异步代码时,无论以什么顺序简单的执行代码,通常情况会变成许多层级的回调函数堆积</p>
<p>下面代码使用promise多次加载图片，防止回调函数嵌套</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 封装绑定事件处理函数</h3>
<details class="hint-container details"><summary>详情</summary>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 文档碎片</h3>
<details class="hint-container details"><summary>详情</summary>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> preload和prefetch的区别</h3>
<h3> script脚本加了defer属性后，是DOMContentLoaded回调先执行，还是script脚本的代码先执行</h3>
<h3> Object object any的区别</h3>
<h3> Object.definedProperty有哪些属性</h3>
<h3> object静态方法freeze()，seal(),preventExtension()的区别</h3>
<h2> promise 相关</h2>
<h3> 异步加载图片</h3>
<details class="hint-container details"><summary>详情</summary>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 封装接口请求</h3>
<details class="hint-container details"><summary>详情</summary>
<p><strong>注意事项：</strong></p>
<p>为防止跨域问题，post请求采用简单请求，内容详见<a href="../CrossDomain">跨域问题</a></p>
<p>XMLHttpRequest的 <strong>readyState</strong> 状态码内容如下：</p>
<ul>
<li>0 - 代表未初始化。 还没有调用 open 方法</li>
<li>1 - 代表正在加载。 open 方法已被调用，但 send 方法还没有被调用</li>
<li>2 - 代表已加载完毕。send 已被调用。请求已经开始</li>
<li>3 - 代表正在与服务器交互中。服务器正在解析响应内容</li>
<li>4 - 代表完成。响应发送完毕</li>
</ul>
<h2> Get请求</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Post请求</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> await 一个promise，promise里的执行reject的话会怎么样</h3>
]]></content:encoded>
    </item>
    <item>
      <title>Reflect</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Reflect/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Reflect/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Reflect</source>
      <description>Object.keys() 和 Reflect.ownKeys() 差别 var obj = { 	a: 1, 	b: 2 } Object.defineProperty(obj, &amp;apos;method&amp;apos;, { 	value: function () { 	 alert(&amp;quot;Non enumerable property&amp;quot;) 	}, 	enumerable: false }) console.log(Object.keys(obj)) // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;] console.log(Reflect.ownKeys(obj)) // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;method&amp;quot;]</description>
      <category>JavaScript</category>
      <pubDate>Tue, 28 Feb 2023 16:46:13 GMT</pubDate>
      <content:encoded><![CDATA[<h3> Object.keys() 和 Reflect.ownKeys() 差别</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从结果上看出:</p>
<ul>
<li>Object.keys()返回属性key，但不包括不可枚举的属性</li>
<li>Reflect.ownKeys()返回所有属性key</li>
</ul>
<div class="hint-container info">
<p class="hint-container-title">从网上搜索资料所得</p>
<p>Object.keys() :</p>
<p>相当于返回属性数组</p>
<p>Reflect.ownKeys() :</p>
<p>相当于
Object.getOwnPropertyNames(target) concat(Object.getOwnPropertySymbols(target)</p>
<p>注意:
getOwnPropertyNames()</p>
<p>方法: 返回所有属性的数组</p>
<p>Object.getOwnPropertySymbols()</p>
<p>方法: 返回所有符号属性直接发现在给定的对象</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 小技巧</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Skill/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Skill/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">JavaScript 小技巧</source>
      <description>一行代码完成结构加赋值 经常使用结构赋值，一般都是先结构，再赋值，当然也可以一行就完成解构加赋值操作，看起来非常简化，当然可读性你懂得！ let people = { name: null, age: null }; let result = { name: &amp;apos;张三&amp;apos;, age: 16 }; ({ name: people.name, age: people.age } = result); console.log(people) // {&amp;quot;name&amp;quot;:&amp;quot;张三&amp;quot;,&amp;quot;age&amp;quot;:16}</description>
      <category>JavaScript</category>
      <pubDate>Tue, 28 Feb 2023 10:37:02 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 一行代码完成结构加赋值</h3>
<p>经常使用结构赋值，<strong>一般都是先结构，再赋值</strong>，当然也可以一行就完成解构加赋值操作，看起来非常简化，当然可读性你懂得！</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 对基础数据类型进行解构</h3>
<p>实际上可以对 <strong>基础数据类型</strong> 解构</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 对数组解构快速拿到最后一项值</h3>
<p>实际上是可以对 <strong>数组</strong> 解构赋值拿到 <strong>length</strong> 属性的，通过这个特性也可以做更多的事情。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 将下标转为中文零一二三...</h3>
<p>日常可能有的列表需要将对应的 <strong>012345</strong> 转为中文的 <strong>一、二、三、四、五...</strong>，在老的项目看到还有通过自己手动定义很多行这样的写法，于是写了一个这样的方法转换</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 判断整数的不同方法</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 通过css检测系统的主题色从而全局修改样式</h3>
<p><strong>@media</strong> 的属性 <strong>prefers-color-scheme</strong> 就可以知道当前的系统主题，当然使用前需要查查兼容性</p>
<div class="language-scss line-numbers-mode" data-ext="scss"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>javascript也可以轻松做到</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数组随机打乱顺序</h3>
<p>通过 <strong>0.5-Math.random()</strong> 得到一个随机数，再通过两次 <strong>sort</strong> 排序打乱的更彻底，但是这个方法实际上并不够随机，如果是企业级运用，建议使用第二种洗牌算法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 随机获取一个Boolean值</h3>
<p>和上个原理相同，通过随机数获取，<strong>Math.random()</strong> 的区间是 <strong>0-0.99</strong>，用<strong>0.5</strong>在中间百分之五十的概率</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 把数组的第一项放到最后一项</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 把数组最后一项移到第一项</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 利用set数组去重</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> dom节点平滑滚动到可视区域，顶部，底部</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 获取随机颜色</h3>
<p>日常我们经常会需要获取一个随机颜色，通过随机数即可完成</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 检测是否为空对象</h3>
<p>通过使用 <strong>Es6</strong> 的 <strong>Reflect<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></strong><a class="footnote-anchor" id="footnote-ref1"> 静态方法判断它的长度就可以判断是否是空对象了，也可以通过 <strong>Object.keys()</strong> 来判断</a></p><a class="footnote-anchor" id="footnote-ref1">
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></a><h3><a class="footnote-anchor" id="footnote-ref1"></a> Boolean转换</h3>
<p>一些场景下会将<strong>boolean</strong>值定义为场景，但是在js中非空的字符串都会被认为是true</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 各种数组克隆方法</h3>
<p>数组克隆的方法其实特别多了，看看有没有你没见过的！</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 比较两个时间大小</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算两个时间之间的月份差异</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 一步从时间中提取年月日时分秒</h3>
<p>时间格式化轻松解决，一步获取到年月日时分秒毫秒，由于 <strong>toISOString</strong> 会丢失时区，导致时间差八小时，所以在格式化之前我们加上八个小时时间即可</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 判断一个参数是不是函数</h3>
<p>有时候方法需要传入一个<strong>函数回调</strong>，但是需要检测其类型，我们可以通过 <strong>Object</strong>的原型方法去检测，当然这个方法可以准确检测任何类型。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 计算两个坐标之间的距离</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 检测两个dom节点是否覆盖重叠</h3>
<p>有些场景下需要判断 <strong>dom</strong> 是否发生 <strong>碰撞了</strong> 或者 <strong>重叠了</strong> ，我们可以通过 <strong>getBoundingClientRect</strong> 获取到dom的 <strong>x1,y1,x2,y2</strong> 坐标然后进行坐标比对即可判断出来</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 判断是否是NodeJs环境</h3>
<p>前端的日常开发是<code>离不开nodeJs</code>的，通过判断全局环境来检测是否是<strong>nodeJs</strong>环境</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 参数求和</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>Reflect 可以看这篇文章 <a href="/FrontEnd/JavaScript/Reflect/#object-keys-%E5%92%8C-reflect-ownkeys-%E5%B7%AE%E5%88%AB" target="blank">通道</a> <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>请封装一个Storage</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Storage/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/JavaScript/Storage/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">请封装一个Storage</source>
      <description>很多人在用 localStorage 或 sessionStorage 的时候喜欢直接用明文存储，直接将信息暴露在浏览器中， 虽然一般场景下都能应付得了且简单粗暴，但特殊需求情况下，比如设置定时功能，就不能实现。 就需要对其进行二次封装，为了在使用上增加些安全感，那加密也必然是少不了的了。 为方便项目使用，特对常规操作进行封装。</description>
      <category>JavaScript</category>
      <pubDate>Mon, 13 Jun 2022 15:07:14 GMT</pubDate>
      <content:encoded><![CDATA[<p>很多人在用 localStorage 或 sessionStorage 的时候喜欢直接用明文存储，直接将信息暴露在浏览器中，</p>
<p>虽然一般场景下都能应付得了且简单粗暴，但特殊需求情况下，比如设置定时功能，就不能实现。</p>
<p>就需要对其进行二次封装，为了在使用上增加些安全感，那加密也必然是少不了的了。</p>
<p>为方便项目使用，特对常规操作进行封装。</p>
<!-- more -->
<h2> 设计</h2>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>封装之前先梳理下所需功能，并要做成什么样，采用什么样的规范，部分主要代码片段是以 localStorage作为示例。</p>
</div>
<ul>
<li>区分存储类型 type</li>
<li>自定义名称前缀 prefix</li>
<li>支持设置过期时间 expire</li>
<li>支持加密可选，开发环境下未方便调试可关闭加密</li>
<li>支持数据加密 这里采用 crypto-js 加密 也可使用其他方式</li>
<li>判断是否支持 Storage isSupportStorage</li>
<li>设置 setStorage</li>
<li>获取 getStorage</li>
<li>是否存在 hasStorage</li>
<li>获取所有key getStorageKeys</li>
<li>根据索引获取key getStorageForIndex</li>
<li>获取localStorage长度 getStorageLength</li>
<li>获取全部 getAllStorage</li>
<li>删除 removeStorage</li>
<li>清空 clearStorage</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 设置 setStorage</h3>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>Storage 本身是不支持过期时间设置的，要支持设置过期时间，可以效仿 Cookie 的做法，setStorage(key,value,expire) 方法，接收三个参数，第三个参数就是设置过期时间的，用相对时间，单位秒，要对所传参数进行类型检查。</p>
<p>可以设置统一的过期时间，也可以对单个值得过期时间进行单独配置。两种方式按需配置。</p>
</div>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 获取 getStorage</h3>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>首先要对 key 是否存在进行判断，防止获取不存在的值而报错。对获取方法进一步扩展，只要在有效期内获取 Storage 值，就对过期时间进行续期，如果过期则直接删除该值。并返回 null</p>
</div>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 获取所有值</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 删除 removeStorage</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 清空 clearStorage</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 加密、解密</h3>
<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>加密采用的是 crypto-js</p>
</div>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>对 crypto-js 设置密钥和密钥偏移量，可以采用将一个私钥经 MD5 加密生成16位密钥获得。</p>
</div>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>对加密方法进行封装</p>
</div>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在存储数据及获取数据中进行使用：</p>
<p>这里我们主要看下进行加密和解密部分，部分方法在下面代码段中并未展示，<code>请注意，不能直接运行</code>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用</h3>
<p>使用的时候你可以通过 import 按需引入，也可以挂载到全局上使用，一般建议少用全局方式或全局变量，为后来接手项目继续开发维护的人，追查代码留条便捷之路！不要为了封装而封装，尽可能基于项目需求和后续的通用，以及使用上的便捷。比如获取全部存储变量，如果你项目上都未曾用到过，倒不如删减掉，留着过年也不见得有多香，不如为减小体积做点贡献！</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 完整代码</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>乾坤</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Micro/QianKun/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Micro/QianKun/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">乾坤</source>
      <description>微前端 是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。 各个前端应用还可以独立开发、独立部署。同时，它们也可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。 qiankun（乾坤） 就是一款由蚂蚁金服推出的比较成熟的微前端框架，基于 single-spa 进行二次开发，用于将Web应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。 那么，话不多说，我们的源码解析正式开始。</description>
      <category>微前端</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>微前端</strong> 是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将单页面前端应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p>
<p>各个前端应用还可以独立开发、独立部署。同时，它们也可以在共享组件的同时进行并行开发——这些组件可以通过 NPM 或者 Git Tag、Git Submodule 来管理。</p>
<p><strong>qiankun（乾坤）</strong> 就是一款由蚂蚁金服推出的比较成熟的微前端框架，基于 <strong>single-spa</strong> 进行二次开发，用于将Web应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。</p>
<p>那么，话不多说，我们的源码解析正式开始。</p>
<!-- more -->

<p>我们从两个基础 API : <strong>registerMicroApps(apps, lifeCycles?) - 注册子应用</strong> 和 <strong>start(opts?) - 启动主应用</strong> 开始</p>
<p>由于 <strong>registerMicroApps</strong> 函数中设置的回调函数较多，并且读取了 <strong>start</strong> 函数中设置的初始配置项，所以我们从 <strong>start</strong> 函数开始解析。</p>
<h2> start(opts)</h2>

<p>第 196 行：设置 <strong>window</strong> 的 <strong><strong>POWERED_BY_QIANKUN</strong></strong> 属性为 true，在子应用中使用 <strong>window.<strong>POWERED_BY_QIANKUN</strong></strong> 值判断是否运行在主应用容器中。</p>
<p>第 198~199 行：设置配置参数（有默认值），将配置参数存储在 <strong>importLoaderConfiguration</strong> 对象中。</p>
<p>第 201~203 行：检查 <strong>prefetch</strong> 属性，如果需要预加载，则添加全局事件 <strong>single-spa:first-mount</strong> 监听，在第一个子应用挂载后预加载其他子应用资源，优化后续其他子应用的加载速度。</p>
<p>第 205 行：根据 <strong>singularMode</strong> 参数设置是否为单实例模式。</p>
<p>第 209~217 行：根据 <strong>jsSandbox</strong> 参数设置是否启用沙箱运行环境，旧版本需要关闭该选项以兼容 IE。（新版本在单实例模式下默认支持 IE，多实例模式依然不支持 IE）。</p>
<p>第 222 行：调用了 <strong>single-spa</strong> 的 <strong>startSingleSpa</strong> 方法启动主应用。</p>
<p>从上面可以看出，<strong>start</strong> 函数负责初始化一些全局设置，然后启动应用。这些初始化的配置参数有一部分将在 <strong>registerMicroApps</strong> 注册子应用的回调函数中使用，我们继续往下看。</p>
<h2> registerMicroApps(apps, lifeCycles?)</h2>
<p><strong>registerMicroApps</strong> 函数的作用是注册子应用，并且在子应用激活时，创建运行沙箱，在不同阶段调用不同的生命周期钩子函数。</p>

<p>从上面可以看出，在 第 70~71 行 <strong>registerMicroApps</strong> 函数做了个处理，防止重复注册相同的子应用。</p>
<p>在 第 74 行 调用了 <strong>single-spa</strong> 的 <strong>registerApplication</strong> 方法注册了子应用。</p>
<p>我们直接来看 <strong>registerApplication</strong> 方法，<strong>registerApplication</strong> 方法是 <strong>single-spa</strong> 中注册子应用的核心函数。该函数有四个参数，分别是</p>
<ul>
<li>name（子应用的名称）</li>
<li>回调函数（activeRule 激活时调用）</li>
<li>activeRule（子应用的激活规则）</li>
<li>props（主应用需要传递给子应用的数据）</li>
</ul>
<p>这些参数都是由 <strong>single-spa</strong> 直接实现，这里可以先简单理解为注册子应用。在符合 <strong>activeRule</strong> 激活规则时将会激活子应用，执行回调函数，返回一些生命周期钩子函数。</p>
<blockquote>
<p>注意，这些生命周期钩子函数属于 single-spa，由 single-spa 决定在何时调用。</p>
</blockquote>
<p>如果你还是觉得有点懵，没关系，我们通过一张图来帮助理解。</p>

<h2> import-html-entry</h2>
<p>我们从上面分析可以看出，<strong>qiankun</strong> 的 <strong>registerMicroApps</strong> 方法中第一个入参 apps - <strong>Array&lt;RegistrableApp&lt;<strong>T</strong>&gt;&gt;</strong> 有三个参数 <strong>name、activeRule、props</strong> 都是交给 <strong>single-spa</strong> 使用，还有 <strong>entry</strong> 和 <strong>render</strong> 参数还没有用到。</p>
<p>我们这里需要关注 <strong>entry（子应用的 entry 地址）</strong> 和 <strong>render（子应用被激活时触发的渲染规则）</strong> 这两个还没有用到的参数，这两个参数延迟到 <strong>single-spa</strong> 子应用激活后的回调函数中执行。</p>
<p>那我们假设此时我们的子应用已激活，我们来看看这里做了什么。</p>

<p>从上图可以看出，在子应用激活后，首先在 第 81~84 行 处使用了 import-html-entry 库从 entry 进入加载子应用，加载完成后将返回一个对象</p>

<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>template</code></td>
<td style="text-align:left">将脚本文件内容注释后的 <code>html</code> 模板文件</td>
</tr>
<tr>
<td style="text-align:left"><code>assetPublicPath</code></td>
<td style="text-align:left">资源地址根路径，可用于加载子应用资源</td>
</tr>
<tr>
<td style="text-align:left"><code>getExternalScripts</code></td>
<td style="text-align:left">方法：获取外部引入的脚本文件</td>
</tr>
<tr>
<td style="text-align:left"><code>getExternalStyleSheets</code></td>
<td style="text-align:left">方法：获取外部引入的样式表文件</td>
</tr>
<tr>
<td style="text-align:left"><code>execScripts</code></td>
<td style="text-align:left">方法：执行该模板文件中所有的 <code>JS</code> 脚本文件，并且可以指定脚本的作用域 - <code>proxy</code> 对象</td>
</tr>
</tbody>
</table>
<p>我们先将 <strong>template 模板</strong>、<strong>getExternalScripts</strong> 和 <strong>getExternalStyleSheets</strong> 函数的执行结果打印出来，效果如下:</p>

<p>从上图我们可以看到我们外部引入的三个 <strong>js</strong> 脚本文件，这个模板文件没有外部 <strong>css</strong> 样式表，对应的样式表数组也为空。</p>
<p>然后我们再来分析 <strong>execScripts</strong> 方法，该方法的作用就是指定一个 <strong>proxy（默认是 window）对象</strong>，然后执行该模板文件中所有的 JS，并返回 JS 执行后 proxy 对象的最后一个属性。</p>
<p>在微前端架构中，这个对象一般会包含一些子应用的生命周期钩子函数，主应用可以通过在特定阶段调用这些生命周期钩子函数，进行挂载和销毁子应用的操作。</p>


<p>在 qiankun 的 <strong>importEntry</strong> 函数中还传入了配置项 <strong>getTemplate</strong>，这个其实是对 html 目标文件的二次处理，这里就不作展开了，有兴趣的可以自行去了解一下。</p>
<h2> 主应用挂载子应用 HTML 模板</h2>
<p>我们回到 qiankun 源码部分继续看</p>

<p>从上图看出，在 第 85~87 行 处，先对单实例进行检测。在单实例模式下，新的子应用挂载行为会在旧的子应用卸载之后才开始。</p>
<p>在 第 88 行 中，执行注册子应用时传入的 render 函数，将 HTML Template 和 loading 作为入参，render 函数的内容一般是将 HTML 挂载在指定容器中（见下图）。</p>

<p>在这个阶段，主应用已经将子应用基础的 HTML 结构挂载在了主应用的某个容器内，接下来还需要执行子应用对应的 mount 方法（如 Vue.$mount）对子应用状态进行挂载。</p>
<p>此时页面还可以根据 loading 参数开启一个类似加载的效果，直至子应用全部内容加载完成。</p>
<h2> 沙箱运行环境 - genSandbox</h2>
<p>我们回到 qiankun 源码部分继续看，此时还是子应用激活时的回调函数部分（见下图）</p>

<p>在 第 90~98 行 是 qiankun 比较核心的部分，也是几个子应用之间状态独立的关键，那就是 js 的沙箱运行环境。如果关闭了 useJsSandbox 选项，那么所有子应用的沙箱环境都是 window，就很容易对全局状态产生污染。</p>
<p>我们进入到 genSandbox 内部，看看 qiankun 是如何创建的 （JS）沙箱运行环境。（见下图）</p>

<p>从上图可以看出 genSandbox 内部的沙箱主要是通过是否支持 window.Proxy 分为 LegacySandbox 和 SnapshotSandbox 两种。</p>
<blockquote>
<p>扩展阅读：多实例还有一种 ProxySandbox 沙箱，这种沙箱模式目前看来是最优方案。由于其表现与旧版本略有不同，所以暂时只用于多实例模式。</p>
<p>ProxySandbox 沙箱稳定之后可能会作为单实例沙箱使用。</p>
</blockquote>
<h3> LegacySandbox</h3>
<p>我们先来看看 LegacySandbox 沙箱是怎么进行状态隔离的（见下图）</p>

<p>我们来分析一下 LegacySandbox 类的几个属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>addedPropsMapInSandbox</code></td>
<td style="text-align:left">记录沙箱运行期间新增的全局变量</td>
</tr>
<tr>
<td style="text-align:left"><code>modifiedPropsOriginalValueMapInSandbox</code></td>
<td style="text-align:left">记录沙箱运行期间更新的全局变量</td>
</tr>
<tr>
<td style="text-align:left"><code>currentUpdatedPropsValueMap</code></td>
<td style="text-align:left">记录沙箱运行期间操作过的全局变量。上面两个 <code>Map</code> 用于 <code>关闭沙箱</code> 时还原全局状态，而 <code>currentUpdatedPropsValueMap</code> 是在 <code>激活沙箱</code> 时还原沙箱的独立状态</td>
</tr>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">沙箱名称</td>
</tr>
<tr>
<td style="text-align:left"><code>proxy</code></td>
<td style="text-align:left">代理对象，可以理解为子应用的 <code>global/window</code> 对象</td>
</tr>
<tr>
<td style="text-align:left"><code>sandboxRunning</code></td>
<td style="text-align:left">当前沙箱是否在运行中</td>
</tr>
<tr>
<td style="text-align:left"><code>active</code></td>
<td style="text-align:left">激活沙箱，在子应用挂载时启动</td>
</tr>
<tr>
<td style="text-align:left"><code>inactive</code></td>
<td style="text-align:left">关闭沙箱，在子应用卸载时启动</td>
</tr>
<tr>
<td style="text-align:left"><code>constructor</code></td>
<td style="text-align:left">构造函数，创建沙箱环境</td>
</tr>
</tbody>
</table>
<p>我们现在从 window.Proxy 的 set 和 get 属性来详细讲解 LegacySandbox 是如何实现沙箱运行环境的。（见下图）</p>

<blockquote>
<p>注意：子应用沙箱中的 proxy 对象（第 62 行）可以简单理解为子应用的 window 全局对象（代码如下），子应用对全局属性的操作就是对该 proxy 对象属性的操作，带着这份理解继续往下看吧。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 第 65~72 行中，当调用 set 向子应用 proxy/window 对象设置属性时，所有的属性设置和更新都会先记录在 addedPropsMapInSandbox 或 modifiedPropsOriginalValueMapInSandbox 中，然后统一记录到currentUpdatedPropsValueMap 中。</p>
<p>在 第 73 行 中修改全局 window 的属性，完成值的设置。</p>
<p>当调用 get 从子应用 proxy/window 对象取值时，会直接从 window 对象中取值。对于非构造函数的取值将会对 this 指针绑定到 window 对象后，再返回函数。</p>
<p>LegacySandbox 的沙箱隔离是通过激活沙箱时还原子应用状态，卸载时还原主应用状态（子应用挂载前的全局状态）实现的，具体实现如下（见下图）。</p>

<p>从上图可以看出：</p>
<p>第 37 行：在激活沙箱时，沙箱会通过 currentUpdatedPropsValueMap 查询到子应用的独立状态池（沙箱可能会激活多次，这里是沙箱曾经激活期间被修改的全局变量），然后还原子应用状态。</p>
<p>第 44~45 行：在关闭沙箱时，通过 addedPropsMapInSandbox 删除在沙箱运行期间新增的全局变量，通过 modifiedPropsOriginalValueMapInSandbox 还原沙箱运行期间被修改的全局变量，从而还原到子应用挂载前的状态。</p>
<p>从上面的分析可以得知，LegacySandbox 的沙箱隔离机制利用快照模式实现，我们画一张图来帮助理解（见下图）</p>

<h3> 多实例沙箱 - ProxySandbox</h3>
<p>ProxySandbox 是一种新的沙箱模式，目前用于多实例模式的状态隔离。在稳定后以后可能会成为 单实例沙箱，我们来看看 ProxySandbox 沙箱是怎么进行状态隔离的（见下图）</p>

<p>我们来分析一下 ProxySandbox 类的几个属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>updateValueMap</code></td>
<td style="text-align:left">记录沙箱中更新的值，也就是每个子应用中独立的状态池</td>
</tr>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">沙箱名称</td>
</tr>
<tr>
<td style="text-align:left"><code>proxy</code></td>
<td style="text-align:left">代理对象，可以理解为子应用的 <code>global/window</code> 对象</td>
</tr>
<tr>
<td style="text-align:left"><code>sandboxRunning</code></td>
<td style="text-align:left">当前沙箱是否在运行中</td>
</tr>
<tr>
<td style="text-align:left"><code>active</code></td>
<td style="text-align:left">激活沙箱，在子应用挂载时启动</td>
</tr>
<tr>
<td style="text-align:left"><code>inactive</code></td>
<td style="text-align:left">关闭沙箱，在子应用卸载时启动</td>
</tr>
<tr>
<td style="text-align:left"><code>constructor</code></td>
<td style="text-align:left">构造函数，创建沙箱环境</td>
</tr>
</tbody>
</table>
<p>我们现在从 window.Proxy 的 set 和 get 属性来详细讲解 ProxySandbox 是如何实现沙箱运行环境的。（见下图）</p>

<blockquote>
<p>注意：子应用沙箱中的 proxy 对象可以简单理解为子应用的 window 全局对象（代码如下），子应用对全局属性的操作就是对该 proxy 对象属性的操作，带着这份理解继续往下看吧。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当调用 set 向子应用 proxy/window 对象设置属性时，所有的属性设置和更新都会命中 updateValueMap，存储在 updateValueMap 集合中（第 38 行），从而避免对 window 对象产生影响（旧版本则是通过 diff 算法还原 window 对象状态快照，子应用之间的状态是隔离的，而父子应用之间 window 对象会有污染）。</p>
<p>当调用 get 从子应用 proxy/window 对象取值时，会优先从子应用的沙箱状态池 updateValueMap 中取值，如果没有命中才从主应用的 window 对象中取值（第 49 行）。对于非构造函数的取值将会对 this 指针绑定到 window 对象后，再返回函数。</p>
<p>如此一来，ProxySandbox 沙箱应用之间的隔离就完成了，所有子应用对 proxy/window 对象值的存取都受到了控制。设置值只会作用在沙箱内部的 updateValueMap 集合上，取值也是优先取子应用独立状态池（updateValueMap）中的值，没有找到的话，再从 proxy/window 对象中取值。</p>
<p>相比较而言，ProxySandbox 是最完备的沙箱模式，完全隔离了对 window 对象的操作，也解决了快照模式中子应用运行期间仍然会对 window 造成污染的问题。</p>
<p>我们对 ProxySandbox 沙箱画一张图来加深理解（见下图）</p>

<h3> SnapshotSandbox</h3>
<p>在不支持 window.Proxy 属性时，将会使用 SnapshotSandbox 沙箱，我们来看看其内部实现（见下图）</p>

<p>我们来分析一下 SnapshotSandbox 类的几个属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">沙箱名称</td>
</tr>
<tr>
<td style="text-align:left"><code>proxy</code></td>
<td style="text-align:left">代理对象，此处为 <code>window</code> 对象</td>
</tr>
<tr>
<td style="text-align:left"><code>sandboxRunning</code></td>
<td style="text-align:left">当前沙箱是否激活</td>
</tr>
<tr>
<td style="text-align:left"><code>windowSnapshot</code></td>
<td style="text-align:left"><code>window</code> 状态快照</td>
</tr>
<tr>
<td style="text-align:left"><code>modifyPropsMap</code></td>
<td style="text-align:left">沙箱运行期间被修改过的 <code>window</code> 属性</td>
</tr>
<tr>
<td style="text-align:left"><code>constructor</code></td>
<td style="text-align:left">构造函数，激活沙箱</td>
</tr>
<tr>
<td style="text-align:left"><code>active</code></td>
<td style="text-align:left">激活沙箱，在子应用挂载时启动</td>
</tr>
<tr>
<td style="text-align:left"><code>inactive</code></td>
<td style="text-align:left">关闭沙箱，在子应用卸载时启动</td>
</tr>
</tbody>
</table>
<p>SnapshotSandbox 的沙箱环境主要是通过激活时记录 window 状态快照，在关闭时通过快照还原 window 对象来实现的。（见下图）</p>

<p>我们先看 active 函数，在沙箱激活时，会先给当前 window 对象打一个快照，记录沙箱激活前的状态（第 38~40 行）。打完快照后，函数内部将 window 状态通过 modifyPropsMap 记录还原到上次的沙箱运行环境，也就是还原沙箱激活期间（历史记录）修改过的 window 属性。</p>
<p>在沙箱关闭时，调用 inactive 函数，在沙箱关闭前通过遍历比较每一个属性，将被改变的 window 对象属性值（第 54 行）记录在 modifyPropsMap 集合中。在记录了 modifyPropsMap 后，将 window 对象通过快照 windowSnapshot 还原到被沙箱激活前的状态（第 55 行），相当于是将子应用运行期间对 window 造成的污染全部清除。</p>
<p>SnapshotSandbox 沙箱就是利用快照实现了对 window 对象状态隔离的管理。相比较 ProxySandbox 而言，在子应用激活期间，SnapshotSandbox 将会对 window 对象造成污染，属于一个对不支持 Proxy 属性的浏览器的向下兼容方案。</p>
<p>我们对 SnapshotSandbox 沙箱画一张图来加深理解（见下图）</p>

<h2> 挂载沙箱 - mountSandbox</h2>

<p>我们继续回到这张图，genSandbox 函数不仅返回了一个 sandbox 沙箱，还返回了一个 mount 和 unmount 方法，分别在子应用挂载时和卸载时的时候调用。</p>
<p>我们先看看 mount 函数内部（见下图）</p>

<p>首先，在 mount 内部先激活了子应用沙箱（第 26 行），在沙箱启动后开始劫持各类全局监听（第 27 行），我们这里重点看看 patchAtMounting 内部是怎么实现的。（见下图）</p>

<p>patchAtMounting 内部调用了下面四个函数：</p>
<ul>
<li>patchTimer（计时器劫持）</li>
<li>patchWindowListener（window 事件监听劫持）</li>
<li>patchHistoryListener（window.history 事件监听劫持）</li>
<li>patchDynamicAppend（动态添加 Head 元素事件劫持）</li>
</ul>
<p>上面四个函数实现了对 window 指定对象的统一劫持，我们可以挑一些解析看看其内部实现。</p>
<h3> 计时器劫持 - patchTimer</h3>
<p>我们先来看看 patchTimer 对计时器的劫持（见下图）</p>

<p>从上图可以看出，patchTimer 内部将 setInterval 进行重载，将每个启用的定时器的 intervalId 都收集起来（第 23~24 行），以便在子应用卸载时调用 free 函数将计时器全部清除（见下图）</p>

<p>我们来看看在子应用加载时的 setInterval 函数验证即可（见下图）</p>

<p>从上图可以看出，在进入子应用时，setInterval 已经被替换成了劫持后的函数，防止全局计时器泄露污染。</p>
<h3> 动态添加样式表和脚本文件劫持 - patchDynamicAppend</h3>
<p>patchWindowListener 和 patchHistoryListener 的实现都与 patchTimer 实现类似，这里就不作复述了。</p>
<p>我们需要重点对 patchDynamicAppend 函数进行解析，这个函数的作用是劫持对 head 元素的操作（见下图）</p>

<p>从上图可以看出，patchDynamicAppend 主要是对动态添加的 style 样式表和 script 标签做了处理。</p>
<p>我们先看看对 style 样式表的处理（见下图）</p>

<p>从上图可以看出，主要的处理逻辑在 第 68~74 行，如果当前子应用处于激活状态（判断子应用的激活状态主要是因为：当主应用切换路由时可能会自动添加动态样式表，
此时需要避免主应用的样式表被添加到子应用head节点中导致出错），那么动态 style 样式表就会被添加到子应用容器内（见下图），在子应用卸载时样式表也可以和子应用一起被卸载，从而避免样式污染。
同时，动态样式表也会存储在 dynamicStyleSheetElements 数组中，在后面还会提到其用处。</p>

<p>我们再来看看对 script 脚本文件的处理（见下图）</p>

<p>对动态 script 脚本文件的处理较为复杂一些，我们也来解析一波：</p>
<p>在 第 83~101 行 处对外部引入的 script 脚本文件使用 fetch 获取，然后使用 execScripts 指定 proxy 对象（作为 window 对象）后执行脚本文件内容，同时也触发了 load 和 error 两个事件。</p>
<p>在 第 103~106 行 处将注释后的脚本文件内容以注释的形式添加到子应用容器内。</p>
<p>在 第 109~113 行 是对内嵌脚本文件的执行过程，就不作复述了。</p>
<p>我们可以看出，对动态添加的脚本进行劫持的主要目的就是为了将动态脚本运行时的 window 对象替换成 proxy 代理对象，使子应用动态添加的脚本文件的运行上下文也替换成子应用自身。</p>
<p>HTMLHeadElement.prototype.removeChild 的逻辑就是多加了个子应用容器判断，其他无异，就不展开说了。</p>
<p>最后我们来看看 free 函数（见下图）</p>

<p>这个 free 函数与其他的 patches（劫持函数） 实现不太一样，这里缓存了一份 cssRules，在重新挂载的时候会执行 rebuild 函数将其还原。
这是因为样式元素 DOM 从文档中删除后，浏览器会自动清除样式元素表。如果不这么做的话，在重新挂载时会出现存在 style 标签，但是没有渲染样式的问题。</p>
<h2> 卸载沙箱 - unmountSandbox</h2>
<p>我们再回到 mount 函数本身（见下图）</p>

<p>从上图可以看出，在 patchAtMounting 函数中劫持了各类全局监听，并返回了解除劫持的 free 函数。在卸载应用时调用 free 函数解除这些全局监听的劫持行为（见下图）</p>

<p>从上图可以看到 sideEffectsRebuilders 在 free 后被返回，在 mount 的时候又将被调用 rebuild 重建动态样式表。这块环环相扣，是稍微有点绕，没太看明白的同学可以翻上去再看一遍。</p>
<p>到这里，qiankun 的最核心部分-沙箱机制，我们就已经解析完毕了，接下来我们继续剖析别的部分。</p>
<p>在这里我们画一张图，对沙箱的创建过程进行一个总梳理（见下图）</p>

<h3> 注册内部生命周期函数</h3>
<p>在创建好了沙箱环境后，在 第 100~106 行 注册了一些内部生命周期函数（见下图）</p>

<p>在上图中，第 106 行 的 mergeWith 方法的作用是将内置的生命周期函数与传入的 lifeCycles 生命周期函数。</p>
<blockquote>
<p>这里的 lifeCycles 生命周期函数指的是全子应用共享的生命周期函数，可用于执行多个子应用间相同的逻辑操作，例如 加载效果 之类的。（见下图）</p>
</blockquote>

<p>除了外部传入的生命周期函数外，我们还需要关注 qiankun 内置的生命周期函数做了些什么（见下图）</p>

<p>我们对上图的代码进行逐一解析：</p>
<ul>
<li>第 13~15 行：在加载子应用前 beforeLoad（只会执行一次）时注入一个环境变量，指示了子应用的 public 路径。</li>
<li>第 17~19 行：在挂载子应用前 beforeMount（可能会多次执行）时可能也会注入该环境变量。</li>
<li>第 23~30 行：在卸载子应用前 beforeUnmount 时将环境变量还原到原始状态。</li>
</ul>
<p>通过上面的分析我们可以得出一个结论，我们可以在子应用中获取该环境变量，将其设置为 <strong>webpack_public_path</strong> 的值，从而使子应用在主应用中运行时，可以匹配正确的资源路径。（见下图）</p>

<h3> 触发 beforeLoad 生命周期钩子函数</h3>
<p>在注册完了生命周期函数后，立即触发了 beforeLoad 生命周期钩子函数（见下图）</p>

<p>从上图可以看出，在 第 108 行 中，触发了 beforeLoad 生命周期钩子函数。</p>
<p>随后，在 第 110 行 执行了 import-html-entry 的 execScripts 方法。指定了脚本文件的运行沙箱（jsSandbox），执行完子应用的脚本文件后，返回了一个对象，对象包含了子应用的生命周期钩子函数（见下图）。</p>

<p>在 第 112~121 行 对子应用的生命周期钩子函数做了个检测，如果在子应用的导出对象中没有发现生命周期钩子函数，会在沙箱对象中继续查找生命周期钩子函数。如果最后没有找到生命周期钩子函数则会抛出一个错误，所以我们的子应用一定要有 bootstrap, mount, unmount 这三个生命周期钩子函数才能被 qiankun 正确嵌入到主应用中。</p>
<p>这里我们画一张图，对子应用挂载前的初始化过程做一个总梳理（见下图）</p>

<h3> 进入到 mount 挂载流程</h3>
<p>在一些初始化配置（如 子应用资源、运行沙箱环境、生命周期钩子函数等等）准备就绪后，qiankun 内部将其组装在一起，返回了三个函数作为 single-spa 内部的生命周期函数</p>
<p>single-spa 内部的逻辑我们后面再展开说，这里我们可以简单理解为 single-spa 内部的三个生命周期钩子函数：</p>
<ul>
<li>bootstrap：子应用初始化时调用，只会调用一次；</li>
<li>mount：子应用挂载时调用，可能会调用多次；</li>
<li>unmount：子应用卸载时调用，可能会调用多次；</li>
</ul>
<p>我们可以看出，在 bootstrap 阶段调用了子应用暴露的 bootstrap 生命周期函数。</p>
<p>我们这里对 mount 阶段进行展开，看看在子应用 mount 阶段执行了哪些函数（见下</p>

<p>我们进行逐行解析：</p>
<ul>
<li>第 127~133 行：对单实例模式进行检测。在单实例模式下，新的子应用挂载行为会在旧的子应用卸载之后才开始。（由于这里是串行顺序执行，所以如果某一处发生阻塞的话，会阻塞所有后续的函数执行）</li>
<li>第 134 行：执行注册子应用时传入的 render 函数，将 HTML Template 和 loading 作为入参。这里一般是在发生了一次 unmount 后，再次进行 mount 挂载行为时将 HTML 挂载在指定容器中（见下图）</li>
</ul>
<blockquote>
<p>由于初始化的时候已经调用过一次 render，所以在首次调用 mount 时可能已经执行过一次 render 方法。</p>
<p>在下面的代码中也有对重复挂载的情况进行判断的语句 - if (frame.querySelector("div") === null，防止重复挂载子应用。</p>
</blockquote>

<ul>
<li>第 135 行：触发了 beforeMount 全局生命周期钩子函数；</li>
<li>第 136 行：挂载沙箱，这一步中激活了对应的子应用沙箱，劫持了部分全局监听（如 setInterval）。此时开始子应用的代码将在沙箱中运行。（反推可知，在 beforeMount 前的部分全局操作将会对主应用造成污染，如 setInterval）</li>
<li>第 137 行：触发子应用的 mount 生命周期钩子函数，在这一步通常是执行对应的子应用的挂载操作（如 ReactDOM.render、Vue.$mount。（见下图）</li>
</ul>

<ul>
<li>第 138 行：再次调用 render 函数，此时 loading 参数为 false，代表子应用已经加载完成。</li>
<li>第 139 行：触发了 afterMount 全局生命周期钩子函数；</li>
<li>第 140~144 行：在单实例模式下设置 prevAppUnmountedDeferred 的值，这个值是一个 promise，在当前子应用卸载时才会被 resolve，在该子应用运行期间会阻塞其他子应用的挂载动作（第 134 行）；</li>
</ul>
<p>我们在上面很详细的剖析了整个子应用的 mount 挂载流程，如果你还没有搞懂的话，没关系，我们再画一个流程图来帮助理解。（见下图）</p>

<h3> 进入到 unmount 卸载流程</h3>
<p>我们刚才梳理了子应用的 mount 挂载流程，我们现在就进入到子应用的 unmount 卸载流程。在子应用激活阶段， activeRule 未命中时将会触发 unmount 卸载行为，具体的行为如下（见下图）</p>

<p>从上图我们可以看出，unmount 卸载流程要比 mount 简单很多，我们直接来梳理一下：</p>
<ul>
<li>
<p>第 148 行：触发了 beforeUnmount 全局生命周期钩子函数；</p>
</li>
<li>
<p>第 149 行：这里与 mount 流程的顺序稍微有点不同，这里先执行了子应用的 unmount 生命周期钩子函数，保证子应用仍然是运行在沙箱内，避免造成状态污染。在这里一般是对子应用的一些状态进行清理和卸载操作。（如下图，销毁了刚才创建的 vue 实例）</p>
</li>
<li>
<p>第 150 行：卸载沙箱，关闭了沙箱的激活状态。</p>
</li>
<li>
<p>第 151 行：触发了 afterUnmount 全局生命周期钩子函数；</p>
</li>
<li>
<p>第 152 行：触发 render 方法，并且传入的 appContent 为空字符串，此处可以清空主应用容器内的内容。</p>
</li>
<li>
<p>第 153~156 行：当前子应用卸载完成后，在单实例模式下触发 prevAppUnmountedDeferred.resolve()，使其他子应用的挂载行为得以继续进行，不再阻塞。</p>
</li>
</ul>
<p>我们对 unmount 卸载流程也画一张图，帮助大家理解（见下图）。</p>

<h2> 总结</h2>
<p>到这里，我们对 qiankun 框架的总流程梳理就差不多了。这里应该做个总结，大家看了这么多文字，估计大家也看累了，最后用一张图对 qiankun 的总流程进行总结吧。</p>

<h2> 彩蛋</h2>

<h2> 展望</h2>
<p>传统的云控制台应用，几乎都会面临业务快速发展之后，单体应用进化成巨石应用的问题。我们要如何维护一个巨无霸中台应用？</p>
<p>上面这个问题引出了微前端架构理念，所以微前端的概念也越来越火，我们团队最近也在尝试转型微前端架构。</p>
<p>工欲善其事必先利其器，所以针对 qiankun 的源码进行解读，在分享知识的同时也是帮助自己理解。</p>

]]></content:encoded>
    </item>
    <item>
      <title>浏览器缓存</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Network/BrowserCache/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Network/BrowserCache/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">浏览器缓存</source>
      <description>什么是web缓存？ web缓存主要指的是两部分：浏览器缓存和http缓存。 http缓存是web缓存的核心，是最难懂的那一部分,也是最重要的那一部分。 浏览器缓存：例如 localStorage(5M)、sessionStorage(5M)、cookie(4k)等等。这些功能主要用于缓存一些必要的数据，比如用户信息。比如需要携带到后端的参数。亦或者是一些列表数据等等。 缓存可以解决什么问题？ 减少不必要的网络传输，节约宽带（就是省钱） 更快的加载页面（就是加速） 减少服务器负载，避免服务器过载的情况出现。（就是减载） 缺点是什么？ 占内存（有些缓存会被存到内存中）</description>
      <category>Network</category>
      <pubDate>Thu, 22 Sep 2022 10:15:04 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是web缓存？</h2>
<p><code>web缓存</code>主要指的是两部分：<code>浏览器缓存</code>和<code>http缓存</code>。</p>
<p>http缓存是web缓存的核心，是最难懂的那一部分,也是最重要的那一部分。</p>
<p>浏览器缓存：例如 <code>localStorage(5M)</code>、<code>sessionStorage(5M)</code>、<code>cookie(4k)</code>等等。这些功能主要用于缓存一些必要的数据，比如用户信息。比如需要携带到后端的参数。亦或者是一些列表数据等等。</p>
<h2> 缓存可以解决什么问题？</h2>
<ol>
<li>减少不必要的网络传输，节约宽带（就是<code>省钱</code>）</li>
<li>更快的加载页面（就是<code>加速</code>）</li>
<li>减少服务器负载，避免服务器过载的情况出现。（就是<code>减载</code>）</li>
</ol>
<h2> 缺点是什么？</h2>
<ol>
<li>占内存（有些缓存会被存到内存中）</li>
</ol>
<!-- more -->
<h2> http缓存</h2>
<div class="hint-container info">
<p class="hint-container-title">官方介绍</p>
<p><code>Web缓存</code>是可以<code>自动保存</code>常见文档副本的 <code>HTTP设备</code>。当<code>Web请求</code>抵达缓存时，如果本地有<code>已缓存的</code>副本，就可以从<code>本地存储设备</code>而不是<code>原始服务器</code>中提取这个文档。</p>
</div>
<p>服务器需要处理<code>http</code>的请求，而缓存，就是为了让服务器<code>不去处理</code>这个请求，客户端也可以<code>拿到数据</code>。</p>
<p>注意，缓存主要是针对<code>html</code>、<code>css</code>、<code>img</code>等<code>静态资源</code>，常规情况下，<strong>不会去缓存一些动态资源</strong>。</p>
<h3> 大纲</h3>
<p><strong>我们把<code>http缓存</code>问题拆分下，可以从以下几个方面来回答这个问题:</strong></p>
<ul>
<li>缓存的类型 (<code>强缓存</code>or<code>协商缓存</code>)</li>
<li>缓存位置 (<code>Service Worker</code>、<code>Memory Cache</code>...)</li>
<li>缓存过程分析</li>
<li>缓存策略的实际场景应用</li>
</ul>
<h3> 缓存的类型</h3>
<p>首先从缓存的类型上来说，可以分为两种: <strong>强缓存</strong> 与 <strong>协商缓存</strong></p>
<p>强缓存是<strong>不需要发送HTTP请求的，而协商缓存需要</strong></p>
<p>也就是在<strong>发送HTTP请求之前</strong>，浏览器会<strong>先检查</strong>一下<code>强缓存</code>，如果命中直接使用，否则就进入下一步。</p>
<h4> 强缓存</h4>
<p>浏览器检查强缓存的方式主要是判断这两个字段:</p>
<ul>
<li><code>HTTP/1.0</code>使用的是<code>Expires</code>;</li>
<li><code>HTTP/1.1</code>使用的是<code>Cache-Control</code>;</li>
</ul>
<h5> Expires</h5>
<p>Expires字面意思是<code>有效期</code>，那么很好理解，它表示的就是一个具体的时间</p>
<p>例如:</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表示这个资源在<strong>2020年11月11日8点</strong>之前，都会去<strong>本地的磁盘（或内存）中读取</strong>，不会去服务器请求。过了这个时间就得<strong>向服务端发请求</strong>了。</p>
<div class="hint-container info">
<p class="hint-container-title">很有意思的是</p>
<p><code>Expires</code>过度<strong>依赖本地时间</strong>，如果 <strong>本地与服务器时间不同步</strong>，就会出现资源 <strong>无法被缓存</strong> 或者 <strong>资源永远被缓存</strong> 的情况。</p>
<p>若是设置了<code>Expires</code>，但是 <strong>服务器的时间</strong> 与 <strong>浏览器的时间</strong> <strong>不一致</strong> 的时候(比如你手动修改了本地的时间)，</p>
<p>那么就可能会造成<strong>缓存失效</strong>，因此这种方式强缓存方式并不是很准确，它也因此在<code>HTTP/1.1</code>中被<strong>摒弃</strong>了。</p>
</div>
<h5> Cache-Control</h5>
<p>摒弃了Expires之后，HTTP/1。1采用了Cache-Control这个重要的规则。<br>
它设置的是一个具体的过期时长，其中的一个属性是max-age。</p>
<p>例如🌰:</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表示的是这个资源在响应之后的300s内过期，也就是5分钟之内再次获取这个资源会直接使用缓存。</p>
<p>Cache-Control不仅仅有max-age&nbsp;这一个属性，其实它有很多的用法，你甚至可以采用组合的方式:</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面用法的意思是响应可以被任何对象(客户端，代理服务器等)缓存，且过期时长为5分钟。
(因为一个请求经历的不仅仅是客户端(浏览器)和目标服务器，它中间有可能会经过不同的代理服务器)</p>
<p>下面来例举一些常用的指令:</p>
<ul>
<li>public: 客户端和代理服务器都可以缓存。</li>
</ul>
<blockquote>
<p>响应可以被中间任何的一个节点缓存，比如一个请求要经历 Browser -&gt; proxy1 -&gt; proxy2 -&gt; Server，中间的代理(proxy)可以缓存资源。 下次再请求同一资源的时候，浏览器就会直接到proxy1中拿缓存的东西而不必向proxy2拿。</p>
</blockquote>
<ul>
<li>private: 这个是Cache-Control默认的取值，只有客户端可以缓存，中间节点不允许缓存。</li>
</ul>
<blockquote>
<p>在 Browser -&gt; proxy1 -&gt; proxy2 -&gt; Server 这个过程中，代理(proxy)不会缓存任何数据，当Browser再次请求时，proxy会把Server返回的数据发送给Brower，做好请求转发，而不是给自己缓存的数据。</p>
</blockquote>
<ul>
<li>no-cache: 表示不进行强缓存验证，而是用协商缓存来验证。</li>
<li>no-store: 所有内容都不会被缓存，不进行强缓存，也不进行协商缓存。</li>
<li>max-age: 表示在多久之后过期，比如max-age=300表示在300s后缓存内容失效。</li>
<li>s-max-age: 它的作用和max-age很像， 不过max-age 用于普通缓存，而s-max-age用于代理缓存，且s-max-age的优先级更高。</li>
<li>max-stale: 能容忍的最大过期时间。</li>
</ul>
<blockquote>
<p>max-stale指令表示客户端愿意接收一个已经过期了的响应。</p>
</blockquote>
<ul>
<li>min-fresh：能够容忍的最小新鲜度。</li>
</ul>
<blockquote>
<p>min-fresh表示客户端不愿意接受新鲜度不多于当前的age加上min-fresh设定的时间之和的响应。</p>
</blockquote>
<p>基于上面的这些指令，我们可以将它们进行组合，达到多个目的， 不同的效果。
有一张来自<a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener noreferrer">《浪里行舟-深入理解浏览器的缓存机制》</a>中的图表述的非常好:</p>

<h4> Expires和Cache-control的对比</h4>
<ul>
<li>Expires产于HTTP/1。0，Cache-control产于HTTP/1。1;</li>
<li>Expires设置的是一个具体的时间，Cache-control&nbsp;可以设置具体时常还有其它的属性;</li>
<li>两者同时存在，Cache-control的优先级更高;</li>
<li>在不支持HTTP/1。1的环境下，Expires就会发挥作用，所以先阶段的存在是为了做一些兼容的处理。</li>
</ul>
<h3> 协商缓存</h3>
<p>在上面我们已经介绍了强缓存，它是不需要发送HTTP请求的，若是强缓存失效，则会进入协商缓存。</p>
<p>协商缓存概括来说 就是浏览器会携带缓存标识(tag)向服务器发送请求，服务器会根据缓存标识(tag)来决定是否使用缓存。</p>
<p>所以对于服务器的返回结果会有这两种情况:</p>
<ul>
<li>协商缓存生效，返回304和Not Modified(空的响应体)</li>
<li>协商缓存失效，返回200和请求结果</li>
</ul>
<p>而刚刚提到的这个缓存标识(tag)也是有两种。</p>
<p>分为Last-Modified和 ETag。</p>
<h4> Last-Modified 和 If-Modified-Since</h4>
<p>从字面意思上我们可以看出，Last-Modified表示的是资源的最后修改时间，因此其中一种协商缓存判断的就是最后修改时间。</p>
<p>那它具体是怎样实现的呢?</p>
<p>其实使用Last-Modified进行协商缓存会经过以下几步:</p>
<ol>
<li>浏览器第一次向服务器请求这个资源</li>
<li>服务器在返回这个资源的时候，在response header中添加Last-Modified的header，值为该资源在服务器上最后的修改时间</li>
<li>浏览器接收到后缓存文件和这个header</li>
<li>当下次浏览器再次请求这个资源的时候， 检测到有Last-Modified这个header，就会在请求头中添加If-Modified-Since这个header，该值就是Last-Modified</li>
<li>服务器再次接收到该资源的请求，则根据If-Modified-Since与服务器中的这个资源的最后修改时间做对比</li>
<li>对比结果相同则返回304和一个空的响应体，告诉浏览器从自己(浏览器)的缓存中拿</li>
<li>对比结果不同(If-Modified-Since &lt; 服务器资源最后修改时间)，则表示资源被修改了，则返回200和最新的资源文件(当然还包括最新的Last-Modefied)</li>
</ol>

<h4> ETag 与 If-None-Match</h4>
<p>ETag其实与Last-Modefied的原理差不多，不过它不是根据资源的最后修改时间来判断的，而是通过一个唯一的标识。</p>
<p>在浏览器请求服务器资源的时候，服务器会根据当前文件的内容，给文件生成一个唯一的标识，若是文件发生了改变，则这个标识就会改变。</p>
<p>服务器会将这个标识ETag放到响应体的header中与请求的资源一起返回给浏览器，而浏览器同样也会缓存文件与这个header。</p>
<p>在下一次再次加载该资源时，浏览器会将刚刚缓存的ETag放到请求体头部(request header)的If-None-Match里发送给服务器。</p>
<p>同样的服务器接收到了之后与该资源自身的ETag做对比，如果一致，则表示该资源未发生改变，则直接返回304知会客户端直接使用本地缓存即可。 若是不一致，则返回200和最新的资源文件(当然还包括最新的ETag)</p>
<p>如下图:</p>

<h4> 两者对比</h4>
<p>在进行对比之前，我们先来看看两者都有什么优缺点呢?</p>
<p>首先对于Last-Modified:</p>
<ul>
<li>若是本地打开了缓存文件，并没有进行修改，也还是会改变最后修改时间，导致缓存失败;</li>
<li>由于Last-Modified是以秒来计时的，若是某个文件在一秒内被修改了很多次，那么这时候的 Last-Modified 并没有体现出修改了。</li>
</ul>
<p>然后对于ETag:</p>
<ul>
<li>性能上的不足,只要文件发生改变,ETag就会发生改变。  ETag需要服务器通过算法来计算出一个hash值。</li>
</ul>
<p><strong>总结，所以对于两种协商缓存:</strong></p>
<ul>
<li>准确度上ETag更强;</li>
<li>性能上Last-Modified更好;</li>
<li>两者都支持的话，ETag优先级更高。</li>
</ul>
<h2> 缓存位置</h2>
<p>在上面我们已经介绍完了缓存的类型，但是之前也提到过了，若是命中了强缓存或者服务器返回了304之后，
要浏览器从缓存中过去资源，那这些缓存具体是存储在哪里呢?</p>
<p>从优先级上来说分为以下四种:</p>
<ul>
<li>Service Worker</li>
<li>Memory Cache</li>
<li>Disk Cache</li>
<li>Push Cache</li>
</ul>
<h3> Service Worker</h3>
<p>Service Worker是运行在浏览器背后的独立线程，也就是说它脱离了浏览器的窗体，无法直接访问DOM。
功能上主要是能实现: 离线缓存、消息推送、网络代理等。比如离线缓存就是Service Worker Cache。</p>
<p>简单来说，它有以下几个特点:</p>
<ul>
<li>借鉴了Web Worker的思路</li>
<li>使用Service Worker会涉及到请求拦截，所以需要用HTTPS协议来保证安全，传输协议必须是HTTPS</li>
<li>与浏览器其它内建的缓存机制不同，它可以让我们自由的控制缓存哪些文件、如何匹配读取缓存，且缓存是持续性的</li>
<li>Service Worker同时也是PWA的重要实现机制</li>
</ul>
<h3> Memory Cache</h3>
<p>从命名上来说，Memory Cache就是内存中的缓存，存储的主要是当前页面已经抓取到的资源，
比如页面上已经下载的样式、脚本、图片等。</p>
<p>Memory Cache的特点:</p>
<ul>
<li>读取效率快，可是缓存持续时间短，会随着进程的释放而释放(一旦关闭Tab页面，就被释放了，还有可能在没关闭之前，排在前面的缓存就失效了，例如一个页面的缓存占用了超级多的内存)</li>
<li>几乎所有的请求资源都能进入memory Cache，细分来说主要分为preloader和preload这两块。</li>
<li>在从memory Cache读取缓存时，浏览器会忽视Cache-Control中的一些max-age、no-cache等头部配置，除非设置了no-store这个头部配置。</li>
</ul>
<p><strong>preloader</strong></p>
<p>上面提到的preloader是页面优化的常见手段之一，它的作用主要是用于在浏览器打开一个网页的时候,能够一边解析执行js/css，一边去请求下一个资源，而这些被 preloader 请求来的资源就会被放入 memory Cache 中，供之后的解析执行操作使用。</p>
<p><strong>preload</strong></p>
<p>preload与preloader仅两个字母之差，它能显式指定预加载的资源，这些资源也会被放进memory Cache中，例如<link rel="preload"></p>
<h3> Disk Cache</h3>
<p>Disk Cache，也叫做HTTP Cache，是存储在硬盘上的缓存，所以它是持久存储，是实际存在于文件系统中的。</p>
<p>从存储效率上说，它比内存缓存慢，但是优势在于存储容量更大，且存储时长更长。</p>
<p>在所有浏览器缓存中，Disk Cache是覆盖面最大的。 它会根据前面我们提到的HTTP header中的缓存字段来判断哪些资源需要缓存，哪些资源不需要请求而直接使用，哪些已经过期了需要重新请求获取。</p>
<p>若是命中了缓存之后，浏览器会从硬盘中直接读取资源，虽然没有从内存中读取的快，但是却是比网络缓存快。</p>
<p>前面提到的强缓存和协商缓存也是属于Disk Cache，它们最终都存储在硬盘里。</p>
<p><strong>Memory Cache与Disk Cache两者的对比:</strong></p>
<ul>
<li>比较大的JS、CSS文件会被丢硬盘中存储，反之则存储在内存中</li>
<li>当前系统内存使用率比较高的时候，文件优先进入磁盘</li>
</ul>
<h3> Push Cache</h3>
<p>Push Cache(推送缓存)，它是浏览器缓存的最后一段防线，当以上三种缓存都没有命中的时候，它才会被使用。</p>
<p>我所知道的，它只会在会话(Session)中存在，一旦会话结束它就会被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟。</p>
<p>另外由于它是 HTTP/2 中的内容，因此在国内不是很普及，这里贴上一个比较好的总结:</p>
<ul>
<li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差</li>
<li>可以推送 no-cache 和 no-store 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>你可以给其他域名推送资源</li>
</ul>
<h2> 缓存过程分析</h2>
<p>上面已经向大家介绍了缓存类型已经缓存的位置，那么浏览器具体的一个缓存行径是怎样的呢?</p>
<p>从浏览器发起HTTP请求到获得请求结果，可以分为以下几个过程:</p>
<ol>
<li>浏览器第一次发起HTTP请求，在浏览器缓存中没有发现请求的缓存结果和缓存标识</li>
<li>因此向服务器发起HTTP请求，获得该请求的结果还有缓存规则(也就是Last-Modified 或者ETag)</li>
<li>浏览器把响应内容存入Disk Cache，把响应内容的引用存入Memory Cache</li>
<li>把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 cache.put())</li>
</ol>
<p>下一次请求相同资源的时候:</p>
<ol>
<li>调用Service Worker 的fetch事件响应</li>
<li>查看memory Cache</li>
<li>查看disk Cache。 这里细分为:</li>
</ol>
<blockquote>
<p>有强缓存且未失效，则使用强缓存，不请求服务器，返回的状态码都是200
有强缓存且已失效，使用协商缓存判断，是返回304还是200(读取缓存还是重新获取)</p>
</blockquote>
<h2> 缓存策略的实际场景应用</h2>
<p>说了这么多缓存策略，那么在实际使用上来说，我们一般是怎样使用它的呢?</p>
<p><strong>不常变化的资源</strong></p>
<p>对于不常变化的资源:</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通常是给Cache-Control设置成一个很大的值，(31536000，一年)。 这个也很好理解，不常变化的资源，直接让它使用缓存就是了。</p>
<p>但是有时候为了解决更新的问题，我们需要在文件名中添加上hash，版本号等动态字段，这样就达到了更改引用URL 的目的。</p>
<p><strong>常变化的资源</strong></p>
<p>经常变化的资源，我们进行以下配置:</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置成以上配置，使得浏览器每次都请求服务器，然后配合ETag或者Last-Modified来验证资源是否有效。</p>
<h2> 后语</h2>
<p>浏览器缓存的内容其实还有很多可以说的，这里主要是总结了一些面试时常问到的，你可以转化成自己的言语来回答面试官。</p>
]]></content:encoded>
    </item>
    <item>
      <title>跨域</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Network/CrossDomain/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Network/CrossDomain/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">跨域</source>
      <description>白话解释：所谓跨域其实就是浏览器对我们发送的接口请求进行拦截，不允许我们直接访问，浏览器就像是一个中间桥梁，它说让我们通过就让通过，它说不让通过那就通过不了。 发生跨域的三个必要条件： 一般情况，我们己的项目地址和接口地址的域名不同时，如：https://localhost:9527，也许会不假思索的就能回答出：不同协议，不同域名，不同端口。没有问题，但并不准确，我更倾向于把这三个叫 跨域的三要素 ，那什么是跨域形成的必要条件呢？ 浏览器限制： 即浏览器对跨域行为进行检测和阻止 触发跨域的三要素之一： 即协议、域名和端口三个条件满足其一 发起的是xhr请求： 即发起的是 XMLHttpRequest 类型的请求。</description>
      <category>Network</category>
      <pubDate>Wed, 01 Jun 2022 15:28:16 GMT</pubDate>
      <content:encoded><![CDATA[<p>白话解释：所谓跨域其实就是浏览器对我们发送的接口请求进行拦截，不允许我们直接访问，浏览器就像是一个中间桥梁，它说让我们通过就让通过，它说不让通过那就通过不了。</p>
<h2> 发生跨域的三个必要条件：</h2>
<p>一般情况，我们己的项目地址和接口地址的域名不同时，如：<a href="https://localhost:9527" target="_blank" rel="noopener noreferrer">https://localhost:9527</a>，也许会不假思索的就能回答出：<strong>不同协议，不同域名，不同端口</strong>。没有问题，但并不准确，我更倾向于把这三个叫 <strong>跨域的三要素</strong> ，那什么是跨域形成的必要条件呢？</p>
<blockquote>
<p>浏览器限制： 即浏览器对跨域行为进行检测和阻止</p>
<p>触发跨域的三要素之一： 即协议、域名和端口三个条件满足其一</p>
<p>发起的是xhr请求： 即发起的是 XMLHttpRequest 类型的请求。</p>
</blockquote>
<!-- more -->
<h2> 如何解决跨域？</h2>
<p>为了更好的理解这个知识点，我们先回顾一下一个普通项目的交互关系。客户端有各种各样的请求发送给中间服务器Apache / Nginx，中间服务器在接收到请求之后，判断如果是静态资源（img，js插件等）则直接返回客户端，如果是交互资源（例如访问@RequestMapping里的方法）则转发至应用服务器上。</p>
<p>现在大部分公司项目采用前后端分离的开发模式，使得客户端和服务器端通常都在不同服务器上，这种模式解决跨域主要有两种思路：</p>
<ul>
<li>第一种就是<strong>被调用方（即后端）解决</strong>：调用方在浏览器直接将请求发送至被调用方，被调用方处理完成后，在请求响应中添加基于http协议关于跨域请求的一些规定，就是在http响应头中添加Access-Control-Allow-Origin等一些配置允许跨域访问。这种解决方法是基于解决跨域的思路，修改的是被调用方的HTTP服务器，我们在浏览器中能看到有调用方的url，也有被调用方的url。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>第二种就是<strong>调用方（即前端）解决</strong>：这是基于隐藏跨域的解决办法。调用方通过一个代理服务器（Nginx）转发请求到被调用方的中间服务器，浏览器看到请求都是来自同一个域，就不会报跨域问题了。这种方式是基于隐藏跨域的思路，修改的是调用方的HTTP服务器(调用方的请求url是经过调用方的 Nginx 做反向代理转换转换的，目的就是为了和‘’被调用方”的域名端口一致)，在浏览器中也就只能看到调用方的url。</li>
</ul>
<h3> 补充后端解决跨域问题</h3>
<p>如果是在被调用方解决跨域问题，被调用方解决支持跨域办法如下：</p>
<ol>
<li>在应用服务器端实现</li>
<li>在Ngnix上配置</li>
<li>在Apache上配置</li>
<li>Spring框架解决</li>
</ol>
<p>虽然有4种方案，但是这4种方案的本质都是一样的，最终的目的是在响应头增加字段。浏览器在执行跨域请求时，如果遇到是简单请求，则先执行后判断；如果是非简单请求，则先使用OPTION向服务器发起一个预检请求 <strong>preflight request</strong> ，从而获知服务器是否允许该跨域访问，如果允许，就在此发起带真实数据的请求，否则不发起。这就实现了对被调用方的数据安全保护，也是跨域问题设计所在的目的之一。</p>
<blockquote>
<p>在介绍简单/非简单请求前，我们要了解什么是 Content-Type，<strong>Content-Type是指http/https发送信息至服务器时的内容编码类型</strong></p>
</blockquote>
<p><strong>【常见简单请求】</strong></p>
<ol>
<li>
<p>GET</p>
</li>
<li>
<p>HEAD</p>
</li>
<li>
<p>POST</p>
</li>
</ol>
<p>且它的Content-Type为text/plain（普通文本类型）或multipart/form-data（多媒体数据/表单数据）或application/x-www-form-urlencoded中的一种</p>
<p><strong>【常见非简单请求】</strong></p>
<ol>
<li>PUT</li>
<li>DELETE</li>
<li>OPTIONS</li>
<li>发送Json格式的Ajax请求[常为post]</li>
<li>带自定义Header信息的Ajax请求</li>
<li>CONNECT</li>
<li>TRACE</li>
<li>PATCH</li>
</ol>
<p>当浏览器发现发起的是一个跨域的请求时，它会向请求头里增加一个Origin字段，当请求被响应时，浏览器会检查响应头里有没有设置允许跨域的信息，如果没有，它就会报错。同理，如果给请求增加头信息，那么加入的信息也会作为跨域检查的信息。</p>
<ul>
<li><strong>举个例子</strong></li>
</ul>
<p>我们在本地搭起来了一个后端项目，端口号为8080；同时搭建了一个前端项目，端口号为9527。那这个时候我们直接调用后端接口的时候，前后端分离的原因导致我们需要跨域请求 。因此，在应用服务器端的响应头需要添加允许跨域的设置，即如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这时候，我们就可以在响应头Response Headers里观察到 <strong>Access-Control-Allow-Origin</strong> 和 <strong>Access-Control-Allow-Methods</strong> 信息，这代表跨域就被成功允许了。</p>
<ul>
<li><strong>还有一种特殊情况</strong></li>
</ul>
<p>带有Cookie的请求还需要注意一下两点才能实现跨域：</p>
<ol>
<li>Access-Control-Allow-Origin的值不能为 <strong>'*'</strong> 而是必须是精准匹配，因此需要添上具体的域名</li>
<li>打开允许Cookie的设置，即Access-Control-Allow-Credentials: true</li>
</ol>
<p>但是这又带出了另一个问题，就是只能支持一个域名的跨域，怎么办？其实该变量可以通过调用方的请求头信息获取，解决办法如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于需要增加请求头信息解决方案与此类似</p>
<p><strong>调用方解决跨域：反向代理</strong></p>
<p>当被调用方无法帮助解决处理跨域问题时，调用方也可以自己解决处理。其实现的办法就是利用反向代理</p>
<blockquote>
<p><strong>正向代理：</strong> 利用代理客户端去请求服务器，从而隐藏了真实的客户端，服务器并不知道客户端是谁，这种代理方式称作正向代理，其代理的对象是客户端</p>
<p><strong>反向代理:</strong> 反向代理隐藏了真正的服务端。举个例子，我们只知道敲下www.baidu.com时就能访问百度搜索页面，然而背后成千上万的服务器到底是哪一台正在为我们服务我们并不知道，这种隐藏了服务器端的代理方式称作反向代理，其代理的是服务器端。软件层面上常用Ngnix来做反向代理服务器，他的性能很好，用来做负载均衡。</p>
</blockquote>
<p>为了实现反向代理，我们需要在 Ngnix中配置一个代理域名，<a href="http://xn--demo-k84fui0dy35fh5wuq8c4mmu4b.com" target="_blank" rel="noopener noreferrer">或者称为一个网址demo.com</a>，就像百度成千上万的服务器使用用一个代理网址www.baidu.com一样。ngnix的配置信息如下</p>
<div class="language-nginx line-numbers-mode" data-ext="nginx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>跨域是由浏览器安全限制造成的，解决跨域的办法有三种，一是 <strong>Jsonp</strong> 绕过浏览器安全检测策略，二是从被调用方配置支持跨域的请求头信息，三是从调用方利用反向代理，在 Ngnix 或 Apache 中配置代理域名隐藏跨域。</p>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器相关面试问题</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Network/Question/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Network/Question/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">浏览器相关面试问题</source>
      <description>常问问题 一个完整的http请求发生了什么 从浏览器输入url到回车页面渲染出来 这中间发生了什么</description>
      <category>Question</category>
      <pubDate>Mon, 16 May 2022 11:26:43 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 常问问题</h2>
<h3> 一个完整的http请求发生了什么</h3>
<h3> 从浏览器输入url到回车页面渲染出来 这中间发生了什么</h3>
]]></content:encoded>
    </item>
    <item>
      <title>浅谈12个Hooks</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/React/Hooks/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/React/Hooks/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">浅谈12个Hooks</source>
      <description>前言 React Hooks的发布已经有三年多了，它给函数式组件带来了生命周期，现如今，Hooks逐渐取代class组件，相信各位 React 开发的小伙伴已经深有体会，然而你真的完全掌握hooks了吗？知道如何去做一个好的自定义hooks吗？ 我们知道React Hooks有useState设置变量，useEffect副作用，useRef来获取元素的所有属性，还有useMemo、useCallback来做性能优化，当然还有一个自定义Hooks，来创造出你所想要的Hooks 接下来我们来看看以下几个问题，问问自己，是否全都知道： Hooks的由来是什么？ useRef的高级用法是什么？ useMemo 和 useCallback 是怎么做优化的？ 一个好的自定义Hooks该如何设计？ 如何做一个不需要useState就可以直接修改属性并刷新视图的自定义Hooks？ 如何做一个可以监听任何事件的自定义Hooks？ 如果你对以上问题有疑问，有好奇，那么这篇文章应该能够帮助到你～ 本文将会以介绍自定义Hooks来解答上述问题，并结合 TS，ahooks中的钩子，以案列的形式去演示 注：这里讲解的自定义钩子可能会和 ahooks上的略有不同，不会考虑过多的情况，如果用于项目，建议直接使用ahooks上的钩子～</description>
      <category>React</category>
      <pubDate>Mon, 27 Jun 2022 10:14:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 前言</h2>
<p><code>React Hooks</code>的发布已经有三年多了，它给函数式组件带来了<strong>生命周期</strong>，现如今，<code>Hooks</code>逐渐取代<code>class</code>组件，相信各位 <code>React</code> 开发的小伙伴已经深有体会，然而你真的完全掌握hooks了吗？知道如何去做一个好的自定义hooks吗？</p>
<p>我们知道<code>React Hooks</code>有<code>useState</code>设置变量，<code>useEffect</code>副作用，<code>useRef</code>来获取元素的所有属性，还有<code>useMemo</code>、<code>useCallback</code>来做性能优化，当然还有一个<code>自定义Hooks</code>，来创造出你所想要的<code>Hooks</code></p>
<p>接下来我们来看看以下几个问题，问问自己，是否全都知道：</p>
<ul>
<li>Hooks的由来是什么？</li>
<li><code>useRef</code>的高级用法是什么？</li>
<li><code>useMemo</code> 和 <code>useCallback</code> 是怎么做优化的？</li>
<li>一个好的自定义Hooks该如何设计？</li>
<li>如何做一个不需要<code>useState</code>就可以直接修改属性并刷新视图的自定义Hooks？</li>
<li>如何做一个可以监听任何事件的自定义Hooks？</li>
</ul>
<p>如果你对以上问题有疑问，有好奇，那么这篇文章应该能够帮助到你～</p>
<p>本文将会以介绍<strong>自定义Hooks</strong>来解答上述问题，并结合 <strong>TS</strong>，<strong>ahooks</strong>中的钩子，以案列的形式去演示</p>
<p>注：这里讲解的自定义钩子可能会和 <code>ahooks</code>上的略有不同，不会考虑过多的情况，如果用于项目，建议直接使用<code>ahooks</code>上的钩子～</p>
<!-- more -->

<h2> 自定义Hooks是什么？</h2>
<p><code>react-hooks</code>是<code>React16.8</code>以后新增的钩子API，目的是增加代码的可复用性、逻辑性，最主要的是解决了<strong>函数式组件无状态的问题</strong>，这样既保留了函数式的简单，又解决了没有数据管理状态的缺陷。那么什么是自定义hooks呢？</p>
<p><code>自定义hooks</code>是在<code>react-hooks</code>基础上的一个扩展，可以根据业务、需求去制定相应的<code>hooks</code>,将常用的逻辑进行封装，从而具备复用性。</p>
<h3> 如何设计一个自定义Hooks</h3>
<p><code>hooks</code>本质上是一个<strong>函数</strong>，而这个函数主要就是<strong>逻辑复用</strong>，我们首先要知道一件事，<code>hooks</code>的驱动条件是什么？</p>
<p>其实就是<code>props</code>的修改，<code>useState</code>、<code>useReducer</code>的使用是无状态组件更新的条件，从而驱动自定义hooks。</p>
<h3> 通用模式</h3>
<p>自定义hooks的名称是以<strong>use</strong>开头，我们设计为： <code>const [ xxx, ...] = useXXX(参数一，参数二...)</code></p>
<h3> 简单的小例子：usePow</h3>
<p>我们先写一个简单的小例子来了解下<code>自定义hooks</code></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们简单的写了个 <code>usePow</code>，我们通过 <code>usePow</code> 给所传入的数字平方, 用切换状态的按钮表示函数内部的状态，我们来看看此时的效果：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21cc3b15e24a8fba7a7cf3f2a89d14~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="awebp"></p>
<p>我们发现了一个问题，为什么点击切换按钮也会触发<code>console.log(1)</code>呢？</p>
<p>这样明显增加了性能开销，我们的理想状态肯定不希望做无关的渲染，所以我们做自定义 <code>hooks</code>的时候一定要注意，需要<strong>减少性能开销</strong>,我们为组件加入 <code>useMemo</code>试试：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3e583fe589a4dacbb0a5a72b2e99cef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<p>发现此时就已经解决了这个问题，所以要非常注意一点，一个好用的自定义<code>hooks</code>,一定要配合<code>useMemo</code>、<code>useCallback</code>等 Api 一起使用。</p>
<h2> 玩转React Hooks</h2>
<p>在上述中我们讲了用 <code>useMemo</code>来处理无关的渲染，接下来我们一起来看看<code>React Hooks</code>的这些钩子的妙用（这里建议先熟知、并使用对应的<code>React Hooks</code>,才能造出好的钩子）</p>
<h3> useMemo</h3>
<p>当一个父组件中调用了一个子组件的时候，父组件的 state 发生变化，会导致父组件更新，而子组件虽然没有发生改变，但也会进行更新。</p>
<p>简单的理解下，当一个页面内容非常复杂，模块非常多的时候，函数式组件会<strong>从头更新到尾</strong>，只要一处改变，所有的模块都会进行刷新，这种情况显然是没有必要的。</p>
<p>我们理想的状态是各个模块只进行自己的更新，不要相互去影响，那么此时用<code>useMemo</code>是最佳的解决方案。</p>
<p>这里要尤其注意一点，<strong>只要父组件的状态更新，无论有没有对自组件进行操作，子组件都会进行更新</strong>，<code>useMemo</code>就是为了防止这点而出现的</p>
<p>在讲 <code>useMemo</code> 之前，我们先说说<code>memo</code>,<code>memo</code>的作用是<strong>结合了pureComponent纯组件和 componentShouldUpdate功能</strong>，会对传入的props进行一次对比，然后根据第二个函数返回值来进一步判断哪些props需要更新。（具体使用会在下文讲到～）</p>
<p><code>useMemo</code>与<code>memo</code>的理念上差不多，都是判断是否满足当前的限定条件来决定是否执行<code>callback</code>函数，而<code>useMemo</code>的第二个参数是一个数组，通过这个数组来判定是否更新回掉函数</p>
<p>这种方式可以运用在<strong>元素、组件、上下文中</strong>，尤其是利用在数组上，先看一个例子：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面我们看出 <code>useMemo</code>只有在<code>list</code>发生变化的时候才会进行渲染，从而减少了不必要的开销</p>
<p>总结一下<code>useMemo</code>的好处：</p>
<ul>
<li>可以减少不必要的循环和不必要的渲染</li>
<li>可以减少子组件的渲染次数</li>
<li>通过特地的依赖进行更新，可以避免很多不必要的开销，但要注意，有时候在配合 <code>useState</code>拿不到最新的值，这种情况可以考虑使用 <code>useRef</code>解决</li>
</ul>
<h3> useCallback</h3>
<p><code>useCallback</code>与<code>useMemo</code>极其类似,可以说是一模一样，唯一不同的是<code>useMemo</code>返回的是函数运行的<strong>结果</strong>，而<code>useCallback</code>返回的是<strong>函数</strong></p>
<p>注意：这个函数是父组件传递子组件的一个函数，防止做无关的刷新，其次，这个组件必须配合<code>memo</code>,否则<strong>不但不会提升性能，还有可能降低性能</strong></p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c00efe7071b40c583a3d167d073a979~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<p>我们可以看到，当点击切换按钮的时候，没有经过 <code>useCallback</code>封装的函数会再次刷新，而进过过 <code>useCallback</code>包裹的函数不会被再次刷新</p>
<h3> useRef</h3>
<p><strong>useRef</strong> 可以获取当前元素的所有属性，并且返回一个可变的ref对象，并且这个对象<strong>只有current属性</strong>，可设置initialValue</p>
<h4> 通过useRef获取对应的属性值</h4>
<p>我们先看个案例：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上述可知，我们可以通过<code>useRef</code>来获取对应元素的相关属性，以此来做一些操作</p>
<p>效果：<img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce0221becc3940ec8610783afa66f5dc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h4> 缓存数据</h4>
<p>除了获取对应的属性值外，<code>useRef</code>还有一点比较重要的特性，那就是 <strong>缓存数据</strong></p>
<p>上述讲到我们封装一个合格的<code>自定义hooks</code>的时候需要结合<strong>useMemo</strong>、<strong>useCallback</strong>等Api，但我们控制变量的值用<strong>useState</strong> 有可能会导致拿到的是旧值，并且如果他们更新会带来整个组件重新执行，这种情况下，我们使用<strong>useRef</strong>将会是一个非常不错的选择</p>
<p>在<code>react-redux</code>的源码中，在hooks推出后，<code>react-redux</code>用大量的<strong>useMemo</strong>重做了<strong>Provide</strong>等核心模块，其中就是运用<strong>useRef</strong>来缓存数据，并且所运用的 <strong>useRef()</strong> 没有一个是绑定在dom元素上的，都是做数据缓存用的</p>
<p>可以简单的来看一下：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看到 <code>react-redux</code> 用重新赋值的方法，改变了缓存的数据源，减少了不必要的更新，如过采取<code>useState</code>势必会重新渲染</p>
<h4> useLatest</h4>
<p>经过上面的讲解我们知道<code>useRef</code> 可以拿到最新值，我们可以进行简单的封装，这样做的好处是：<strong>可以随时确保获取的是最新值，并且也可以解决闭包问题</strong></p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 结合useMemo和useRef封装useCreation</h4>
<p><strong>useCreation</strong> ：是 <code>useMemo</code> 或 <code>useRef</code>的替代品。换言之，<code>useCreation</code>这个钩子增强了 <code>useMemo</code> 和 <code>useRef</code>，让这个钩子可以替换这两个钩子。（来自ahooks-useCreation[2]）</p>
<ul>
<li><code>useMemo</code>的值不一定是最新的值，但<code>useCreation</code>可以保证拿到的值一定是最新的值</li>
<li>对于复杂常量的创建，<code>useRef</code>容易出现潜在的的性能隐患，但<code>useCreation</code>可以避免</li>
</ul>
<p>这里的性能隐患是指：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来我们来看看如何封装一个<code>useCreation</code>,首先我们要明白以下三点：</p>
<ul>
<li>第一点：先确定参数，<code>useCreation</code> 的参数与<code>useMemo</code>的一致，第一个参数是函数，第二个参数参数是可变的数组</li>
<li>第二点：我们的值要保存在 <code>useRef</code>中，这样可以将值缓存，从而减少无关的刷新</li>
<li>第三点：更新值的判断，怎么通过第二个参数来判断是否更新 <code>useRef</code>里的值。</li>
</ul>
<p>明白了一上三点我们就可以自己实现一个<code>useCreation</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>useRef</code>判断是否更新值通过<code>initialized</code> 和 <code>depsAreSame</code>来判断，其中<code>depsAreSame</code>通过存储在 <code>useRef</code>下的<code>deps</code>(旧值) 和 新传入的 <code>deps</code>（新值）来做对比，判断两数组的数据是否一致，来确定是否更新</p>
<h4> 验证 useCreation</h4>
<p>接下来我们写个小例子，来验证下 <code>useCreation</code>是否能满足我们的要求：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa5645ef84d141878142032ae2079bdc~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<p>我们可以看到，当我们做无关的<code>state</code>改变的时候，正常的函数也会刷新，但<code>useCreation</code>没有刷新，从而增强了渲染的性能～</p>
<h3> useEffect</h3>
<p><code>useEffect</code>相信各位小伙伴已经用的熟的不能再熟了，我们可以使用<code>useEffect</code>来模拟下<code>class</code>的<code>componentDidMount</code>和<code>componentWillUnmount</code>的功能。</p>
<h4> useMount</h4>
<p>这个钩子不必多说，只是简化了使用<code>useEffect</code>的第二个参数：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> useUnmount</h4>
<p>这个需要注意一个点，就是使用<code>useRef</code>来确保所传入的函数为最新的状态，所以可以结合上述讲的<strong>useLatest</strong>结合使用</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 结合<code>useMount</code>和<code>useUnmount</code>做个小例子</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果如下：<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27b1cfa623a944eb9056b62eeafaba5f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h4> useUpdate</h4>
<p><strong>useUpdate</strong>:强制更新</p>
<p>有的时候我们需要组件强制更新，这个时候就可以使用这个钩子：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbe4ebe0e17f439693b48eac899e3f67~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h2> 案例</h2>
<h3> 案例1: useReactive</h3>
<p><strong>useReactiv</strong>: 一种具备<strong>响应式</strong>的<code>useState</code></p>
<p>缘由：我们知道用<code>useState</code>可以定义变量其格式为：</p>
<p><code>const [count, setCount] = useState&lt;number&gt;(0)</code></p>
<p>通过<code>setCount</code>来设置，<code>count</code>来获取，使用这种方式才能够渲染视图</p>
<p>来看看正常的操作，像这样 <code>let count = 0; count =7</code> 此时<code>count</code>的值就是7，也就是说数据是响应式的</p>
<p>那么我们可不可以将 <code>useState</code>也写成<strong>响应式</strong>的呢？我可以自由设置<strong>count的值,并且可以随时获取到count的最新值</strong>，而不是通过<code>setCount</code>来设置。</p>
<p>我们来想想怎么去实现一个具备 <strong>响应式</strong> 特点的 <code>useState</code> 也就是 <code>useRective</code>,提出以下疑问，感兴趣的，可以先自行思考一下：</p>
<ul>
<li>这个钩子的出入参该怎么设定？</li>
<li>如何将数据制作成响应式（毕竟普通的操作无法刷新视图）？</li>
<li>如何使用<code>TS</code>去写，完善其类型？</li>
<li>如何更好的去优化？</li>
</ul>
<h4> 分析</h4>
<p>以上四个小问题，最关键的就是<code>第二个</code>，我们如何将数据弄成<strong>响应式</strong>，想要弄成响应式，就必须监听到值的变化，在做出更改，也就是说，我们对这个数进行操作的时候，要进行相应的<strong>拦截</strong>，这时就需要<code>ES6</code>的一个知识点：<strong>Proxy</strong></p>
<p>在这里会用到 <strong>Proxy</strong>和<strong>Reflect</strong>的点，感兴趣的可以看看我的这篇文章：🔥花一个小时，迅速了解ES6~ES12的全部特性[3]</p>
<p><strong>Proxy</strong>：接受的参数是<strong>对象</strong>，所以第一个问题也解决了，入参就为对象。那么如何去刷新视图呢？这里就使用上述的<strong>useUpdate</strong>来强制刷新，使数据更改。</p>
<p>至于优化这一块，使用上文说的<code>useCreation</code>就好，再配合<code>useRef</code>来放<code>initialState</code>即可</p>
<h4> 代码</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里先说下<code>TS</code>，因为我们不知道会传递什么类型的<code>initialState</code>所以在这需要使用<strong>泛型</strong>，我们接受的参数是<strong>对象</strong>，可就是 key-value 的形式，其中 key 为 string，value 可以是 任意类型，所以我们使用 <code>Record&lt;string, any&gt;</code></p>
<p>有不熟悉的小伙伴可以看看我的这篇文章：一篇让你完全够用TS的指南[4]（又推销一遍，有点打广告，别在意～）</p>
<p>再来说下<code>拦截这块</code>,我们只需要拦截<strong>设置（set）</strong> 和 <strong>获取（get）</strong> 即可，其中：</p>
<ul>
<li>设置这块，需要改变是图，也就是说需要，使用<strong>useUpdate</strong>来强制刷新</li>
<li>获取这块，需要判断其是否为对象，是的话继续递归，不是的话返回就行</li>
</ul>
<h4> 验证</h4>
<p>接下来我们来验证一下我们写的 <code>useReactive</code>,我们将以 字符串、数字、布尔、数组、函数、计算属性几个方面去验证一下：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果如下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9571ffdbb94c478bbb34e8b37d9c454f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h3> 案例2: useEventListener</h3>
<p>缘由：我们监听各种事件的时候需要做监听，如：监听点击事件、键盘事件、滚动事件等，我们将其统一封装起来，方便后续调用</p>
<p>说白了就是在<code>addEventListener</code>的基础上进行封装，我们先来想想在此基础上需要什么？</p>
<p>首先，<code>useEventListener</code>的入参可分为三个</p>
<ul>
<li>第一个<code>event</code>是事件（如：click、keydown）</li>
<li>第二个回调函数（所以不需要出参）</li>
<li>第三个就是目标（是某个节点还是全局）</li>
</ul>
<p>在这里需要注意一点就是在<strong>销毁的时候需要移除对应的监听事件</strong></p>
<h4> 代码</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：这里把<code>target</code>默认设置成了<code>window</code>，至于为什么要这么写：<code>'current' in target</code>是因为我们用<code>useRef</code>拿到的值都是 <code>ref.current</code></p>
<h4> 优化</h4>
<p>接下来我们一起来看看如何优化这个组件，这里的优化与 <code>useCreation</code> 类似，但又有不同，原因是这里的需要判断的要比<code>useCreation</code>复杂一点。</p>
<blockquote>
<p><strong>再次强调一下</strong>，传递过来的值，优先考虑使用<code>useRef</code>，再考虑用<code>useState</code>，可以直接使用<code>useLatest</code>，防止拿到的值不是最新值</p>
</blockquote>
<p>这里简单说一下我的思路（又不对的地方或者有更好的建议欢迎评论区指出）：</p>
<ul>
<li>首先需要<code>hasInitRef</code>来存储是否是第一次进入，通过它来判断初始化存储</li>
<li>然后考虑有几个参数需要存储，从上述代码上来看，可变的变量有两个，一个是<code>event</code>，另一个是<code>target</code>，其次，我们还需要存储<code>对应的卸载后的函数</code>，所以存储的变量应该有<code>3个</code></li>
<li>接下来考虑一下什么情况下触发<strong>更新</strong>，也就是可变的两个参数：<code>event</code>和 <code>target</code></li>
<li>最后在卸载的时候可以考虑使用<code>useUnmount</code>，并<code>执行存储对应的卸载后的函数</code> 和把<code>hasInitRef</code>还原</li>
</ul>
<h4> 详细代码</h4>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>在这里只用<code>useEffect</code>是因为，在更新和初始化的情况下都需要使用</li>
<li>必须要防止没有 <code>addEventListener</code>这个属性的情况，监听的目标有可能没有加载出来</li>
</ul>
<h4> 验证</h4>
<p>验证一下<code>useEventListener</code>是否能够正常的使用，顺变验证一下初始化、卸载的，代码：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9dbb36ddad2d41f9917b8db7355d283a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<p>我们可以利用<code>useEventListener</code>这个钩子去封装其他钩子，如 鼠标悬停，长按事件，鼠标位置等，在这里在举一个鼠标悬停的小例子</p>
<h4> 小例子 useHover</h4>
<p><strong>useHover</strong>：监听 DOM 元素是否有鼠标悬停</p>
<p>这个就很简单了，只需要通过 <code>useEventListener</code>来监听<code>mouseenter</code>和<code>mouseleave</code>即可，在返回布尔值就行了：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d77611b1d33647e689398e380f1fdb16~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h3> 案例3: 有关时间的Hooks</h3>
<p>在这里主要介绍有关时间的三个hooks,分别是：<code>useTimeout</code>、<code>useInterval</code>和<code>useCountDown</code></p>
<h4> useTimeout</h4>
<p><strong>useTimeout</strong>：一段时间内，执行一次</p>
<p>传递参数只要函数和延迟时间即可，需要注意的是卸载的时候将定时器清除下就OK了</p>
<p>详细代码：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果展示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38ea46cb005e4b7e92979bc56ffb76f9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h4> useInterval</h4>
<p><strong>useInterval</strong>: 每过一段时间内一直执行</p>
<p>大体上与<code>useTimeout</code>一样，多了一个是否要首次渲染的参数<code>immediate</code></p>
<p>详细代码：</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果展示：<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47b323c0e8b04546a5a30f51b9eb3488~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
<h4> useCountDown</h4>
<p><strong>useCountDown</strong>：简单控制倒计时的钩子</p>
<p>跟之前一样我们先来想想这个钩子需要什么：</p>
<ul>
<li>我们要做倒计时的钩子首先需要一个目标时间（targetDate），控制时间变化的秒数（interval默认为1s），然后就是倒计时完成后所触发的函数（onEnd）</li>
<li>返参就更加一目了然了，返回的是两个时间差的数值（time），再详细点可以换算成对应的天、时、分等（formattedRes）</li>
</ul>
<p>详细代码:</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证:</p>
<div class="language-tsx line-numbers-mode" data-ext="tsx"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果展示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f41eaef407564c86b27aac51c4539da2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="图片"></p>
]]></content:encoded>
      <enclosure url="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d21cc3b15e24a8fba7a7cf3f2a89d14~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" type="image/"/>
    </item>
    <item>
      <title>ECMAScript 6</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Standard/ES6/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Standard/ES6/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">ECMAScript 6</source>
      <description>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 Node.js 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node.js 默认没有打开的 ES6 实验性语法。 // Linux &amp;amp; Mac $ node --v8-options | grep harmony // Windows $ node --v8-options | findstr harmony</description>
      <category>ECMAScript</category>
      <pubDate>Wed, 01 Jun 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<p>ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。</p>
<p>Node.js 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node.js 默认没有打开的 ES6 实验性语法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><!-- more -->
<h2> Babel 转码器</h2>
<p>在讲ES6特性前，需要知道一下什么是Babel转码器。Babel&nbsp;是 <strong>一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在老版本的浏览器执行</strong> 。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的原始代码用了箭头函数，Babel将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<h3> 安装 @Babel/core</h3>
<p>下面的命令在项目目录中，安装 Babel。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。该文件用来 <strong>设置转码规则和插件</strong> ，基本格式如下：</p>
<div class="language-json5 line-numbers-mode" data-ext="json5"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，将这些规则加入.babelrc</p>
<div class="language-json5 line-numbers-mode" data-ext="json5"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 安装 @Babel/cli</h3>
<p>Babel 提供命令行工具@babel/cli，用于命令行转码。它的安装命令如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>基本用法如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 安装 @Babel/node</h3>
<p>@babel/node模块的babel-node命令， <strong>提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码</strong> 。</p>
<p>首先，安装这个模块。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，执行babel-node就进入 REPL 环境。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 安装 @babel/register</h3>
<p>@babel/register模块改写require命令，为它加上一个钩子。此后， <strong>每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码</strong>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用时，必须首先加载@babel/register。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，就不需要手动对index.js转码了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要注意的是，@babel/register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h3> polyfill</h3>
<p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如 <strong>Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码</strong> 。</p>
<p>举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，可以 <strong>使用core-js和regenerator-runtime(后者提供generator函数的转码)，为当前环境提供一个垫片</strong> 。</p>
<p>安装命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，在脚本头部，加入如下两行代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的 <strong>definitions.js</strong> 文件。</p>
<h3> 浏览器环境</h3>
<p>Babel 也可以用于浏览器环境，使用@babel/standalone模块提供的浏览器版本，将其插入网页。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<h2> 最常用的ES6特性</h2>
<p><strong>let, const, class, extends, super, arrow function, template string, destructuring, default, rest arguments</strong></p>
<p>这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。</p>
<h2> let, const</h2>
<p>实例展示</p>
<p>这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用var&nbsp;两次输出都是obama，这是因为 <strong>ES5只有全局作用域和函数作用域，没有块级作用域</strong> ，这带来很多不合理的场景。</p>
<p>第一种场景就是你现在看到的内层变量覆盖外层变量。而 <strong>let则实际上为JavaScript新增了块级作用域</strong> 。用它所声明的变量，只在 <strong>let命令所在的代码块内有效</strong>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>const也用来声明变量，但是声明的是常量。一旦声明，<strong>常量的值就不能改变</strong>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 概念概述</h4>
<ul>
<li>不存在变量提升</li>
</ul>
<p>var命令会发生“变量提升”现象，即 <strong>变量可以在声明之前使用，值为undefined</strong> 。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象， <strong>let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错</strong> 。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<ul>
<li>暂时性死区</li>
</ul>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“ <strong>暂时性死区</strong> ”（temporal dead zone，简称 TDZ）。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 <strong>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作</strong> 。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p>
<p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以， <strong>在没有let之前，typeof运算符是百分之百安全的</strong> ，永远不会报错
。
现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。有些“死区”比较隐蔽，不太容易发现。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，下面的代码也会报错，与var的行为不同。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之， <strong>暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量</strong> 。</p>
<ul>
<li>不允许重复声明</li>
</ul>
<p>let不允许在相同作用域内，重复声明同一个变量。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，不能在函数内部重新声明参数。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>块级作用域</li>
</ul>
<p>为什么需要块级作用域？</p>
<p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数if执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<ul>
<li>ES6 的块级作用域</li>
</ul>
<p>let实际上为 JavaScript 新增了块级作用域。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。</p>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>块级作用域与函数声明</li>
</ul>
<p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定， <strong>块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用</strong> 。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码在 ES6 浏览器中，都会报错。</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ol>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ol>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的例子实际运行的代码如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而let只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p>
<p>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> class, extends, super</h2>
<p>这三个特性涉及了ES5中最令人头疼的几个部分：原型、构造函数，继承...你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？有了ES6我们不再烦恼！</p>
<p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说， <strong>constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的</strong>。</p>
<p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。</p>
<p>super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为 <strong>子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象</strong> 。</p>
<p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p>
<p>P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承React.Component的类。详见react文档</p>
<h2> arrow function</h2>
<p>这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>简直是简单的不像话对吧...</p>
<p>如果方程比较复杂，则需要用{}把代码包起来：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：</p>
<p>第一种是将this传给self,再用self来指代this</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二种方法是用bind(this),即</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但现在我们有了箭头函数，就不需要这么麻烦了：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。</p>
<h2> template string</h2>
<p>这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。</p>
<p>大家可以先看下面一段代码：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们要用一堆的’+’号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用反引号（`）来标识始末，用${}来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！</p>
<p>React Router从第1.0.3版开始也使用ES6语法了，比如这个例子：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> destructuring</h2>
<p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>看下面的例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用ES6完全可以像下面这么写：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>反过来可以这么写：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> default</h2>
<p>default很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || 'cat'&nbsp;来指定默认值。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果用ES6我们而已直接这么写：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> rest arguments</h2>
<p>rest语法也很简单，直接看例子：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而如果不用ES6的话，我们则得使用ES5的arguments。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> import export</h2>
<p>这两个家伙对应的就是es6自己的module功能。</p>
<p>之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。</p>
<p>这有可能导致两个问题：一方面js代码变得很臃肿，难以维护另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug。在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。</p>
<p>如果想了解更多AMD，尤其是require.js，可以参看这个教程：why modules on the web are useful and the mechanisms that can be used on the web today to enable them</p>
<p>而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。</p>
<p>上面的设计思想看不懂也没关系，咱先学会怎么用，等以后用多了、熟练了再去研究它背后的设计思想也不迟！好，那我们就上代码...</p>
<ul>
<li>传统的写法</li>
</ul>
<p>假设我们有两个js文件:&nbsp;index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？</p>
<p><strong>require.js的写法</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>CommonJS的写法</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>ES6的写法</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上我把三者都列出来了，妈妈再也不用担心我写混淆了...</p>
<p><strong>ES6 module的其他高级用法</strong></p>
<p><strong>输出输入多个变量</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>修改变量名</strong></p>
<p>此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>模块的整体加载</strong></p>
<p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常星号*结合as一起使用比较合适。</p>
<p><strong>终极秘籍</strong></p>
<p>考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。</p>
<p>ES6帮我们实现了！</p>
<p>不过，目前无论是webpack还是browserify都还不支持这一功能...</p>
<p>如果你现在就想实现这一功能的话，可以尝试使用rollup.js</p>
<p>他们把这个功能叫做Tree-shaking，哈哈哈，意思就是打包前让整个文档树抖一抖，把那些并未被依赖或使用的东西统统抖落下去。。。</p>
<p>看看他们官方的解释吧：</p>
<blockquote>
<p>Normally if you require a module, you import the whole thing. ES2015 lets you just import the bits you need, without mucking around with custom builds. It's a revolution in how we use libraries in JavaScript, and it's happening right now.</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>HTML规范指南</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Standard/HTML/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Standard/HTML/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">HTML规范指南</source>
      <description>HTML 作为描述网页结构的超文本标记语言，本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。</description>
      <category>前端规范</category>
      <pubDate>Wed, 22 Jun 2022 10:28:05 GMT</pubDate>
      <content:encoded><![CDATA[<p><em>HTML 作为描述网页结构的超文本标记语言，本文档的目标是使 HTML 代码风格保持一致，容易被理解和被维护。</em></p>
<!-- more -->
<h2> 通用</h2>
<h3> <code>【强制】</code> 使用 HTML5 的 doctype 来启用标准模式，建议使用大写的 DOCTYPE。</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> <code>【推荐】</code>在 html 标签上设置正确的 <strong>lang</strong> 属性。</h3>
<blockquote>
<p>为什么？有助于提高页面的可访问性，如：让语音合成工具确定其所应该采用的发音，令翻译工具确定其翻译语言等。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> <code>【强制】</code> 页面必须使用精简形式，明确指定字符编码。指定字符编码的 <code>meta</code> 必须是 <code>head</code> 的第一个直接子元素。</h3>
<blockquote>
<p>为什么？见 <a href="https://www.w3school.com.cn/html5/att_script_charset.asp" target="_blank" rel="noopener noreferrer">HTML5 Charset能用吗</a>一文。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <code>【强制】</code> CSS 和 JavaScript 引入</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> <code>【建议】</code> 引入 CSS 和 JavaScript 时无须指明 type 属性。</h3>
<blockquote>
<p>为什么？text/css 和 text/javascript 是 type 的默认值。</p>
</blockquote>
<h3> <code>【建议】</code> JavaScript 应当放在页面末尾，或采用异步加载。</h3>
<blockquote>
<p>为什么？将 <code>script</code> 放在页面中间将阻断页面的渲染。出于性能方面的考虑，如非必要，请遵守此条建议。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <code>【建议】</code> 移动环境或只针对现代浏览器设计的 Web 应用，如果引用外部资源的 URL 协议部分与页面相同，建议省略协议前缀。</h3>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> <code>【强制】</code> 页面必须包含 title 标签声明标题。且 title 必须作为 head 的直接子元素，并紧随 charset 声明之后。</h3>
<blockquote>
<p>title 中如果包含 ASCII 之外的字符，浏览器需要知道字符编码类型才能进行解码，否则可能导致乱码。</p>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> <code>【强制】</code> 保证 favicon 可访问。</h3>
<blockquote>
<p>在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 <code>favicon.ico</code> 。为了保证 favicon 可访问，避免 404，必须遵循以下两种方法之一：</p>
<ol>
<li>在 Web Server 根目录放置 <code>favicon.ico</code> 文件。</li>
<li>使用 <code>link</code> 指定 favicon。</li>
</ol>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> <code>【建议】</code> 若页面欲对移动设备友好，需指定页面的 <code>viewport</code>。</h3>
<blockquote>
<p>viewport meta tag 可以设置可视区域的宽度和初始缩放大小，避免在移动设备上出现页面展示不正常。
比如，在页面宽度小于 <code>980px</code> 时，若需 iOS 设备友好，应当设置 viewport 的 <code>width</code> 值来适应你的页面宽度。</p>
<p>同时因为不同移动设备分辨率不同，在设置时，应当使用 <code>device-width</code> 和 <code>device-height</code> 变量。</p>
<p>另外，为了使 viewport 正常工作，在页面内容样式布局设计上也要做相应调整，如避免绝对定位等。关于 viewport 的更多介绍，
可以参见 <a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html#//apple_ref/doc/uid/TP40006509-SW26" target="_blank" rel="noopener noreferrer">Safari Web Content Guide的介绍</a>。</p>
</blockquote>
<h2> JavaScript规范指南</h2>
<p><em>使用 JavaScript 最合理的方式。基于Airbnb JavaScript Style Guide 结合实际研发情况，做相应改写而成。</em></p>
<blockquote>
<p><strong>注意</strong>: 这个指南假定你正在使用 <a href="https://babeljs.io/" target="_blank" rel="noopener noreferrer">Babel</a>，并且需要你使用 <a href="https://npmjs.com/babel-preset-airbnb" target="_blank" rel="noopener noreferrer">babel-preset-airbnb</a>或与其等效的预设。同时假定你在你的应用里安装了 带有 <a href="https://npmjs.com/airbnb-browser-shims" target="_blank" rel="noopener noreferrer">airbnb-browser-shims</a>或与其等效的插件的 <code>shims/polyfills</code>。</p>
</blockquote>
<blockquote>
<p><strong>提示</strong>: 基于babel-preset-airbnb 二次修改的预设还没完成，仅限与初版文档阶段。</p>
</blockquote>
<h3> 引用</h3>
<h4> <code>【强制】</code> 所有的赋值都用 <code>const</code>，避免使用 <code>var</code>。eslint: <a href="http://eslint.org/docs/rules/prefer-const.html" target="_blank" rel="noopener noreferrer"><code>prefer-const</code></a>, <a href="http://eslint.org/docs/rules/no-const-assign.html" target="_blank" rel="noopener noreferrer"><code>no-const-assign</code></a></h4>
<blockquote>
<p>为什么？因为这个能确保你不会改变你的初始值，重复引用会导致 bug 并且使代码变得难以理解。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 如果你一定要对参数重新赋值，使用 <code>let</code>，而不是 <code>var</code>。eslint: <a href="http://eslint.org/docs/rules/no-var.html" target="_blank" rel="noopener noreferrer"><code>no-var</code></a></h4>
<blockquote>
<p>为什么？因为 <code>let</code> 是块级作用域，而 <code>var</code> 是函数级作用域。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 注意：<code>let</code> 和 <code>const</code> 都是块级作用域。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 对象</h3>
<h4> <code>【强制】</code> 使用字面值创建对象。eslint: <a href="http://eslint.org/docs/rules/no-new-object.html" target="_blank" rel="noopener noreferrer"><code>no-new-object</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 使用计算属性名创建一个带有动态属性名的对象。</h4>
<blockquote>
<p>为什么？因为这可以使你在同一个地方定义所有对象属性。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用对象方法简写。eslint: <a href="http://eslint.org/docs/rules/object-shorthand.html" target="_blank" rel="noopener noreferrer"><code>object-shorthand</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用属性值缩写。eslint: <a href="http://eslint.org/docs/rules/object-shorthand.html" target="_blank" rel="noopener noreferrer"><code>object-shorthand</code></a></h4>
<blockquote>
<p>为什么？因为这样写的更少且可读性更高。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>将你的所有缩写放在对象声明的前面。</h4>
<blockquote>
<p>为什么？因为这样能更方便地知道有哪些属性用了缩写。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 只对那些无效的标示使用引号 <code>''</code>。eslint: <a href="http://eslint.org/docs/rules/quote-props.html" target="_blank" rel="noopener noreferrer"><code>quote-props</code></a></h4>
<blockquote>
<p>为什么？通常我们认为这种方式主观上更易读。不仅优化了代码高亮，而且也更容易被许多 JS 引擎优化。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要直接调用 <code>Object.prototype</code>上的方法，如 <code>hasOwnProperty</code>、<code>propertyIsEnumerable</code>、<code>isPrototypeOf</code>。</h4>
<blockquote>
<p>为什么？在一些有问题的对象上，这些方法可能会被屏蔽掉，如：<code>{ hasOwnProperty: false }</code> 或空对象 <code>Object.create(null)</code></p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 对象浅拷贝时，更推荐使用扩展运算符（即 <code>...</code> 运算符），而不是 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener noreferrer"><code>Object.assign</code> </a>。获取对象指定的几个属性时，用对象的 rest 解构运算符（即 <code>...</code> 运算符）更好。eslint: <a href="https://eslint.org/docs/rules/prefer-object-spread" target="_blank" rel="noopener noreferrer"><code>prefer-object-spread</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数组</h3>
<h4> <code>【强制】</code> 用字面量创建数组。eslint: <a href="http://eslint.org/docs/rules/no-array-constructor.html" target="_blank" rel="noopener noreferrer"><code>no-array-constructor</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener noreferrer">Array#push</a>代替直接向数组中添加一个值。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用扩展运算符做数组浅拷贝，类似上面的对象浅拷贝。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <code>...</code> 运算符而不是 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener noreferrer"><code>Array.from</code></a>来将一个可迭代的对象转换成数组。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener noreferrer"><code>Array.from</code></a>将一个类数组对象转成一个数组。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener noreferrer"><code>Array.from</code></a>而不是 <code>...</code> 运算符去做 map 遍历。 因为这样可以避免创建一个临时数组。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 在数组方法的回调函数中使用 return 语句。如果函数体由一条返回一个表达式的语句组成，并且这个表达式没有副作用， 这个时候可以忽略 return，详见 <a href="http://fe.dev.kdshc.com/docs.html#arrows--implicit-return" target="_blank" rel="noopener noreferrer">7.2</a>。eslint: <a href="http://eslint.org/docs/rules/array-callback-return" target="_blank" rel="noopener noreferrer"><code>array-callback-return</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 如果一个数组有很多行，在数组的 <code>[</code> 后和 <code>]</code> 前断行。请看下面示例：</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 解构</h3>
<h4> <code>【强制】</code> 用对象的解构赋值来获取和使用对象某个或多个属性值。eslint: <a href="https://eslint.org/docs/rules/prefer-destructuring" target="_blank" rel="noopener noreferrer"><code>prefer-destructuring</code></a></h4>
<blockquote>
<p>为什么？解构使您不必为这些属性创建临时引用，并且避免重复引用对象。重复引用对象将造成代码重复、增加阅读次数、提高犯错概率。
Destructuring objects also provides a single site of definition of the object structure that is used in the block, rather than requiring reading the entire block to determine what is used.</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用数组解构。eslint: <a href="https://eslint.org/docs/rules/prefer-destructuring" target="_blank" rel="noopener noreferrer"><code>prefer-destructuring</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 多个返回值用对象的解构，而不是数组解构。</h4>
<blockquote>
<p>为什么？你可以在后期添加新的属性或者变换变量的顺序而不会破坏原有的引用。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 字符串</h3>
<h4> <code>【强制】</code> 字符串应使用单引号 <code>''</code> 。eslint: <a href="https://eslint.org/docs/rules/quotes.html" target="_blank" rel="noopener noreferrer"><code>quotes</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 超过 100 个字符的字符串不应该用字符串连接成多行。</h4>
<blockquote>
<p>为什么？字符串折行增加编写难度且不易被搜索。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>当需要动态生成字符串时，使用模板字符串而不是字符串拼接。eslint: <a href="https://eslint.org/docs/rules/prefer-template.html" target="_blank" rel="noopener noreferrer"><code>prefer-template</code></a><a href="https://eslint.org/docs/rules/template-curly-spacing" target="_blank" rel="noopener noreferrer"><code>template-curly-spacing</code></a></h4>
<blockquote>
<p>为什么？模板字符串更具可读性、多行语法更简洁以及更方便插入变量到字符串里头。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 永远不要使用 <code>eval()</code>，该方法有太多漏洞。eslint: <a href="https://eslint.org/docs/rules/no-eval" target="_blank" rel="noopener noreferrer"><code>no-eval</code></a></h4>
<h4> 不要使用不必要的转义字符。eslint: <a href="http://eslint.org/docs/rules/no-useless-escape" target="_blank" rel="noopener noreferrer"><code>no-useless-escape</code></a></h4>
<blockquote>
<p>为什么？反斜线可读性差，因此仅当必要时才使用它。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 函数</h3>
<h4> <code>【推荐】</code>使用命名函数表达式而不是函数声明。eslint: <a href="http://eslint.org/docs/rules/func-style" target="_blank" rel="noopener noreferrer"><code>func-style</code></a></h4>
<blockquote>
<p>函数表达式： const func = function () {}</p>
</blockquote>
<blockquote>
<p>函数声明： function func () {}</p>
</blockquote>
<blockquote>
<p>为什么？函数声明会发生提升，这意味着在一个文件里函数很容易在其被定义之前就被引用了。这样伤害了代码可读性和可维护性。如果你发现一个函数又大又复杂，且这个函数妨碍了这个文件其他部分的理解性，你应当单独把这个函数提取成一个单独的模块。不管这个名字是不是由一个确定的变量推断出来的，别忘了给表达式清晰的命名（这在现代浏览器和类似 babel 编译器中很常见）。这消除了由匿名函数在错误调用栈产生的所有假设。 (<a href="https://github.com/airbnb/javascript/issues/794" target="_blank" rel="noopener noreferrer">讨论 </a>)</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 把立即执行函数包裹在圆括号里。eslint: <a href="http://eslint.org/docs/rules/wrap-iife.html" target="_blank" rel="noopener noreferrer"><code>wrap-iife</code></a></h4>
<blockquote>
<p>立即执行函数：Immediately Invoked Function expression = IIFE。 为什么？一个立即调用的函数表达式是一个单元 - 把它和它的调用者（圆括号）包裹起来，使代码读起来更清晰。 另外，在模块化世界里，你几乎用不着 IIFE。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要在非函数块（<code>if</code>、<code>while</code> 等）内声明函数。把这个函数分配给一个变量。浏览器会允许你这样做，但不同浏览器的解析方式不同，这是一个坏消息。eslint: <a href="http://eslint.org/docs/rules/no-loop-func.html" target="_blank" rel="noopener noreferrer"><code>no-loop-func</code></a></h4>
<p><em>注意</em>*：ECMA-262 中对块（<code>block</code>）的定义是： 一系列的语句。但是函数声明不是一个语句， 函数表达式是一个语句。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要用 <code>arguments</code> 命名参数。他的优先级高于每个函数作用域自带的 <code>arguments</code> 对象，这会导致函数自带的 <code>arguments</code> 值被覆盖。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要使用 <code>arguments</code>，用收集参数语法 <code>...</code> 代替。eslint: <a href="http://eslint.org/docs/rules/prefer-rest-params" target="_blank" rel="noopener noreferrer"><code>prefer-rest-params</code></a></h4>
<blockquote>
<p>为什么？<code>...</code> 明确你想用哪个参数。而且收集参数是真数组，而不是类似数组的 <code>arguments</code>。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>用默认参数语法而不是在函数里对参数重新赋值。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 避免默认参数的副作用。</h4>
<blockquote>
<p>为什么？他会令人迷惑不解，比如下面这个，a 到底等于几，这个需要想一下。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>把默认参数赋值放在最后。eslint: <a href="https://eslint.org/docs/rules/default-param-last" target="_blank" rel="noopener noreferrer"><code>default-param-last</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要用函数构造器创建函数。eslint: <a href="http://eslint.org/docs/rules/no-new-func" target="_blank" rel="noopener noreferrer"><code>no-new-func</code></a></h4>
<blockquote>
<p>为什么？以这种方式创建函数将类似于字符串 eval()，存在漏洞。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 函数定义部分要有空格。eslint: <a href="http://eslint.org/docs/rules/space-before-function-paren" target="_blank" rel="noopener noreferrer"><code>space-before-function-paren</code></a><a href="http://eslint.org/docs/rules/space-before-blocks" target="_blank" rel="noopener noreferrer"><code>space-before-blocks</code></a></h4>
<blockquote>
<p>为什么？统一性好，而且在你添加/删除一个名字的时候不需要添加/删除空格。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要修改参数. eslint: <a href="http://eslint.org/docs/rules/no-param-reassign.html" target="_blank" rel="noopener noreferrer"><code>no-param-reassign</code></a></h4>
<blockquote>
<p>为什么？操作参数对象对原始调用者会导致意想不到的副作用。就是不要改参数的数据结构，保留参数原始值和数据结构。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>不要对参数重新赋值。eslint: <a href="http://eslint.org/docs/rules/no-param-reassign.html" target="_blank" rel="noopener noreferrer"><code>no-param-reassign</code></a></h4>
<blockquote>
<p>为什么？参数重新赋值会导致意外行为，尤其是对 <code>arguments</code>。这也会导致优化问题，特别是在 V8 引擎里。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 使用拓展运算符调用多参数的函数。eslint: <a href="http://eslint.org/docs/rules/prefer-spread" target="_blank" rel="noopener noreferrer"><code>prefer-spread</code></a></h4>
<blockquote>
<p>为什么？这样更清晰，你不必提供上下文（即指定 this 值），而且你不能轻易地用 <code>apply</code> 来组成 <code>new</code>。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 调用或者编写一个包含多个参数的函数的缩进，应该像这个指南里的其他多行代码写法一样——即每行只包含一个参数，每行逗号结尾。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 箭头函数</h3>
<h4> <code>【强制】</code> 当你一定要用函数表达式（在回调函数里）的时候，使用箭头函数。 eslint: <a href="http://eslint.org/docs/rules/prefer-arrow-callback.html" target="_blank" rel="noopener noreferrer"><code>prefer-arrow-callback</code></a>, <a href="http://eslint.org/docs/rules/arrow-spacing.html" target="_blank" rel="noopener noreferrer"><code>arrow-spacing</code></a></h4>
<blockquote>
<p>为什么？箭头函数中的 <code>this</code> 与定义该函数的上下文中的 <code>this</code> 一致，这通常才是你想要的。而且箭头函数是更简洁的语法。</p>
</blockquote>
<blockquote>
<p>什么时候不用箭头函数：如果你的函数逻辑较复杂，你应该把它单独写入一个命名函数里头。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 如果函数体由一个没有副作用的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener noreferrer">表达式</a>语句组成，删除大括号和 return。否则，使用大括号和 <code>return</code> 语句。 eslint: <a href="https://eslint.org/docs/rules/arrow-parens.html" target="_blank" rel="noopener noreferrer"><code>arrow-parens</code> </a>, <a href="https://eslint.org/docs/rules/arrow-body-style.html" target="_blank" rel="noopener noreferrer"><code>arrow-body-style</code></a></h4>
<blockquote>
<p>为什么？语法糖，当多个函数链在一起的时候好读。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 如果表达式涉及多行，把他包裹在圆括号里以提高可读性。</h4>
<blockquote>
<p>为什么？这样能清晰地显示函数的开始位置和结束位置。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在箭头函数参数两头，总是使用小括号包裹住参数，这样做使代码更清晰且一致. eslint: <a href="https://eslint.org/docs/rules/arrow-parens.html" target="_blank" rel="noopener noreferrer"><code>arrow-parens</code></a></h4>
<blockquote>
<p>为什么？当你想要添加或删除参数时能比较省事。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>避免箭头函数（<code>=&gt;</code>）和比较操作符（<code>&lt;=</code>, <code>&gt;=</code>）混淆. eslint: <a href="http://eslint.org/docs/rules/no-confusing-arrow" target="_blank" rel="noopener noreferrer"><code>no-confusing-arrow</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>使箭头函数体有一个清晰的返回。 eslint: <a href="https://eslint.org/docs/rules/implicit-arrow-linebreak" target="_blank" rel="noopener noreferrer"><code>implicit-arrow-linebreak</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 类与构造函数</h3>
<h4> <code>【推荐】</code>使用 <code>class</code> 语法。避免直接操作 <code>prototype</code>。</h4>
<blockquote>
<p>为什么？<code>class</code> 语法更简洁更易理解。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <code>extends</code> 实现继承。</h4>
<blockquote>
<p>为什么？它是一种内置的方法来继承原型功能而不破坏 <code>instanceof</code>。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>方法可以返回 <code>this</code> 来实现链式调用。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 自己写 <code>toString()</code> 方法是可以的，但需要保证它可以正常工作且没有副作用。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 如果没有特别定义，类有默认的构造方法。一个空的构造函数或只是代表父类的构造函数是不需要写的。 eslint: <a href="http://eslint.org/docs/rules/no-useless-constructor" target="_blank" rel="noopener noreferrer"><code>no-useless-constructor</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 避免重复定义类成员。eslint: <a href="http://eslint.org/docs/rules/no-dupe-class-members" target="_blank" rel="noopener noreferrer"><code>no-dupe-class-members</code></a></h4>
<blockquote>
<p>为什么？重复定义类成员只会使用最后一个被定义的 —— 重复本身也是一个 bug.</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>除非外部库或框架需要使用特定的非静态方法，否则类方法应该使用 <code>this</code> 或被写成静态方法。 作为一个实例方法表明它应该根据实例的属性有不同的行为。eslint: <a href="https://eslint.org/docs/rules/class-methods-use-this" target="_blank" rel="noopener noreferrer"><code>class-methods-use-this</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 模块</h3>
<h4> <code>【推荐】</code>使用（<code>import</code>/<code>export</code>）模块而不是非标准的模块系统。你可以随时转到你喜欢的模块系统。</h4>
<blockquote>
<p>为什么？模块化是未来，让我们现在就开启未来吧。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>不要用 <code>import</code> 通配符， 即 <code>*</code> 这种方式。</h4>
<blockquote>
<p>为什么？这确保你有单个默认的导出。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>不要直接从 <code>import</code> 中直接 <code>export</code>。</h4>
<blockquote>
<p>为什么？虽然只写一行很简洁，但是使用明确 <code>import</code> 和明确的 <code>export</code> 来保证一致性。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 一个路径只 <code>import</code> 一次。eslint: <a href="http://eslint.org/docs/rules/no-duplicate-imports" target="_blank" rel="noopener noreferrer"><code>no-duplicate-imports</code></a></h4>
<blockquote>
<p>为什么？多行导入同一路径将使代码变得难以维护。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要导出可变的东西。eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-mutable-exports.md" target="_blank" rel="noopener noreferrer"><code>import/no-mutable-exports</code></a></h4>
<blockquote>
<p>为什么？变化通常都是需要避免，特别是当你要输出可变的绑定。虽然在某些场景下可能需要这种技术，但总的来说应该导出常量。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在一个单一导出模块里，用 <code>export default</code> 更好。eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/prefer-default-export.md" target="_blank" rel="noopener noreferrer"><code>import/prefer-default-export</code></a></h4>
<blockquote>
<p>为什么？鼓励使用更多文件，每个文件只导出一次，这样可读性和可维护性更好。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 把 <code>import</code> 放在其他所有语句之前。eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/first.md" target="_blank" rel="noopener noreferrer"><code>import/first</code></a></h4>
<blockquote>
<p>为什么？因为 <code>import</code> 会被提升到代码最前面运行，因此将他们放在最前面以防止发生意外行为。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 多行 <code>import</code> 应该缩进，就像多行数组和对象字面量一样。</h4>
<blockquote>
<p>为什么？花括号与样式指南中每个其他花括号块遵循相同的缩进规则，逗号也是。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 在 <code>import</code> 语句里不允许 Webpack loader 语法。eslint: <a href="https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md" target="_blank" rel="noopener noreferrer"><code>import/no-webpack-loader-syntax</code></a></h4>
<blockquote>
<p>为什么？一旦用 Webpack 语法在 import 里会把代码耦合到模块绑定器。最好是在 <code>webpack.config.js</code> 里写 webpack loader 语法</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 迭代器与生成器</h3>
<h4> <code>【强制】</code> 不要用迭代器。使用 JavaScript 高级函数代替 <code>for-in</code>、 <code>for-of</code>。eslint: <a href="http://eslint.org/docs/rules/no-iterator.html" target="_blank" rel="noopener noreferrer"><code>no-iterator</code> </a><a href="http://eslint.org/docs/rules/no-restricted-syntax" target="_blank" rel="noopener noreferrer"><code>no-restricted-syntax</code></a></h4>
<blockquote>
<p>为什么？这强调了我们不可变的规则。 处理返回值的纯函数比处理副作用更容易。</p>
</blockquote>
<blockquote>
<p>用数组的这些迭代方法： <code>map()</code> / <code>every()</code> / <code>filter()</code> / <code>find()</code> / <code>findIndex()</code> / <code>reduce()</code> / <code>some()</code> / ... , 用对象的这些方法 <code>Object.keys()</code> / <code>Object.values()</code> / <code>Object.entries()</code> 去产生一个数组，这样你就能去遍历对象了。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 现在暂时不要使用生成器。</h4>
<blockquote>
<p>为什么？生成器目前不能很好地转换为 ES5 语法。</p>
</blockquote>
<h4> <code>【强制】</code> 如果你一定要用生成器，或者你忽略我们的建议，请确保它们的函数标志空格是得当的。eslint: <a href="http://eslint.org/docs/rules/generator-star-spacing" target="_blank" rel="noopener noreferrer"><code>generator-star-spacing</code></a></h4>
<blockquote>
<p>为什么？<code>function</code> 和 <code>*</code> 是同一概念关键字 - <code>*</code>不是<code>function</code>的修饰符，<code>function*</code> 是一个和<code>function</code> 不一样的独特结构。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 属性</h3>
<h4> <code>【强制】</code> 访问属性时使用点符号。eslint: <a href="http://eslint.org/docs/rules/dot-notation.html" target="_blank" rel="noopener noreferrer"><code>dot-notation</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 当使用变量获取属性时用方括号 <code>[]</code>。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 做幂运算时用幂操作符 <code>**</code> 。eslint: <a href="https://eslint.org/docs/rules/no-restricted-properties" target="_blank" rel="noopener noreferrer"><code>no-restricted-properties</code> </a>.</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 变量</h3>
<h4> <code>【强制】</code> 使用 <code>const</code> 或 <code>let</code> 声明变量。不这样做会导致全局变量。我们想要避免污染全局命名空间。地球超人也这样警告我们（译者注：可能是一个冷笑话）。 eslint: <a href="http://eslint.org/docs/rules/no-undef" target="_blank" rel="noopener noreferrer"><code>no-undef</code> </a><a href="http://eslint.org/docs/rules/prefer-const" target="_blank" rel="noopener noreferrer"><code>prefer-const</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>为每个变量声明都用一个 <code>const</code> 或 <code>let</code>。eslint: <a href="http://eslint.org/docs/rules/one-var.html" target="_blank" rel="noopener noreferrer"><code>one-var</code></a></h4>
<blockquote>
<p>为什么？这种方式很容易去声明新的变量，你不用去考虑把 <code>;</code> 调换成 <code>,</code>，或者引入一个只有标点的不同的变化（译者注：这里说的应该是在 Git 提交代码时显示的变化）。这种做法也可以是你在调试的时候单步每个声明语句，而不是一下跳过所有声明。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>把<code>const</code> 和 <code>let</code> 分别放一起。</h4>
<blockquote>
<p>为什么？在你需要分配一个新的变量，而这个变量依赖之前分配过的变量的时候，这种做法是有帮助的。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 在你需要的地方声明变量，但是要放在合理的位置。</h4>
<blockquote>
<p>为什么？<code>let</code> 和 <code>const</code> 都是块级作用域而不是函数级作用域。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要使用链式声明变量。 eslint: <a href="https://eslint.org/docs/rules/no-multi-assign" target="_blank" rel="noopener noreferrer"><code>no-multi-assign</code></a></h4>
<blockquote>
<p>为什么？链式声明变量会创建隐式全局变量。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要使用一元自增自减运算符（<code>++</code>， <code>--</code>）. eslint <a href="http://eslint.org/docs/rules/no-plusplus" target="_blank" rel="noopener noreferrer"><code>no-plusplus</code></a></h4>
<blockquote>
<p>为什么？根据 eslint 文档，一元增量和减量语句受到自动分号插入的影响，并且可能会导致应用程序中的值递增或递减的静默错误。 使用 <code>num + = 1</code> 而不是 <code>num ++</code> 或 <code>num ++</code> 语句也是含义清晰的。 禁止一元增量和减量语句还会阻止您无意地预增/预减值，这也会导致程序出现意外行为。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在赋值的时候避免在 <code>=</code> 前/后换行。 如果你的赋值语句超出 <a href="https://eslint.org/docs/rules/max-len.html" target="_blank" rel="noopener noreferrer"><code>max-len</code> </a>，那就用小括号把这个值包起来再换行。eslint <a href="https://eslint.org/docs/rules/operator-linebreak.html" target="_blank" rel="noopener noreferrer"><code>operator-linebreak</code> </a>.</h4>
<blockquote>
<p>为什么？在 <code>=</code> 附近换行容易混淆这个赋值语句。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不允许有未使用的变量。eslint: <a href="https://eslint.org/docs/rules/no-unused-vars" target="_blank" rel="noopener noreferrer"><code>no-unused-vars</code></a></h4>
<blockquote>
<p>为什么？一个声明了但未使用的变量更像是由于重构未完成产生的错误。这种在代码中出现的变量会使阅读者迷惑。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 提升</h3>
<h4> <code>var</code> 声明会被提前到离他最近的作用域的最前面，但是它的赋值语句并没有提前。<code>const</code> 和 <code>let</code> 被赋予了新的概念 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let" target="_blank" rel="noopener noreferrer">暂时性死区 </a>。 重要的是要知道为什么 <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15" target="_blank" rel="noopener noreferrer">typeof 不再安全 </a>.</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 匿名函数表达式和 <code>var</code> 情况相同。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 已命名函数表达式提升他的变量名，不是函数名或函数体。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 函数声明则提升了函数名和函数体。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>详情请见 <a href="http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting/" target="_blank" rel="noopener noreferrer">JavaScript Scoping &amp; Hoisting </a>by <a href="http://www.adequatelygood.com/" target="_blank" rel="noopener noreferrer">Ben Cherry</a>.</p>
<h3> 比较运算符与相等</h3>
<h4> <code>【强制】</code> 用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code>. eslint: <a href="http://eslint.org/docs/rules/eqeqeq.html" target="_blank" rel="noopener noreferrer"><code>eqeqeq</code></a></h4>
<h4> <code>【强制】</code> 条件语句如 <code>if</code> 语句使用强制 <code>ToBoolean</code> 抽象方法来计算它们的表达式，并且始终遵循以下简单规则：</h4>
<ul>
<li>
<p><strong>Objects</strong> 计算成 <strong>true</strong></p>
</li>
<li>
<p><strong>Undefined</strong> 计算成 <strong>false</strong></p>
</li>
<li>
<p><strong>Null</strong> 计算成 <strong>false</strong></p>
</li>
<li>
<p><strong>Booleans</strong> 计算成 <strong>the value of the boolean</strong></p>
</li>
<li>
<p><strong>Numbers</strong></p>
<ul>
<li><strong>+0, -0, or NaN</strong> 计算成 <strong>false</strong></li>
<li>其他 <strong>true</strong></li>
</ul>
</li>
<li>
<p><strong>Strings</strong></p>
<ul>
<li><code>''</code> 计算成 <strong>false</strong></li>
<li>其他 <strong>true</strong></li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>布尔值要用缩写，而字符串和数字要明确使用比较操作符。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>更多信息请见 Angus Croll 的 <a href="https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108" target="_blank" rel="noopener noreferrer">Truth Equality and JavaScript</a>。</p>
<h4> <code>【推荐】</code>在 <code>case</code> 和 <code>default</code> 分句里用大括号创建一块包含词法声明的区域（例如：<code>let</code>、<code>const</code>、<code>function</code> 和 <code>class</code>）。eslint rules: <a href="http://eslint.org/docs/rules/no-case-declarations.html" target="_blank" rel="noopener noreferrer"><code>no-case-declarations</code></a>.</h4>
<blockquote>
<p>为什么？词法声明在整个 <code>switch</code> 的代码块里都可见，但是只有当其被分配后才会初始化，仅当这个 <code>case</code> 被执行时才被初始化。当多个 <code>case</code> 分句试图定义同一个对象时就会出现问题。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 三元表达式不应该嵌套，通常是单行表达式。eslint rules: <a href="http://eslint.org/docs/rules/no-nested-ternary.html" target="_blank" rel="noopener noreferrer"><code>no-nested-ternary</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 避免不必要的三元表达式。eslint rules: <a href="http://eslint.org/docs/rules/no-unneeded-ternary.html" target="_blank" rel="noopener noreferrer"><code>no-unneeded-ternary</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用圆括号来组合操作符。 只有当标准的算术运算符（<code>+</code>, <code>-</code>, <code>*</code>, 和 <code>/</code>）， 并且它们的优先级显而易见时，才可以不用圆括号括起来。eslint: <a href="https://eslint.org/docs/rules/no-mixed-operators.html" target="_blank" rel="noopener noreferrer"><code>no-mixed-operators</code></a></h4>
<blockquote>
<p>为什么？这提高了可读性，并且明确了开发者的意图。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 块</h3>
<h4> <code>【强制】</code> 用大括号包裹多行代码块。 eslint: <a href="https://eslint.org/docs/rules/nonblock-statement-body-position" target="_blank" rel="noopener noreferrer"><code>nonblock-statement-body-position</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> <code>if</code> 表达式的 <code>else</code>和 <code>if</code> 的右大括号在一行。eslint: <a href="http://eslint.org/docs/rules/brace-style.html" target="_blank" rel="noopener noreferrer"><code>brace-style</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 如果 <code>if</code> 语句中总是需要用 <code>return</code> 返回，那后续的 <code>else</code> 就不需要写了。 <code>if</code> 块中包含 <code>return</code>， 它后面的 <code>else if</code> 块中也包含了 <code>return</code>， 这个时候就可以把 <code>return</code> 分到多个 <code>if</code> 语句块中。 eslint: <a href="https://eslint.org/docs/rules/no-else-return" target="_blank" rel="noopener noreferrer"><code>no-else-return</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 控制语句</h3>
<p>当你的控制语句（<code>if</code>, <code>while</code> 等）太长或者超过最大长度限制的时候，把每一个（组）判断条件放在单独一行里。逻辑操作符放在行首。</p>
<blockquote>
<p>为什么？把逻辑操作符放在行首是让操作符的对齐方式和链式函数保持一致。这提高了可读性，也让复杂逻辑更清晰。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>不要用选择操作符代替控制语句。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 注释</h3>
<h4> <code>【强制】</code> 多行注释用 <code>/** ... */</code>。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 单行注释用 <code>//</code>，将单行注释放在被注释区域上面。如果注释不是在第一行，那么注释前面就空一行。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 所有注释开头空一格，方便阅读。eslint: <a href="http://eslint.org/docs/rules/spaced-comment" target="_blank" rel="noopener noreferrer"><code>spaced-comment</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 在你的注释前使用 <code>FIXME</code> 或 <code>TODO</code> 前缀，这有助于其他开发人员快速理解你指出的需要修复的问题， 或者您建议需要实现的问题的解决方案。 这些不同于常规注释，它们是有明确含义的。<code>FIXME：需要修复这个问题</code>或<code>TODO：需要实现的功能</code>。</h4>
<h4> <code>【强制】</code> 用 <code>// FIXME:</code> 给问题做注释。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <code>// TODO:</code> 去注释问题的解决方案。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 空格</h3>
<h4> <code>【强制】</code> 一个缩进使用两个空格。eslint: <a href="http://eslint.org/docs/rules/indent.html" target="_blank" rel="noopener noreferrer"><code>indent</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在大括号前空一格。eslint: <a href="http://eslint.org/docs/rules/space-before-blocks.html" target="_blank" rel="noopener noreferrer"><code>space-before-blocks</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在控制语句（<code>if</code>, <code>while</code> 等）的圆括号前空一格。在函数调用和定义时，参数列表和函数名之间不空格。 eslint: <a href="http://eslint.org/docs/rules/keyword-spacing.html" target="_blank" rel="noopener noreferrer"><code>keyword-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>用空格来隔开运算符。eslint: <a href="http://eslint.org/docs/rules/space-infix-ops.html" target="_blank" rel="noopener noreferrer"><code>space-infix-ops</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>文件结尾空一行。eslint: <a href="https://github.com/eslint/eslint/blob/master/docs/rules/eol-last.md" target="_blank" rel="noopener noreferrer"><code>eol-last</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 当出现长的方法链式调用时（&gt;2个）用缩进。用点开头强调该行是一个方法调用，而不是一个新的语句。eslint: <a href="http://eslint.org/docs/rules/newline-per-chained-call" target="_blank" rel="noopener noreferrer"><code>newline-per-chained-call</code></a><a href="http://eslint.org/docs/rules/no-whitespace-before-property" target="_blank" rel="noopener noreferrer"><code>no-whitespace-before-property</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在一个代码块后下一条语句前空一行。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要用空白行填充块。eslint: <a href="http://eslint.org/docs/rules/padded-blocks.html" target="_blank" rel="noopener noreferrer"><code>padded-blocks</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要在代码之间使用多个空白行填充。eslint: <a href="https://eslint.org/docs/rules/no-multiple-empty-lines" target="_blank" rel="noopener noreferrer"><code>no-multiple-empty-lines</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 圆括号里不要加空格。eslint: <a href="http://eslint.org/docs/rules/space-in-parens.html" target="_blank" rel="noopener noreferrer"><code>space-in-parens</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 方括号里不要加空格。 eslint: <a href="http://eslint.org/docs/rules/array-bracket-spacing.html" target="_blank" rel="noopener noreferrer"><code>array-bracket-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 花括号里加空格 。eslint: <a href="http://eslint.org/docs/rules/object-curly-spacing.html" target="_blank" rel="noopener noreferrer"><code>object-curly-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 避免一行代码超过100个字符（包含空格）。注意：对于 <a href="http://fe.dev.kdshc.com/docs.html#strings--line-length" target="_blank" rel="noopener noreferrer">上面</a>，长字符串不受此规则限制，不应换行。 eslint: <a href="http://eslint.org/docs/rules/max-len.html" target="_blank" rel="noopener noreferrer"><code>max-len</code></a></h4>
<blockquote>
<p>为什么？这样确保可读性和可维护性。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 作为语句的花括号内也要加空格 —— <code>{</code> 后和 <code>}</code> 前都需要空格。 eslint: <a href="https://eslint.org/docs/rules/block-spacing" target="_blank" rel="noopener noreferrer"><code>block-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> <code>,</code> 前不要空格， <code>,</code> 后需要空格。 eslint: <a href="https://eslint.org/docs/rules/comma-spacing" target="_blank" rel="noopener noreferrer"><code>comma-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 计算属性内要空格。参考上述花括号和中括号的规则。 eslint: <a href="https://eslint.org/docs/rules/computed-property-spacing" target="_blank" rel="noopener noreferrer"><code>computed-property-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 调用函数时，函数名和小括号之间不要空格。 eslint: <a href="https://eslint.org/docs/rules/func-call-spacing" target="_blank" rel="noopener noreferrer"><code>func-call-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>在对象的字面量属性中， <code>key</code> 和 <code>value</code> 之间要有空格。 eslint: <a href="https://eslint.org/docs/rules/key-spacing" target="_blank" rel="noopener noreferrer"><code>key-spacing</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 行末不要空格。 eslint: <a href="https://eslint.org/docs/rules/no-trailing-spaces" target="_blank" rel="noopener noreferrer"><code>no-trailing-spaces</code></a></h4>
<h4> <code>【强制】</code> 避免出现多个空行。 在文件末尾只允许空一行。避免在文件开始处出现空行。eslint: <a href="https://eslint.org/docs/rules/no-multiple-empty-lines" target="_blank" rel="noopener noreferrer"><code>no-multiple-empty-lines</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 逗号</h3>
<h4> <code>【强制】</code> 不要前置逗号。eslint: <a href="http://eslint.org/docs/rules/comma-style.html" target="_blank" rel="noopener noreferrer"><code>comma-style</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 额外结尾逗号: <strong>要</strong> eslint: <a href="http://eslint.org/docs/rules/comma-dangle.html" target="_blank" rel="noopener noreferrer"><code>comma-dangle</code></a></h4>
<blockquote>
<p>为什么？这使 git diffs 更简洁。此外，像Babel这样的转换器会删除转换代码中的额外的逗号，这意味着你不必担心旧版浏览器中的 <a href="https://github.com/airbnb/javascript/blob/es5-deprecated/es5/README.md#commas" target="_blank" rel="noopener noreferrer">结尾逗号问题 </a>。</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 类型转换与强制转换</h3>
<h4> <code>【强制】</code> 在语句开始执行强制类型转换。</h4>
<h4> <code>【强制】</code> 字符串: eslint: <a href="https://eslint.org/docs/rules/no-new-wrappers" target="_blank" rel="noopener noreferrer"><code>no-new-wrappers</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 数字: 用 <code>Number</code> 做类型转换，<code>parseInt</code> 转换 <code>string</code> 应总是带上基数。 eslint: <a href="http://eslint.org/docs/rules/radix" target="_blank" rel="noopener noreferrer"><code>radix</code></a></h4>
<blockquote>
<p>为什么？函数 <code>parseInt</code> 会根据指定的基数将字符串转换为数字。字符串开头的空白字符将会被忽略，如果参数基数（第二个参数）为 <code>undefined</code> 或者 <code>0</code> ，除非字符串开头为 <code>0x</code> 或 <code>0X</code>（十六进制），会默认假设为 <code>10</code>。这个差异来自 ECMAScript 3，它不鼓励（但是允许）解释八进制。在 2013 年之前，一些实现不兼容这种行为。因为我们需要支持旧浏览器，所以应当始终指定进制。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 请在注释中解释为什么要用移位运算和你在做什么。无论你做什么狂野的事，比如由于 <code>parseInt</code> 是你的性能瓶颈导致你一定要用移位运算。说明这个是因为 <a href="https://jsperf.com/coercion-vs-casting/3" target="_blank" rel="noopener noreferrer">性能原因 </a>。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> <strong>注意:</strong> 用移位运算要小心。数字是用 <a href="https://es5.github.io/#x4.3.19" target="_blank" rel="noopener noreferrer">64-位 </a>表示的，但移位运算常常返回的是32为整形<a href="https://es5.github.io/#x11.7" target="_blank" rel="noopener noreferrer">source </a>)。移位运算对大于 32 位的整数会导致意外行为。<a href="https://github.com/airbnb/javascript/issues/109" target="_blank" rel="noopener noreferrer">Discussion </a>. 最大的 32 位整数是 2,147,483,647:</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 布尔: eslint: <a href="https://eslint.org/docs/rules/no-new-wrappers" target="_blank" rel="noopener noreferrer"><code>no-new-wrappers</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 命名规范</h3>
<h4> <code>【强制】</code> 避免用一个字母命名，让你的命名有意义。eslint: <a href="http://eslint.org/docs/rules/id-length" target="_blank" rel="noopener noreferrer"><code>id-length</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用小驼峰命名法来命名你的对象、函数、实例。eslint: <a href="http://eslint.org/docs/rules/camelcase.html" target="_blank" rel="noopener noreferrer"><code>camelcase</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用大驼峰命名法来命名类。eslint: <a href="http://eslint.org/docs/rules/new-cap.html" target="_blank" rel="noopener noreferrer"><code>new-cap</code></a></h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>不要用前置或后置下划线。eslint: <a href="http://eslint.org/docs/rules/no-underscore-dangle.html" target="_blank" rel="noopener noreferrer"><code>no-underscore-dangle</code></a></h4>
<blockquote>
<p>为什么？JavaScript 没有私有属性或私有方法的概念。尽管前置下划线通常的概念上意味着私有，事实上，这些属性是完全公有的，因此这部分也是你的 API 的内容。这一概念可能会导致开发者误以为更改这个不会导致崩溃或者不需要测试。如果你想要什么东西变成私有，那就不要让它在这里出现。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 不要保存引用 <code>this</code>，用箭头函数或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener noreferrer">函数绑定——Function#bind</a>。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> <code>export default</code> 导出模块A，则这个文件名也叫 <code>A.*</code>， <code>import</code> 时候的参数也叫 <code>A</code>。 大小写完全一致。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code>  当你 export-default 一个函数时，函数名用小驼峰，文件名需要和函数名一致。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>当你 export 一个结构体/类/单例/函数库/对象 时用大驼峰。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 简称和缩写应该全部大写或全部小写。</h4>
<blockquote>
<p>为什么？名字都是给人读的，不是为了去适应计算机算法。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 你可以用全大写字母设置静态变量，他需要满足三个条件。</h4>
<ol>
<li>导出变量；</li>
<li>是 <code>const</code> 定义的， 保证不能被改变；</li>
<li>这个变量是可信的，他的子属性都是不能被改变的。</li>
</ol>
<blockquote>
<p>为什么？这是一个附加工具，帮助开发者去辨识一个变量是不是不可变的。UPPERCASE_VARIABLES 能让开发者知道他能确信这个变量（以及他的属性）是不会变的。</p>
</blockquote>
<ul>
<li>
<p>对于所有的 <code>const</code> 变量呢？ —— 这个是不必要的。大写变量不应该在同一个文件里定义并使用， 它只能用来作为导出变量。</p>
</li>
<li>
<p>那导出的对象呢？ —— 大写变量处在 <code>export</code> 的最高级(例如：<code>EXPORTED_OBJECT.key</code>) 并且他包含的所有子属性都是不可变的。（译者注：即导出的变量是全大写的，但他的属性不用大写）</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Get-Set 访问器</h3>
<h4> <code>【强制】</code> 不需要使用属性的访问器函数。</h4>
<h4> <code>【强制】</code> 不要使用 JavaScript 的 getters/setters，因为他们会产生副作用，并且难以测试、维护和理解。相反的，你可以用 <code>getVal()</code> 和 <code>setVal('hello')</code> 去创造你自己的访问器函数。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>如果属性/方法是 <code>boolean</code>， 用 <code>isVal()</code> 或 <code>hasVal()</code>。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【推荐】</code>用 <code>get()</code> 和 <code>set()</code> 函数是可以的，但是要一起用。</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 事件</h3>
<h4> <code>【强制】</code> 当传递数据载荷给事件时（不论是 DOM 还是像 Backbone 这样有很多属性的事件）。这使得后续的贡献者（程序员）向这个事件添加更多的数据时不用去找或者更新每个处理器。例如：</h4>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 标准库</h3>
<p><a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" rel="noopener noreferrer">标准库</a>中包含一些功能受损但是由于历史原因遗留的工具类</p>
<h4> <code>【强制】</code> 用 <code>Number.isNaN</code> 代替全局的 <code>isNaN</code>。 eslint: <a href="https://eslint.org/docs/rules/no-restricted-globals" target="_blank" rel="noopener noreferrer"><code>no-restricted-globals</code></a></h4>
<blockquote>
<p>为什么？全局 <code>isNaN</code> 强制把非数字转成数字， 然后对于任何强转后为 <code>NaN</code> 的变量都返回 <code>true</code> 如果你想用这个功能，就显式的用它。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 用 <code>Number.isFinite</code> 代替 <code>isFinite</code>. eslint: <a href="https://eslint.org/docs/rules/no-restricted-globals" target="_blank" rel="noopener noreferrer"><code>no-restricted-globals</code></a></h4>
<blockquote>
<p>Why? 理由同上，会把一个非数字变量强转成数字，然后做判断。</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> CSS规范指南</h2>
<p><em>BEM的意思就是块（block）、元素（element）、修饰符（modifier）,是由Yandex团队提出的一种前端命名方法论。这种巧妙的命名方法让你的CSS类对其他开发者来说更加透明而且更有意义。BEM命名约定更加严格，而且包含更多的信息，它们用于一个团队开发一个耗时的大项目</em></p>
<h3> 命名约定的模式</h3>
<h4> <code>【强制】</code> 命名约定的模式如下</h4>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 块</h3>
<h4> <code>【强制】</code> 一个块就是一个组件，如：</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的css</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 修饰符</h3>
<h4> <code>【强制】</code> 修饰符是改变某个块的外观的标志。要使用修饰符，可以将 --modifier 添加到块中。从上面的form示例继续命名</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的css</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 元素</h3>
<h4> <code>【强制】</code> 元素是块的子节点。为了表明某个东西是一个元素，你需要在块名后添加 __element。所以，如果你看到一个像那样的名字，比如 form__row ，你将立即知道 .form 块中有一个 row 元素。</h4>
<blockquote>
<p>BEM 元素有两个优点：</p>
<ol>
<li>你可以让 CSS 的优先级保持相对扁平</li>
<li>你能立即知道哪些东西是一个子元素。</li>
</ol>
</blockquote>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的css</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> <code>【强制】</code> 永远不应该链式命名 BEM 元素。通过以下两种方式绕过长长的 BEM 链式命名：</h4>
<div class="hint-container danger">
<p class="hint-container-title">警告</p>
<ol>
<li>
<p>只把子子元素链接到有意义的</p>
</li>
<li>
<p>创建新的块来保存元素</p>
</li>
</ol>
</div>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>RESTful API</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Standard/RESTful/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Standard/RESTful/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">RESTful API</source>
      <description>如何解释什么是RESTful 一个悠闲的周日下午，Ta午觉醒来，又习惯性的抓起这个月的杂志，饶有兴趣地看了起来。 果不其然，看着看着，Ta又对我发难了，“Restful是什么呀，是restaurant的形容词吗，突然就觉得好饿了啊......” 作为一个合格的程序员，我一直把能够将一项技术讲给Ta听，并且能给Ta讲懂，作为我已经掌握了这项技术的标准。 如果我直接回答说，REST就是Representational State Transfer的缩写呀，翻译为中文就是 表述性状态转移，那肯定不行。</description>
      <category>前端规范</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 如何解释什么是RESTful</h2>
<p>一个悠闲的周日下午，Ta午觉醒来，又习惯性的抓起这个月的杂志，饶有兴趣地看了起来。</p>
<p>果不其然，看着看着，Ta又对我发难了，“Restful是什么呀，是restaurant的形容词吗，突然就觉得好饿了啊......”</p>
<p>作为一个合格的程序员，我一直把能够将一项技术讲给Ta听，并且能给Ta讲懂，作为我已经掌握了这项技术的标准。</p>
<p>如果我直接回答说，<strong>REST就是Representational State Transfer的缩写呀，翻译为中文就是 表述性状态转移</strong>，那肯定不行。</p>
<p>必须找个合适的机会，把Restful的来龙去脉给Ta形象的描述一遍。</p>
<p>“走，咱们去楼下咖啡厅吃个下午茶吧”，我对Ta说。</p>
<p>“一个芝士蛋糕，一杯拿铁，两条吸管，谢谢”，我对前台的服务员说，然后我们找了个角落坐了下来。</p>
<h2> Level 0 - 面向前台</h2>
<p>“刚才我们向前台点了一杯拿铁，这个过程可以用这段文字来描述”，说着，我在纸上写下了这段JSON，虽然Ta不知道什么叫JSON，但理解这段文字对于英语专业8级的Ta，实在再简单不过。</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“我们通过这段文字，告诉前台，新增一笔订单，订单是一杯拿铁咖啡”，接着，前台给我们返回这么一串回复：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“订单ID？还是订单编号？”</p>
<p>“恩恩，就是订单编号”</p>
<p>“那我们就等着前台喊订单123456的客户可以取餐了，然后就可以开吃了！”</p>
<p>“哈哈，你真聪明，不过，在这之前，假设我们有一张会员卡，我们想查询一下这张会员卡的余额，这时候，要向前台发起另一个询问”，我继续在纸上写着：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“查询卡号为886333的卡的余额？”</p>
<p>“真棒！接着，查询的结果返回来了”</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“切，没钱......”</p>
<p>“哈哈，没钱，现在我们要跟前台说，这杯咖啡不要了”，我在纸上写到：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“哼，这就把订单取消啦？”</p>
<h2> Level 1 - 面向资源</h2>
<p>“现在这家咖啡店越做越大，来喝咖啡的人越来越多，单靠前台显然是不行的，店主决定进行分工，每个资源都有专人负责，我们可以直接面向资源操作。”</p>
<p>"面向资源？”</p>
<p>“是的，比如还是下单，请求的内容不变，但是我们多了一条消息”，我在纸上画出这次的模型：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“多了一个斜杠和orders？这是什么意思？”</p>
<p>“这个表示我们这个请求是发给哪个资源的，订单是一种资源，我们可以理解为是咖啡厅专门管理订单的人，他可以帮我们处理所有有关订单的操作，包括新增订单、修改订单、取消订单等操作”</p>
<p>“Soga...”</p>
<p>“接着还是会返回订单的编号给我们”</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“下面，我们还是要查询会员卡余额，这次请求的资源变成了cards”</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“接下来是取消订单”</p>
<p>“这个我会”，说着，Ta抢走我手上的笔，在纸上写了起来：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Level 2 - 打上标签</h2>
<p>“接下来，店主还想继续优化他的咖啡厅的服务流程，他发现负责处理订单的员工，每次都要去订单内容里面看是新增订单还是删除订单，还是其他的什么操作，十分不方便，于是规定，所有新增资源的请求，都在请求上面写上大大的 <strong>POST</strong> ，表示这是一笔新增资源的请求”</p>
<p>“其他种类的请求，比如查询类的，用 <strong>GET</strong> 表示，删除类的，用 <strong>DELETE</strong> 表示”</p>
<p>“还有修改类的，修改分为两种，这个第一种，如果修改，无论发送多少次，最后一次修改后的资源，总是和第一次修改后的一样，比如将拿铁改为猫屎，那么用 <strong>PUT</strong> 表示；第二种，如果这个修改，每次修改都会让这个资源和前一次的不一样，比如是加一杯咖啡，那么这种请求用 <strong>PATCH</strong> 或者 <strong>POST</strong> 表示”，一口气讲了这么多，发现Ta有点似懂非懂。</p>
<p>“来，我们再来重复上面那个过程，来一杯拿铁”，我边说边画着：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>"请求的内容简洁多啦，不用告诉店员是addOrder，看到POST就知道是新增"，Ta听的很认真，理解的也很透彻。</p>
<p>"恩恩，返回的内容还是一样"</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“接着是查询会员卡余额，这次也简化了很多”</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“这个请求我们还可以进一步优化为这样”</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“Soga，直接把要查询的卡号写在后面了”</p>
<p>“没错，接着，取消订单”</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> Level 3 - 完美服务</h2>
<p>“忽然有一天，有个顾客抱怨说，他买了咖啡后，不知道要怎么取消订单，咖啡厅一个店员回了一句，你不会看我们的宣传单吗，上面不写着：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>顾客反问道，谁会去看那个啊，店员不服，又说到，你瞎了啊你......据说后面两人吵着吵着还打了起来...”</p>
<p>“噗，真是悲剧...”</p>
<p>“有了这次教训，店长决定，顾客下了单之后，不仅给他们返回订单的编号，还给顾客返回所有可以对这个订单做的操作，比如告诉用户如何删除订单。现在，我们还是发出请求，请求内容和上一次一样”</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“但是这次返回时多了些内容”</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>“这次返回时多了一项link信息，里面包含了一个rel属性和url属性，rel是relationship的意思，这里的关系是cancel，url则告诉你如何执行这个cancel操作，接着你就可以这样子来取消订单啦”</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>“哈哈，这服务真是贴心，以后再也不用担心店员和顾客打起来了”</p>
<p>“订单123456的客户可以取餐了”，伴随着咖啡厅的广播，我们吃起了下午茶，一杯拿铁，两支吸管......</p>
<h2> 说明</h2>
<p>上面讲的Level0 ~ Level3，来自Leonard Richardson提出的Richardson Maturity Model：</p>
<ul>
<li>
<p>Level0 和 Level1 最大的区别，就是 Level1 拥有了 RESTful 的第一个特征——面向资源，这对构建可伸缩、分布式的架构是至关重要的。同时，如果把 Level0 的数据格式换成XML，那么其实就是 SOAP ，SOAP 的特点是关注行为和处理，和面向资源的 RESTful 有很大的不同。</p>
</li>
<li>
<p>Level0 和 Level1 ，其实都很挫，他们都只是把 HTTP 当做一个传输的通道，没有把 HTTP 当做一种传输协议。</p>
</li>
<li>
<p>Level2，真正将 HTTP 作为了一种传输协议，最直观的一点就是 Level2 使用了HTTP动词，GET/PUT/POST/DELETE/PATCH....,这些都是 HTTP 的规范，规范的作用自然是重大的，用户看到一个 POST 请求，就知道它不是幂等的，使用时要小心，看到 PUT ，就知道他是幂等的，调用多几次都不会造成问题，当然，这些的前提都是 API 的设计者和开发者也遵循这一套规范，确保自己提供的 PUT 接口是幂等的。</p>
</li>
<li>
<p>Level3，关于这一层，有一个古怪的名词，叫 HATEOAS（Hypertext As The Engine Of Application State），中文翻译为“将超媒体格式作为应用状态的引擎”，核心思想就是每个资源都有它的状态，不同状态下，可对它进行的操作不一样。理解了这一层，再来看看 REST 的全称，Representational State Transfer，中文翻译为“表述性状态转移”，是不是好理解多了？</p>
</li>
<li>
<p>Level3 的 Restful API，给使用者带来了很大的便利，使用者只需要知道如何获取资源的入口，之后的每个URI都可以通过请求获得，无法获得就说明无法执行那个请求。</p>
</li>
<li>
<p>现在绝大多数的 RESTful 接口都做到了 Level2 的层次，做到 Level3 的比较少。当然，这个模型并不是一种规范，只是用来理解 RESTful 的工具。所以，做到了 Level2 ，也就是面向资源和使用 HTTP 动词，就已经很 RESTful 了。RESTful 本身也不是一种规范，我比较倾向于用“风格"来形容它。如果你想深入了解Level3，可以阅读《Rest in Practice》第五章。</p>
</li>
</ul>
<blockquote>
<p>我讲的时候，用的数据格式是JSON，但是要强调一点，RESTful 对数据格式没有限制，就算你用的是XML或者其他格式，只要符合上面提到的几个特征，也算RESTful。</p>
</blockquote>
<h2> 规范</h2>
<p>RESTful 是目前最流行的 API 设计规范，用于 Web 数据接口的设计。</p>
<p>它的大原则容易把握，但是细节不容易做对。本文总结 RESTful 的设计细节，介绍如何设计出易于理解和使用的 API。</p>
<h3> URL 设计</h3>
<h4> 动词 + 宾语</h4>
<p>RESTful 的核心思想就是，客户端发出的数据操作指令都是"动词 + 宾语"的结构。比如: <strong>GET /articles</strong> 这个命令，GET是动词，/articles是宾语。</p>
<p>动词通常就是五种 HTTP 方法，对应 CRUD 操作。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 动词的覆盖</h4>
<p>有些客户端只能使用 GET 和 POST 这两种方法。服务器必须接受 POST 模拟其他三个方法（PUT、PATCH、DELETE）。</p>
<p>这时，客户端发出的 HTTP 请求，要加上 <strong>X-HTTP-Method-Override</strong> 属性，告诉服务器应该使用哪一个动词，覆盖POST方法。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，X-HTTP-Method-Override 指定本次请求的方法是PUT，而不是POST。</p>
<h4> 宾语必须是名词</h4>
<p>宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如: <strong>/articles</strong> 这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 复数 URL</h4>
<p>既然 URL 是名词，那么应该使用复数，还是单数？</p>
<p>这没有统一的规定，但是常见的操作是读取一个集合，比如 <strong>GET /articles</strong>（读取所有文章），这里明显应该是复数。</p>
<p>为了统一起见，建议都使用复数 URL，比如 <strong>GET /articles/2</strong> 要好于 <strong>GET /article/2</strong> 。</p>
<h4> 避免多级 URL</h4>
<p>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p>
<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查询字符串的写法明显更好。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 状态码</h3>
<h4> 状态码必须精确</h4>
<p>客户端的每一次请求，服务器都必须给出回应。回应包括 <strong>HTTP 状态码</strong> 和 <strong>数据</strong> 两部分。</p>
<p>HTTP 状态码就是一个三位数，分成五个类别。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这五大类总共包含100多种状态码，覆盖了绝大部分可能遇到的情况。每一种状态码都有标准的（或者约定的）解释，客户端只需查看状态码，就可以判断出发生了什么情况，所以服务器应该返回尽可能精确的状态码。</p>
<p>API 不需要1xx状态码，下面介绍其他四类状态码的精确含义。</p>
<h4> 2xx 状态码</h4>
<p>200状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，POST返回201状态码，表示生成了新的资源；DELETE返回204状态码，表示资源已经不存在。</p>
<p>此外，202 Accepted状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3xx 状态码</h4>
<p>API 用不到301状态码（永久重定向）和302状态码（暂时重定向，307也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</p>
<p>API 用到的3xx状态码，主要是303 See Other，表示参考另一个 URL。它与302和307的含义一样，也是"暂时重定向"，区别在于 <strong>302和307用于GET请求</strong> ，而 <strong>303用于POST、PUT和DELETE请求</strong>。收到303以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 4xx 状态码</h4>
<p>4xx状态码表示客户端错误，主要有下面几种。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 5xx 状态码</h4>
<p>5xx状态码表示服务端错误。一般来说，API 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 服务器回应</h3>
<h4> 不要返回纯本文</h4>
<p>API 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 HTTP 头的 <strong>Content-Type</strong> 属性要设为 <strong>application/json</strong>。</p>
<p>客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。下面是一个例子。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 发生错误时，不要返回 200 状态码</h4>
<p>有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面，就像下面这样。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，解析数据体以后，才能得知操作失败。</p>
<p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 提供链接</h4>
<p>API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。</p>
<blockquote>
<p>举例来说，GitHub 的 API 都在 <a href="http://api.github.com" target="_blank" rel="noopener noreferrer">api.github.com</a> 这个域名。访问它，就可以得到其他 URL。</p>
</blockquote>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 <a href="http://api.github.com" target="_blank" rel="noopener noreferrer">api.github.com</a> 一步步查找就可以了。</p>
<p>HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p>
<div class="language-http line-numbers-mode" data-ext="http"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>组件通讯方式</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Communicate/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Communicate/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">组件通讯方式</source>
      <description>Vue中的8种组件通信方式 Vue是数据驱动视图更新的框架，所以对于vue来说组件间的数据通信非常重要。 常见使用场景可以分为三类: 父子组件通信: props/$emit $parent/$children provide/inject ref $attrs/$listeners 兄弟组件通信: eventBus Vuex 跨级通信: eventBus Vuex provide/inject $attrs/$listeners</description>
      <category>VUE</category>
      <pubDate>Wed, 01 Jun 2022 16:21:10 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Vue中的8种组件通信方式</h1>
<p>Vue是数据驱动视图更新的框架，所以对于vue来说组件间的数据通信非常重要。</p>
<p>常见使用场景可以分为三类:</p>
<ul>
<li>
<p>父子组件通信: props/$emit  $parent/$children provide/inject ref $attrs/$listeners</p>
</li>
<li>
<p>兄弟组件通信: eventBus Vuex</p>
</li>
<li>
<p>跨级通信: eventBus Vuex provide/inject $attrs/$listeners</p>
</li>
</ul>
<!-- more -->
<h2> props / $emit （最常用的组建通信方式）</h2>
<p>父组件通过props的方式向子组件传递数据，而通过$emit 子组件可以向父组件通信。</p>
<h3> 父组件向子组件传值（props）</h3>
<ul>
<li>传入一个静态的值</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>传入一个动态的值，任何类型的值都可以传给一个 prop。</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>总结：props 只可以在父子组件中通信，即单向数据流。而且 props 是只读的，不可以被修改，所有修改都会被警告。</p>
</blockquote>
<h3> 子组件向父组件传值（$emit）</h3>
<p>子组件通过 $emit 将参数传递给父组件,父组件通过v-on监听并接收参数。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> $children / $parent</h2>
<p><code>$parent</code> 可以访问到当前组件的父组件实例，<code>$children</code> 可以访问到当前组件的子组件实例。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>注意：<code>$parent</code> 和 <code>$children</code> 得到的值不一样，<code>$children</code> 的值是数组，而 <code>$parent</code> 是个对象。</p>
</blockquote>
<h2> provide/ inject</h2>
<p>provide/ inject 就是父组件中通过provide来提供变量, 然后在子组件中通过inject来注入变量。</p>
<p>provide 是一个对象或返回一个对象的函数。inject 是一个数组或对象。</p>
<p>注意: 这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中获取数据。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> ref / refs</h2>
<p>ref：在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；用在组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> eventBus</h2>
<p>eventBus 又称为事件总线，在vue中是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件。</p>
<ul>
<li>初始化</li>
</ul>
<p>首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它.</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>发送事件</li>
</ul>
<p>假设你有两个组件: additionNum 和 showNum, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例:</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>接收事件</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就实现了在组件addtionNum.vue中点击相加按钮, 在showNum.vue中利用传递来的 num 展示求和的结果.</p>
<ul>
<li>移除事件监听者</li>
</ul>
<p>如果想移除事件的监听, 可以像下面这样操作:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> Vuex</h2>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，主要解决的是开发大型单页面项目的组件通信问题。</p>
<h2> $attrs与 $listeners</h2>
<p>为了解决该需求，引入了 <code>$attrs</code> 和 <code>$listeners</code>， 新增了inheritAttrs 选项。 默认情况下,父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会“回退”且作为普通的HTML特性应用在子组件的根元素上。接下来看一个跨级通信的例子:</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> localStorage / sessionStorage#</h2>
<p>通过 window.localStorage.getItem(key) 获取数据，通过 window.localStorage.setItem(key,value) 存储数据。</p>
<h2> 总结：</h2>
<p>props / $emit 是使用最多，也最推荐的方式。适用于父子组件通信。</p>
<p>Vuex 是 Vue 官方提供的组件通信方式，适用于构建大型单页面项目。</p>
<p><code>$children</code> / <code>$parent</code> ，<code>ref</code> ，<code>$attr</code> / <code>$listener</code> 主要是通过操作父子组件的实例来获取组件的数据，实现组件通信。</p>
]]></content:encoded>
    </item>
    <item>
      <title>点击组件外部</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Directive/ClickOutside/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Directive/ClickOutside/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">点击组件外部</source>
      <description>如何使用 &amp;lt;button @click=&amp;quot;add&amp;quot; v-click-outside:[capture]=&amp;quot;reset&amp;quot; v-click-outside:[capture].mousedown=&amp;quot;reset&amp;quot; v-click-outside:[capture].touchstart=&amp;quot;reset&amp;quot; &amp;gt;测试按钮&amp;lt;/button&amp;gt;</description>
      <category>VUE</category>
      <pubDate>Sat, 18 Feb 2023 22:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 如何使用</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 指令源代码</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>生命周期</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/LifeCycle/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/LifeCycle/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">生命周期</source>
      <description>前言 每个Vue实例再被创建之前，都会经过一系列的初始化过程，这个过程被称之为vue的生命周期。</description>
      <category>VUE</category>
      <pubDate>Wed, 22 Feb 2023 15:55:13 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 前言</h1>
<p>每个Vue实例再被创建之前，都会经过一系列的初始化过程，这个过程被称之为vue的生命周期。</p>
<!-- more -->
<p>下面这张官网的图，想必大家都熟悉，那让我们一步一步的分析，并最后验证一下。</p>

<p>图中可以看到在一整个生命周期中会有很多的钩子函数，不同的钩子函数提供给我们在vue生命周期不同的时刻进行的操作, 那么我们先列出所有的钩子函数，然后我们再一一详解：</p>
<blockquote>
<p>结合下面的Vue生命周期案例，F12看控制台更容易理解。</p>
</blockquote>

<h2> beforeCreate（创建前）</h2>
<p>此阶段为实例初始化之后，此时的数据观察和事件机制都未形成，不能获得DOM节点。</p>
<p>在 <strong>beforeCreate</strong> 和 <strong>created</strong> 生命周期之间，进行 <strong>初始化事件，进行数据的观测</strong> ，这时候我们可以看到在created钩子的时候数据已经和data中的属性进行绑定（其中在data中的属性值发生改变的时候，视图也会相对应改变，即所谓的双向绑定）。</p>
<p>注意事项：此时并没有el</p>
<h2> created（创建后）</h2>
<p>此阶段vue实例已经创建，仍然不能获取DOM元素。</p>
<p>在 <strong>created</strong> 和 <strong>beforeMount</strong> 生命周期之间，发生的事情相对比较多，结合官网给出的生命周期图可以分析下：</p>

<p>首先会判断对象是否有 <strong>el</strong> 。如果有的话就继续向下编译，如果没有el选项，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。</p>
<blockquote>
<p>此时注释掉demo代码中的 <strong>el: '#app'</strong> ，然后可以看到控制台打印的日志到created的时候就停止了，如果我们在代码后面继续调用 <strong>vm.$mount(el)</strong> ，可以发现代码继续向下执行了，其中这个 <strong>el</strong> 参数就是挂载的dom节点</p>
</blockquote>
<p>然后，我们往下看，<strong>template</strong> 参数选项的对生命周期的影响。</p>
<ol>
<li>
<p>如果vue实例对象中有template参数选项，则将其作为模板编译成 <strong>render函数</strong>。</p>
</li>
<li>
<p>如果没有template选项，则将外部HTML作为模板编译。</p>
</li>
<li>
<p>可以看到template中的模板优先级要高于outer HTML的优先级。</p>
</li>
</ol>
<blockquote>
<p>vue中还有一个 <strong>render 函数</strong> ，它是以createElement作为参数，然后做渲染操作，而且我们可以直接嵌入JSX，可以看到页面中渲染的是： <strong>render function</strong> 。若没有 <strong>rennder 函数</strong> ，则观察demo中的template参数，在有这个参数的时候，页面渲染出来的结果为 <strong>Vue的生命周期 --- 这是在template中的</strong> ，若注释掉 <strong>template</strong> 参数，则页面渲染结果为 <strong>Vue的生命周期 --- 这是在outer HTML中的</strong> ，证明以上三点结论。</p>
</blockquote>
<p>同时，也可以从侧面解释为什么 <strong>Has 'el' option</strong> 要在 <strong>Has 'template' option</strong> 之前，因为vue需要通过 <strong>el</strong> 去找到对应的 <strong>outer html</strong> ，最终可得出优先级结论：<strong>render函数选项 &gt; template选项 &gt; outer HTML</strong></p>
<h2> beforeMount（载入前）</h2>
<p>此阶段，依然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行。</p>

<p>在 <strong>beforeMount</strong> 和 <strong>mounted</strong> 生命周期之间，可以看到此时是给vue实例对象添加 <strong>$el成员</strong> ，并且替换掉挂载的DOM元素。</p>
<blockquote>
<p>demo中控制台打印的日志可以看出生命周期在 <strong>beforeMount</strong> 之前时 <strong>el</strong> 是undefined。</p>
<p>同时，我们可以看下控制台打印的日志，<strong>beforeMount</strong> 和 <strong>mounted</strong> 两个生命周期上的 <strong>el</strong> ，在beforeMount时h1中还是使用 <strong>{{ message + '  --- 这是在outer HTML中的' }}</strong> 进行占位，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。</p>
</blockquote>
<h2> mounted（载入后）</h2>
<p>此阶段数据和DOM都已被渲染出来。</p>
<h2> beforeUpdate（更新前）</h2>
<p>此阶段，vue遵循数据驱动DOM的原则；函数在数据更新后虽然没立即更新数据，但是DOM中的数据会在Vue双向数据绑定的作用下改变。</p>
<h2> updated（更新后）</h2>
<p>此阶段DOM会和更改过的内容同步。</p>
<h2> beforeDestroy（销毁前）</h2>
<h2> destroyed（销毁后）</h2>
]]></content:encoded>
    </item>
    <item>
      <title>Vue相关面试问题</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Question/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Question/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Vue相关面试问题</source>
      <description>常问问题 vue-router实现原理的histroy相关的api vue项目想要改变element-ui的组件内部的样式，默认情况下style加了scope无法修改，需怎么做 v-if 和 v-for优先级 详情 v-if和v-for是开发中经常会遇到的2个指令，那么在使用的过程中，二者如果同时存在同一个标签上，谁的优先级会更高一点呢？ 那么我们从源码的角度去看他，源码位置： compiler/codegen/index.js 在genElement方法中，我们可以看到一些if else的判断 if (el.staticRoot &amp;amp;&amp;amp; !el.staticProcessed) { return genStatic(el, state) } else if (el.once &amp;amp;&amp;amp; !el.onceProcessed) { return genOnce(el, state) } else if (el.for &amp;amp;&amp;amp; !el.forProcessed) { return genFor(el, state) } else if (el.if &amp;amp;&amp;amp; !el.ifProcessed) { return genIf(el, state) } else if (el.tag === &amp;apos;template&amp;apos; &amp;amp;&amp;amp; !el.slotTarget &amp;amp;&amp;amp; !state.pre) { return genChildren(el, state) || &amp;apos;void 0&amp;apos; } else if (el.tag === &amp;apos;slot&amp;apos;) { return genSlot(el, state) } else { // component or element let code if (el.component) { code = genComponent(el.component, el, state) } else { let data if (!el.plain || (el.pre &amp;amp;&amp;amp; state.maybeComponent(el))) { data = genData(el, state) } const children = el.inlineTemplate ? null : genChildren(el, state, true) code = `_c(&amp;apos;${el.tag}&amp;apos;${ data ? `,${data}` : &amp;apos;&amp;apos; // data }${ children ? `,${children}` : &amp;apos;&amp;apos; // children })` } // module transforms for (let i = 0; i &amp;lt; state.transforms.length; i++) { code = state.transforms[i](el, code) } return code } 处理for循环是处于if的上面的，所以我们由此可以判定v-for的优先级是高于v-if的。 我们经常会遇见这种情况，在v-for的时候，在数组中会有一些需要进行v-if的判断，这种情况下，我们如果先使用computed将不需要渲染的项过滤出来，那么在进行v-for的时候，循环的就只是需要渲染的项，这也是提升vue性能的一种方式。</description>
      <category>Question</category>
      <pubDate>Mon, 16 May 2022 11:21:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 常问问题</h2>
<h3> vue-router实现原理的histroy相关的api</h3>
<h3> vue项目想要改变element-ui的组件内部的样式，默认情况下style加了scope无法修改，需怎么做</h3>
<h3> v-if 和 v-for优先级</h3>
<details class="hint-container details"><summary>详情</summary>
<p><strong>v-if和v-for是开发中经常会遇到的2个指令，那么在使用的过程中，二者如果同时存在同一个标签上，谁的优先级会更高一点呢？</strong></p>
<p>那么我们从源码的角度去看他，源码位置： compiler/codegen/index.js</p>
<p>在genElement方法中，我们可以看到一些if else的判断</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>处理for循环是处于if的上面的，所以我们由此可以判定v-for的优先级是高于v-if的。</p>
</blockquote>
<p>我们经常会遇见这种情况，在v-for的时候，在数组中会有一些需要进行v-if的判断，这种情况下，我们如果先使用computed将不需要渲染的项过滤出来，那么在进行v-for的时候，循环的就只是需要渲染的项，这也是提升vue性能的一种方式。</p>
</details>
<h3> vue渐进式</h3>
<details class="hint-container details"><summary>详情</summary>
<p><strong>什么是渐进式</strong></p>
<p>先使用Vue的核心库，再根据你的需要的功能再去逐渐增加加相应的插件。</p>
<ul>
<li>渐进式代表的含义是：主张最少，</li>
<li>渐进式的含义，我的理解是：没有多做职责之外的事。</li>
</ul>
<p>Vue的核心的功能，是一个视图模板引擎，但这不是说Vue就不能成为一个框架。</p>
<p>在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统、客户端路由、大规模状态管理来构建一个完整的框架。</p>
<p>更重要的是，这些功能相互独立，你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。</p>
<p>可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。</p>
</details>
<h3> 优雅降级和渐进增强</h3>
<details class="hint-container details"><summary>详情</summary>
<p><strong>优雅降级</strong>：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。</p>
<p>如：border-shadow</p>
<p><strong>渐进增强</strong>：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
<p>如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验；</p>
</details>
<h2> 实例选项</h2>
<h3> extend(s)与mixins差异</h3>
<details class="hint-container details"><summary>详情</summary>
<ul>
<li>
<p><strong>Mixins 的使用方法：</strong></p>
<p>首先，我们先定义一个Mixins混入类对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，将对象混合到当前组件中：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​		Mixins选项接收一个混入对象的数组（即可以多个）。这些混入对象可以像正常实例对象一样包含实例选项，这些选项将会被合并到组件的选项中。</p>
<p>​		其中，有以下几点可以便于理解Mixins</p>
<ol>
<li>
<p>应用场景：在项目中，如果我们需要提取公用的数据或者通用的方法，并且这些数据与方法不需要组件间进行维护，就可以使用Mixins</p>
</li>
<li>
<p>特点：方法和参数在各组件中不共享</p>
<p>当值为对象的选项，如 <strong>methods,components</strong> 等，选项会被合并，键冲突的时候组件会覆盖混入对象</p>
<p>当值为函数的选项，如 <strong>created,mounted</strong> 等，就会被合并调用，混入对象钩子函数会比组件里的钩子函数先调用</p>
</li>
<li>
<p>与vuex的区别
vuex：用来做状态管理的（即全局），里面定义的变量在每个组件中均可以使用和修改，在任一组件中修改此变量的值之后，其他组件中此变量的值也会随之修改。
Mixins：可以定义共用的变量，在每个组件中使用，引入组件中之后，各个变量是相互独立的，值的修改在组件中不会相互影响。</p>
</li>
<li>
<p>与公共组件的区别
组件：父组件中引入子组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。
Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。</p>
</li>
<li>
<p>Mixins中的异步请求
当混合里面包含异步请求函数，而我们又需要在组件中使用异步请求函数的返回值时，我们应直接返回异步函数（即 new Promise）</p>
</li>
</ol>
</li>
<li>
<p><strong>extends 的使用方法：</strong></p>
</li>
</ul>
<p>首先，我们先定义一个extend对象。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，将对象混合到当前组件中：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中，有以下几点可以便于理解extends</p>
<ol>
<li>extends和Mixins类似，通过暴露一个extends对象到组件中使用。</li>
<li>extends会比Mixins先执行。执行顺序：extends &gt; Mixins&gt; 组件</li>
<li>extends只能暴露一个extends对象，暴露多个extends不会执行</li>
</ol>
<ul>
<li><strong>extend 的使用方法：</strong></li>
</ul>
<p>vue.extend()方法其实是vue的一个构造器，继承自vue，可以通过extent拓展全局组件，首先我们新建一个 hello.vue</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，我们在同级新建一个 hello.js</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后在main.js引入</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>extend,extends, Mixins 区别</strong></li>
</ul>
<p>Vue.extend创建组件的构造函数，为了复用</p>
<p>Mixins 可以混入多个Mixin ，extends只能继承一个</p>
<p>Mixins 类似于面向切面的编程（AOP），extends类似于面向对象的编程</p>
<p>优先级Vue.extend&gt;extends&gt;Mixins</p>
</details>
<h3> created与activated差异</h3>
<details class="hint-container details"><summary>详情</summary>
<ul>
<li>keep-alive 有什么作用？</li>
</ul>
<p>使用 &lt;<strong>keep-alive</strong>&gt; 会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务。
被包含在 &lt;<strong>keep-alive</strong>&gt; 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated</p>
<ul>
<li>keep-alive 在vue的生命周期中赋予了什么新的钩子？</li>
</ul>
<p>activated：在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用。</p>
<p>deactivated：在组件被停用时调用。</p>
<p>注意：只有组件被 keep-alive 包裹时，这两个生命周期才会被调用，如果作为正常组件使用，是不会被调用，以及在 2.1.0 版本之后，使用 exclude 排除之后，就算被包裹在 &lt;<strong>keep-alive</strong>&gt; 中，这两个钩子依然不会被调用！另外在服务端渲染时此钩子也不会被调用的。</p>
<ul>
<li>什么时候获取数据？</li>
</ul>
<p>当引入 keep-alive 的时候，页面第一次进入，钩子的触发顺序created -&gt; mounted-&gt; activated，退出时触发deactivated。当再次进入（前进或者后退）时，只触发activated。</p>
<p>我们知道 keep-alive 之后页面模板第一次初始化解析变成HTML片段后，再次进入就不在重新解析而是读取内存中的数据，即只有当数据变化时，才使用VirtualDOM进行diff更新。有需要的话，页面进入的数据获取应该在activated中也放一份。数据下载完毕手动操作DOM的部分也应该在activated中执行才会生效。</p>
<p>所以，有需要的话，应该activated中留一份数据获取的代码，或者不要created部分，直接将created中的代码转移到activated中。</p>
<p><strong>注意</strong></p>
<blockquote>
<p>created()：在创建vue对象时，当html渲染之前就触发；但是注意，全局vue.js不强制刷新或者重启时只创建一次，也就是说，created()只会触发一次；</p>
<p>activated()：在vue对象存活的情况下，进入当前存在activated()函数的页面时，一进入页面就触发；可用于初始化页面数据等</p>
</blockquote>
</details>
<h3> vue的computed跟普通的函数有什么区别吗，computed怎么实现缓存的，有看过源码吗</h3>
<h2> webpack模块</h2>
<h3> webpack中 bundle chunk module 有什么区别</h3>
<h3> webpack中 plugin loader 有什么区别</h3>
]]></content:encoded>
    </item>
    <item>
      <title>父组件里监听子组件的生命周期</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/@Hook/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/@Hook/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">父组件里监听子组件的生命周期</source>
      <description>前言 比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，常规的写法可能如下： // Parent.vue &amp;lt;template&amp;gt; &amp;lt;Child @mounted=&amp;quot;() =&amp;gt; {}&amp;quot;/&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { // Child.vue mounted() { this.$emit(&amp;quot;mounted&amp;quot;); } } &amp;lt;/script&amp;gt;</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 09:57:46 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 前言</h3>
<p>比如有父组件 <code>Parent</code> 和子组件 <code>Child</code>，如果父组件监听到子组件挂载 <code>mounted</code> 就做一些逻辑处理，常规的写法可能如下：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 技巧</h3>
<p>此外，还有一种特别简单的方式，子组件不需要任何处理，只需要在父组件引用的时候通过<code>@hook</code>来监听即可，<code>@hook</code>也可以监听<code>其它的生命周期</code>事件,代码如下：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 源码</h3>
<p>实现原理在<code>vue</code>源码的 <code>/src/core/instance/lifecycle.js</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Computed中使用this</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Computed/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Computed/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">Computed中使用this</source>
      <description>我们平时在 computed 属性中可以通过 this.xxx 去拿 data 里面的数据和 methods 里面的方法， 或许还会通过 this.$store 去拿 vuex 的 state 和 commit 等， 甚至，还会通过 this.$route 去获取路由里面的数据。 其实，我们可以避免这些丑陋的this，它甚至会给我们带来看不见的性能问题。</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 09:58:16 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们平时在 <code>computed</code> 属性中可以通过 <code>this.xxx</code> 去拿 <code>data</code> 里面的数据和 <code>methods</code> 里面的方法，</p>
<p>或许还会通过 <code>this.$store</code> 去拿 <code>vuex</code> 的 <code>state</code> 和 <code>commit</code> 等，</p>
<p>甚至，还会通过 this.<code>$route</code> 去获取路由里面的数据。</p>
<p>其实，我们可以避免这些丑陋的this，它甚至会给我们带来看不见的性能问题。</p>
<p>实现上，我们通过this能访问到的数据，在 <code>computed</code> 的 <code>第一个参数</code> 上都能 <code>解构</code> 出来。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>上下文批量引入</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Context/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Context/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">上下文批量引入</source>
      <description>前言 &amp;lt;script&amp;gt; import Comp1 from &amp;apos;@/components/Comp1&amp;apos; import Comp2 from &amp;apos;@/components/Comp2&amp;apos; import Comp3 from &amp;apos;@/components/Comp3&amp;apos; export default { components: { Comp1, Comp2, Comp3 } } &amp;lt;/script&amp;gt;</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 09:58:22 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 前言</h3>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 技巧</h3>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>引入多个组件，常常用来在组件内引入多个组件, <code>require.context(directory, useSubdirectories, regExp)</code></p>
</div>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在<code>main.js</code>中引入大量公共组件,利用 <code>require.context</code> 可以写成</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>数据冻结</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Freeze/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Freeze/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">数据冻结</source>
      <description>警告 vue 2.0版本会通过 Object.defineProperty 对数据进行劫持，遇到数组和对象必须循环遍历所有的域值才能劫持每一个属性。 vue 3.0版本会通过 Proxy 构造函数来进行数据劫持，来实现视图响应数据的变化 然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间。</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 09:59:01 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container danger">
<p class="hint-container-title">警告</p>
<p>vue 2.0版本会通过 <code>Object.defineProperty</code> 对数据进行劫持，遇到数组和对象必须循环遍历所有的域值才能劫持每一个属性。</p>
<p>vue 3.0版本会通过 <code>Proxy</code> 构造函数来进行数据劫持，来实现视图响应数据的变化</p>
</div>
<p>然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间。</p>
<p>所以，我们可以通过 <code>Object.freeze</code> 方法来冻结一个对象，这个对象一旦被冻结，vue就不会对数据进行劫持了。</p>
<p><code>Object.freeze()</code> 可以冻结一个对象，冻结之后不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。该方法返回被冻结的对象。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>懒加载</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/LazyLoader/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/LazyLoader/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">懒加载</source>
      <description>路由懒加载（能让你首次加载更快） 路由懒加载可以让我们的包不需要一次把所有的页面的加载进来，只加载当前页面的路由组件就行。 举个栗子🌰，如果这样写，加载的时候会全部都加载进来。 const router = new VueRouter({ routes:[ { path: &amp;apos;/&amp;apos;, name: &amp;apos;Home&amp;apos;, component: Home }, { path: &amp;apos;/about&amp;apos;, name: &amp;apos;About&amp;apos;, component: About } ] })</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 09:59:37 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 路由懒加载（能让你首次加载更快）</h3>
<p><code>路由懒加载</code>可以让我们的包不需要一次把所有的页面的加载进来，只加载当前页面的路由组件就行。</p>
<p>举个栗子🌰，如果这样写，加载的时候会全部都加载进来。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，应该避免上面的写法，尽量使用懒加载。</p>
<p>路由的懒加载可以分为以下<code>三种</code>写法。</p>
<ul>
<li>Vue异步组件</li>
<li>es6的import</li>
<li>webpack提供的require.ensure()</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 组件懒加载（按需加载）</h3>
<p>举个栗子🌰，如果这样写，加载的时候会全部都加载进来。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，应该避免上面的写法，尽量使用组件懒加载。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>异步组件还有一种比较完善的写法</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
]]></content:encoded>
    </item>
    <item>
      <title>插槽</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Slot/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Slot/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">插槽</source>
      <description>默认内容和扩展点 Vue中的槽可以有默认的内容，这使我们可以制作出更容易使用的组件。 &amp;lt;template&amp;gt; &amp;lt;button class=&amp;quot;button&amp;quot; @click=&amp;quot;$emit(&amp;apos;click&amp;apos;)&amp;quot;&amp;gt; &amp;lt;slot&amp;gt; &amp;lt;!-- Used if no slot is provided --&amp;gt; Click me &amp;lt;/slot&amp;gt; &amp;lt;/button&amp;gt; &amp;lt;/template&amp;gt;</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 09:59:47 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 默认内容和扩展点</h3>
<p>Vue中的<code>槽</code>可以有默认的内容，这使我们可以制作出更容易使用的组件。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以取组件的<strong>任何部分</strong>，将其封装在一个插槽中，在外面可以用想要的任何内容覆盖组件的该部分。</p>
<p>默认情况下，它仍然会按照原来的方式工作，但这样做会有了更多的选项。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在可以用许多不同的方式使用这个组件。简单的、默认的方式，或者自定义的方式。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 单个作用域插槽的简写(不需要 template 标签)</h3>
<p>限定范围的插槽非常有趣，但为了使用它们，您还必须使用许多模板标记。</p>
<blockquote>
<p>幸运的是，有一个简写可以让我们摆脱它，但只有在我们使用<code>单个作用域槽</code>的情况下。</p>
</blockquote>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 有条件地渲染插槽</h3>
<p>先来看如何做，然后在讨论为什么想隐藏插槽。</p>
<p>每个Vue组件都有一个特殊的<code>$slots</code>对象，里面有你所有的插槽。默认槽的键是<code>default</code>，任何被命名的槽都使用其称名作为键。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但这个 <code>$slots</code> 对象只有适用于该组件的插槽，而不是每一个定义的插槽。</p>
<p>拿这个定义了几个插槽的组件来说，包括几个命名的插槽。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果只对组件应用一个插槽，那么只有那个插槽会显示在我们的 <code>$slots</code> 对象中。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以在组件中使用这一点来检测 <code>哪些插槽已经被应用</code> 到组件中，例如，通过隐藏插槽的包装元素。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，应用样式的包装器 <code>div</code> 只有在我们用某些东西填充这个插槽时才会被渲染。</p>
<p>如果不使用 <code>v-if</code> ，那么，当没有插槽时，就会得到一个空的不必要的div。</p>
<p>根据div的样式，这可能会打乱我们的布局，让界面看起来很奇怪。</p>
<p>那么，为什么我们希望能够有条件地渲染插槽呢？</p>
<p>使用条件插槽的主要原因有三个:</p>
<ul>
<li>当使用封装的div来添加默认样式时</li>
<li>插槽是空的</li>
<li>如果将默认内容与嵌套槽相结合</li>
</ul>
<p>例如，在添加默认样式时，在插槽周围添加一个div</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，如果父组件没有将内容应用到该插槽中，最终会在页面上渲染出一个空的div。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方法就是像上面讲的一样，多个条件判断，就行啦。</p>
<h3> 如何监听一个插槽的变化</h3>
<p>有时需要知道插槽内的内容<strong>何时</strong>发生了变化。</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不幸的是，<strong>Vue没有内置的方法让我们检测这一点</strong>。</p>
<p>然而有一次想出了一个非常干净的方法，使用<code>MutationObserver</code>来做这件事。</p>
<p><code>MutationObserver</code>接口提供了监视对<code>DOM树</code>所做更改的能力。它被设计为旧的<code>Mutation Events</code>功能的替代品，该功能是<code>DOM3 Events</code>规范的一部分。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>父组件通信</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Sync/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue/Skill/Sync/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">父组件通信</source>
      <description>前言 vue中我们经常会用 v-bind(缩写为:) 给子组件传入参数，然后子组件 emit 事件去改变父组件的状态。 或者我们会给子组件传入一个函数，子组件通过调用传入的函数来改变父组件的状态。 举个例子🌰 &amp;lt;template&amp;gt; //父组件 给子组件传入一个函数 &amp;lt;MyFooter :age=&amp;quot;age&amp;quot; @setAge=&amp;quot;(res) =&amp;gt; age = res&amp;quot; /&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { data() { return { age: 1, // 父组件的变量 } }, //子组件 通过调用这个函数来实现修改父组件的状态。 mounted () { console.log(this.$emit(&amp;apos;setAge&amp;apos;, 1234567)); } } &amp;lt;/script&amp;gt;</description>
      <category>VUE</category>
      <pubDate>Thu, 23 Feb 2023 10:00:19 GMT</pubDate>
      <content:encoded><![CDATA[<h3> 前言</h3>
<p>vue中我们经常会用 <code>v-bind(缩写为:)</code> 给子组件传入参数，然后子组件 <code>emit</code> 事件去改变父组件的状态。</p>
<p>或者我们会给子组件传入一个函数，子组件通过调用传入的函数来改变父组件的状态。</p>
<p>举个例子🌰</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 技巧</h3>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p><code>.sync</code>提供了一种与父组件沟通的思路！ 你如果只是单纯的在<code>子组件</code>当中修改<code>父组件</code>的某个数据时，建议使用 <code>sync</code> ，简单，快捷，不需要在传一个自定义方法来接收了</p>
</div>
<p>现在只需要使用.sync就可以轻松更新赋组件的值</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>VUE3工具函数源码解析</title>
      <link>https://jin-shaohui.gitee.io/FrontEnd/Vue3/ToolFunction/</link>
      <guid>https://jin-shaohui.gitee.io/FrontEnd/Vue3/ToolFunction/</guid>
      <source url="https://jin-shaohui.gitee.io/rss.xml">VUE3工具函数源码解析</source>
      <description>Tips 具体文件是 shared.cjs.prod.js 和 shared.cjs.js 文件下针对源码中的工具函数和较冷门知识点的提取分析。 vue 版本为 3.2.31 常量定义 EMPTY_OBJ、EMPTY_ARR 对象 typescript是通过 readonly 的方式来定义一个冻结对象的类型的， readonly 是只读修饰符。 Object.freeze 冻结对象属性功能。</description>
      <category>VUE</category>
      <category>VUE3</category>
      <pubDate>Mon, 11 Jul 2022 13:41:55 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>具体文件是 <code>shared.cjs.prod.js</code> 和 <code>shared.cjs.js</code> 文件下针对源码中的工具函数和较冷门知识点的提取分析。</p>
<p>vue 版本为 3.2.31</p>
</div>
<h2> 常量定义</h2>
<h3> EMPTY_OBJ、EMPTY_ARR 对象</h3>
<p>typescript是通过 <code>readonly</code> 的方式来定义一个冻结对象的类型的， <code>readonly</code> 是只读修饰符。 <code>Object.freeze</code> 冻结对象属性功能。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> NOOP 空函数</h3>
<p>定义一个空函数，而不是 <code>function () {}</code> 这样定义，是为了方便压缩。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> NO 返回false常量函数</h3>
<p>永远返回 <code>false</code> 的函数, 就是一个返回 <code>boolean</code> 值的函数的备选项</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 函数定义</h2>
<h3> toTypeString  复杂数据类型区分</h3>
<p><code>toTypeString</code> 主要是返回数据的类型，使用了 <code>Object.prototype.toString.call</code> 的方法，实现了对复杂数据类型的区分</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> toRawType 取出数据类型</h3>
<p>这里需要注意的是前面的 <code>toTypeString</code> 返回了 <code>[object xxType]</code>，现在则是使用 <code>slice</code> 方法来将 <code>xxType</code> 取出</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> isOn 事件名on判断</h3>
<p>利用正则来判断当前的事件名是否是 <code>on + EventName</code> 的格式</p>
<p>注意: <code>^</code> 在正则开头表示首位占位符，其他地方都是非的含义，<code>[^a-z]</code> 表示不是 a 到 z 的字母</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> isModelListener 事件名onUpdate判断</h3>
<p>检验监听事件名是否是<code>onUpdate:</code>开头</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote>
<p><code>startsWith</code> 是 <code>es6</code> 当中的方法，可以获取一个字符串是否以指定的子字符串开头，返回Boolean类型</p>
</blockquote>
<ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> extend 合并对象</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> remove 删除数组元素</h3>
<p>删除数组中的某个元素，但是使用splice方法，其实是比较消耗性能的。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>axios源码中 <code>lib/core/interceptorManager.js</code> , 使用以下的方式删除数组中的元素:</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> hasOwn 是否包含属性</h3>
<p>判断一个属性是否是一个对象本身的属性，利用了 <code>Object.prototype.hasOwnProperty.call</code> 的形式来实现功能</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<ul>
<li><code>is</code> 关键字：它被称为类型谓词，用来判断一个变量属于某个接口或类型，比如：</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>keyof</code> 关键字：用于获取某种类型的所有键，其返回类型是联合类型，比如：</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>typeof</code> 关键字：js 中的 typeof 只能获取几种类型，而在 ts 中 typeof 用来获取一个变量声明或对象的类型，比如：</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> isArray 是否数组</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> isMap/isSet 是否Map/Set</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> Map</h4>
<p>Map 是一种 <code>es6</code> 提供的新的一种键值对数据结构的数据类型，相比于对象，它的键不同于对象那种只能是字符串的键，可以是各种类型。</p>
<ul>
<li>基础方法</li>
</ul>
<blockquote>
<p><code>get</code> 获取元素，
<code>set</code> 新增元素成员，
<code>has</code> 是否包含某元素，
<code>delete</code> 删除元素成员，
<code>clear</code> 清空所有元素，
<code>Array.from</code> 转为普通的二维数组</p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>遍历相关的方法</li>
</ul>
<blockquote>
<p><code>keys</code> 返回包含映射中 <strong>键</strong> 的迭代器对象，<code>entries</code> 返回包含映射中的 <strong>键值</strong> 的迭代器对象，<code>values</code> 返回包含映射中的 <strong>值</strong> 的迭代器对象，<code>forEach</code></p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>::: theorem Map和Object的区别:</p>
<ul>
<li>Map的键可以是<code>任意类型</code>, Object只能是 <code>String</code> 或者 <code>Symbol</code></li>
<li>Map的可以通过<code>size</code>属性获取元素数量, Object则必须<code>手动计算</code></li>
<li>Map在频繁<code>增减键值对</code>的场景下, <code>性能较好</code></li>
<li>Map中的数据是<code>有序</code>的, 而Object则是<code>无序</code>的
:::</li>
</ul>
<h4> Set</h4>
<p>Set类型是<code>es6</code>提供的一种新的数据类型，它允许你存入 <code>任意类型</code> 的 <code>唯一值</code> ，无论是 <code>基本数据类型</code> 还是 <code>引用类型</code> ，尽管NaN !== NaN，Set仍然认为这是同一个数据。</p>
<ul>
<li>基础方法</li>
</ul>
<blockquote>
<p><code>add</code> 新增元素成员，
<code>has</code> 是否包含某元素，
<code>delete</code> 删除元素成员，
<code>clear</code> 清空所有元素，
<code>Array.from</code> 转为数组</p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>遍历相关的方法</li>
</ul>
<blockquote>
<p>主要有<code>keys</code>，<code>entries</code>，<code>values</code>，<code>forEach</code></p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> isDate 是否时间</h3>
<ul>
<li>源码实现 </li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这么做有一定的漏洞，但一般还是可以判断</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> isFunction 是否函数</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> isObject 是否对象</h3>
<ul>
<li>注意事项</li>
</ul>
<blockquote>
<p><code>typeof null === 'object'</code>，所以必须确保val不为null。</p>
<p><code>Record</code>是 <code>typescript</code> 中的一种工具类型，它的作用是限制一个对象的键值类型，其两个泛型参数就是一个限制键类型，一个限制值类型。</p>
</blockquote>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Record使用案例:</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> isPlainObject 是否纯粹对象</h3>
<p>该方法作用是，判断一个对象<code>是否是纯粹的对象</code>，前面一个isObject方法，<code>isObject([])是true</code>，<code>isObject({})也是true</code>，而此处的isPlainObject则仅限于真正的Object。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> isPromise 是否Promise</h3>
<p>判断是否是promise对象，这里要注意的是Promise的类型，typescript 中 <code>Promise&lt;T&gt;</code> 类型，接受一个<code>泛型参数T</code>，用以确定这个promise对象最终<code>resolve的值的类型</code>。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>我们如何控制声明Promise返回值的类型:</p>
<ul>
<li>使用这里的泛型方式声明</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>单独声明resolve方法</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<h3> isIntegerKey 是否数字型的字符串</h3>
<p>主要是用于判断是否是数字型的字符串，形如: '123'，'888' 则为true，'123hello'则为false。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>parseInt 的第一个参数大家都很熟悉，就是要被转换的字符串，但是第二个出现的概率可能相对偏低，第二个表示的就是<code>进制</code>，一般<code>默认是10</code>，也就是十进制！
这里指明进制数是为了保证在不同的环境下运行结果能保证一致！</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> makeMap 构造带逗号的字符串校验字符函数</h3>
<p>该方法主要是接收一个<code>带逗号的字符串</code>，将该字符串以<code>逗号拆分</code>为一个个子字符串，再用这些子字符串作为一个对象的<code>键</code>，<code>值全部为true</code>；返回一个方法，这个方法可以检测出这个方法接收的参数是否是对象中的键。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>难点解析</li>
</ul>
<p>类型上来看，其实就是一个这样的方法：<code>(params1:string, params2?:boolean) =&gt; (key: string) =&gt; boolean</code>，其返回了一个检测函数，该检测函数接受一个字符串，返回是该字符串是否存在！</p>
<ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
</div>
<h3> cacheStringFunction 缓存结果函数</h3>
<p>函数<code>返回一个函数</code>，这个函数接收<code>一个字符串</code>参数，如果第一次传入了一个参数，计算结果就会被<code>闭包``缓存</code>起来，下次再遇到相同参数的时候，就不会再走<code>fn方法重新计算</code>了。
本质上是一个<code>单例模式</code>，利用闭包，保存了之前的计算结果。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
</div>
<h3> camelize 驼峰转化</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>关于replace的使用: <code>replace(regexp|substr, newSubStr|function)</code></p>
<blockquote>
<p>第一个参数既可以是<code>字符串</code>，也可以是<code>正则</code>，总之就是需要<code>被替换的字符串的文本模式</code>。</p>
<p>第二个参数，它既可以是用于<code>替换掉</code>第一个参数在原字符串中的匹配部分的<code>字符串</code>（该字符串中可以内插一些<code>特殊的变量名</code>），也可以是一个用来创建新子字符串的<code>函数</code>，该函数的返回值将替换掉第一个参数匹配到的结果。</p>
</blockquote>
<ul>
<li>正则替换表达式</li>
</ul>
<blockquote>
<p>$&amp; 用于无分组的情况</p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>$` 匹配到的数据的左边字符串</p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>$' 和 $` 相反，代表匹配到的数据的右边字符串</p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>$1,$2,$3,.....$n，表示第几个分组</p>
</blockquote>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>函数</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以得出结论，那就是<code>有分组</code>的情况下，第二个参数开始就是<code>依次展示</code>每次分组<code>匹配到的内容</code>。
所以，我们回到源码中，此处的<code>c</code>，实际上就是前面说的每次匹配到的<code>第一个分组</code>，本案例中依次为：h, c两个，然后将其改为大写，直接return，就能将<code>-x</code>替换为<code>X</code>，从而实现我们的目标。</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> hasChanged 比较变量相同</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>可能有人感到疑问，两个值是否不同还需要封装？多此一举，我直接 <code>a !== b</code> 不就行了？我们来看几个例子：</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由此可以看出，<code>Object.is</code>可以弥补 <code>正负0</code> 和 <code>NaN</code> 比较上存在的问题。MDN网站上还提供了一个<code>polyfill</code>：</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> def 添加不可枚举属性</h3>
<p>就是给对象<code>obj</code>，加上一个<code>可以删除</code>，其属性描述符<code>可以改变</code>，且<code>不可枚举的属性key</code>，其值为<code>value</code>。</p>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>使用案例</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试可枚举性，按照我们之前说的<code>for...in</code>，<code>Object.keys</code>，<code>JSON.stringify</code>三种方法</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>属性描述符可以细分为<code>数据描述符</code>和<code>存取描述符</code>。注意，configurable 和 enumerable既是数据描述符又是存取描述符。除了这两个属性之外，其他不同的描述符不得共用！</p>
<p>数据描述符：<code>writable</code> 只有writable为true的时候，该属性才能被改变值。 <code>value</code> 属性的值</p>
<p>存取描述符： <code>get</code>，<code>set</code></p>
</div>
<h3> toNumber 尝试转换数字</h3>
<ul>
<li>源码实现</li>
</ul>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">Tips</p>
<p>isNaN一看字面意思就知道: 判断一个值是否为NaN. 但他有一些怪异行为, 例如:</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很明显, 这个方法关心的根本不是一个值是否是NaN, 它似乎更关心一个值是否无法被转为数字! 所以, 我们有了Number.isNaN</p>
<div class="language-TypeScript line-numbers-mode" data-ext="TypeScript"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以, 一定要注意了, <code>isNaN</code>和<code>Number.isNaN</code>不是一回事!</p>
</div>
]]></content:encoded>
    </item>
  </channel>
</rss>